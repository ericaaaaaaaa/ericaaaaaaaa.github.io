<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta charset="UTF-8"><title>Data Structure | Erica's Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
<link href="https://fonts.googleapis.com/css?family=Amatic+SC|Lato|Source+Sans+Pro&display=swap" rel="stylesheet"><meta name="generator" content="Hexo 5.3.0"></head><body><div id="layout-page"><nav id="layout-menu"><div class="other-page hide"><a href="/about">About</a><a href="/archives">Blog</a></div><div class="responsive-pad"></div><div id="mega-head"><a href="/">Erica's Blog</a></div><div class="layout-socialmedia hide"><a class="link-item main-link-item" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ericaaaaaaaa"><i class="iconfont icon-github"></i></a></div><div class="responsive-bar" onclick="toggle(this)">≡</div></nav><div id="content"><article id="post"><h1>Data Structure</h1><time class="created-date" datetime="2021-01-17T13:32:43.000Z">2021-01-17</time><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的概念和表抽象数据类型"><a href="#线性表的概念和表抽象数据类型" class="headerlink" title="线性表的概念和表抽象数据类型"></a>线性表的概念和表抽象数据类型</h2><h3 id="表的概念和性质"><a href="#表的概念和性质" class="headerlink" title="表的概念和性质"></a>表的概念和性质</h3><ul>
<li><p>线性表</p>
<blockquote>
<p>一个（有穷或无穷）的基本元素集合 E, E 中一组有穷个元素排列成的序列 $L = (e_0, e_1, e_2, …,e_{n-1})$ </p>
</blockquote>
</li>
<li><p>下标</p>
</li>
<li><p>空表</p>
</li>
<li><p>长度</p>
</li>
<li><p>首元素 &amp; 尾元素</p>
<p>唯一</p>
</li>
<li><p>前驱元素</p>
</li>
<li><p>后继元素</p>
</li>
</ul>
<h3 id="表抽象数据类型"><a href="#表抽象数据类型" class="headerlink" title="表抽象数据类型"></a>表抽象数据类型</h3><h4 id="线性表的操作"><a href="#线性表的操作" class="headerlink" title="线性表的操作"></a>线性表的操作</h4><h4 id="表抽象数据类型-1"><a href="#表抽象数据类型-1" class="headerlink" title="表抽象数据类型"></a>表抽象数据类型</h4><h3 id="线性表的实现：基本考虑"><a href="#线性表的实现：基本考虑" class="headerlink" title="线性表的实现：基本考虑"></a>线性表的实现：基本考虑</h3><ol>
<li>空间（计算机内存）</li>
<li>时间（各种重要操作的效率）</li>
</ol>
<h2 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h2><blockquote>
<p><strong>顺序表</strong>——表中元素顺序存放在一片足够大的连续存储区内，首元素存入存储区开始位置，其余元素依次顺序存放，元素之间的逻辑顺序关系通过元素在存储区域里的物理位置表示。</p>
</blockquote>
<h3 id="基本实现方式"><a href="#基本实现方式" class="headerlink" title="基本实现方式"></a>基本实现方式</h3><p>若顺序表中存储的元素类型相同，则：</p>
<ul>
<li>存取操作可以在 O(1) 的时间内完成。</li>
<li>元素访问是 O(1) 复杂度的操作</li>
</ul>
<p>若顺序表中元素大小不统一，则</p>
<ul>
<li>可以将实际数据元素另行存储，在顺序表里各单元位置保存相应元素的引用信息（链接/索引）。</li>
</ul>
<h3 id="顺序表基本操作的实现"><a href="#顺序表基本操作的实现" class="headerlink" title="顺序表基本操作的实现"></a>顺序表基本操作的实现</h3><h4 id="创建和访问操作"><a href="#创建和访问操作" class="headerlink" title="创建和访问操作"></a>创建和访问操作</h4><ul>
<li><p>创建空表`</p>
<blockquote>
<p>创建新表的存储区后，应立即将两个表信息域(max 与 num) 设置好，保证这个表处于合法状态</p>
</blockquote>
</li>
<li><p>简单判断操作 O(1)</p>
<ul>
<li>空表：num == 0</li>
<li>表满：num == max</li>
</ul>
</li>
<li><p>访问给定下标 i 的元素 O(1)</p>
</li>
<li><p>遍历操作 O(n)</p>
</li>
<li><p>查找给定元素 d 的（第一次出现的）位置 O(n)</p>
</li>
<li><p>查找给定元素 d 在位置 k 后第一次出现的位置 O(n)</p>
</li>
</ul>
<h4 id="变动操作：加入元素"><a href="#变动操作：加入元素" class="headerlink" title="变动操作：加入元素"></a>变动操作：加入元素</h4><ul>
<li><p>尾端加入新数据项 O(1)</p>
</li>
<li><p>新数据存入元素存储区的第 i 个单元 </p>
<ul>
<li><p>不要求维持原有元素的相对位置：O(1)</p>
<blockquote>
<p>将原有第 i 个单元的元素放入 num，再将新元素写入第 i 个单元</p>
</blockquote>
</li>
<li><p>要求保持原有元素的相对位置： O(n)</p>
<blockquote>
<p>把包括第 i 个单元的所有单元向后平移一位，再将新元素写入第 i 个单元</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="变动操作：删除元素"><a href="#变动操作：删除元素" class="headerlink" title="变动操作：删除元素"></a>变动操作：删除元素</h4><ul>
<li><p>尾端删除数据 O(1)</p>
</li>
<li><p>删除位置 i 的数据</p>
<ul>
<li><p>软删除</p>
<blockquote>
<p>添加合法下标，再删除元素时将合法下标改为非法</p>
</blockquote>
</li>
<li><p>硬删除</p>
<ul>
<li><p>不需要保持原有顺序 O(1)</p>
<blockquote>
<p>将 num - 1 填入 i，再尾端删除</p>
</blockquote>
</li>
<li><p>需要保持原有顺序 O(n)</p>
<blockquote>
<p>将第 i 个删除，再将其后面的每个元素前移一位</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>基于条件的删除 O(n)</p>
<blockquote>
<p><strong>基于条件</strong>：不直接给出删除元素的位置，而是给出需要删除数据项的条件</p>
<p>需要通过循环实现，循环中逐个检查元素，查找到后将其删除。</p>
</blockquote>
</li>
</ul>
<h3 id="顺序表及其操作的性质"><a href="#顺序表及其操作的性质" class="headerlink" title="顺序表及其操作的性质"></a>顺序表及其操作的性质</h3><p><strong>顺序表优缺点总结：</strong></p>
<ul>
<li><strong>优点</strong>：<ul>
<li>O(1) 时间的（随机、直接的）按位置访问元素；</li>
<li>元素在表里存储紧凑，除表中的存储区之外只需要 O(1) 空间存放少量的辅助信息</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要连续的存储区存放表中的元素，若表很大，则需要大片连续的内存空间。</li>
<li>一旦确定了存储块的大小，可容纳单元个数并不随着插入 /删除操作的进行而变化。如果很大的存储区只保存了少量的数据项，就会有大量空闲单元，造成表内的存储浪费。</li>
<li>另外，在执行加入或删除操作时，通常需要移动许多元素，效率低。</li>
<li>最后，建立表需要考虑元素存储区大小，而实际需求通常很难事先估计。</li>
</ul>
</li>
</ul>
<h3 id="Python-的-list"><a href="#Python-的-list" class="headerlink" title="Python 的 list"></a>Python 的 list</h3><ul>
<li><p>创建线性表</p>
</li>
<li><p><code>lst = []</code></p>
</li>
<li><p>加入元素</p>
<ul>
<li>尾端加入单一元素：<code>lst.append(x)</code></li>
<li>将数据存入第 i 个单元：<code>lst.insert(i, x)</code></li>
</ul>
</li>
<li><p>删除元素</p>
<ul>
<li>删除尾端元素：<code>lst.pop()</code></li>
<li>删除下标为 i 的元素：<code>lst.pop(i)</code></li>
<li>删除第一个内容为 x 的元素：<code>lst.remove(x)</code></li>
</ul>
</li>
<li><p>求表长</p>
<ul>
<li><code>len(lst)</code></li>
</ul>
</li>
<li><p>清除 list 中的所有元素</p>
<ul>
<li><code>lst.clear()</code></li>
</ul>
</li>
<li><p>将 list 中的元素倒置</p>
<ul>
<li><code>lst.reverse()</code></li>
</ul>
</li>
<li><p>将 list 中的元素排序</p>
<ul>
<li><code>sort</code>：会修改 list 本身，不会返回新的 list</li>
<li><code>sorted</code>：不会修改 list 本身，会返回排序好的 list</li>
</ul>
<pre><code class="python">lst = [3,4,5,1,2]
print(lst.sort())   # None
print(lst)          # [1,2,3,4,5]
######
lst = [3,4,5,1,2] 
print(sorted(lst))  # [1,2,3,4,5]
print(lst)          # [3,4,5,1,2]</code></pre>
</li>
</ul>
<h2 id="链接表（链表）"><a href="#链接表（链表）" class="headerlink" title="链接表（链表）"></a>链接表（链表）</h2><h3 id="线性表的基本需要和链接表"><a href="#线性表的基本需要和链接表" class="headerlink" title="线性表的基本需要和链接表"></a>线性表的基本需要和链接表</h3><p>链接表的基本思路：</p>
<ul>
<li>把表中的元素分别存储在一批独立的存储块（称为表的结点）里</li>
<li>保证从组成表结构中的任一个节点可找到于其相关的下一个结点</li>
<li>在前一结点里用链接的方式显式地记录与下一个结点的关联</li>
</ul>
<h3 id="单向链接表（单链表）"><a href="#单向链接表（单链表）" class="headerlink" title="单向链接表（单链表）"></a>单向链接表（单链表）</h3><p><img src="/2021/01/17/Data%20Structure/image/linear_table.png" alt="image-20210103164334335"></p>
<p><img src="/2021/01/17/Data%20Structure/image/linear_table_1.png" alt="image-20210103164051115"></p>
<ul>
<li>一个单链表由一些具体的表结点构成</li>
<li>每个结点是一个对象，由自己的标识，下面也常称其为该节点的链接</li>
<li>结点之间通过结点链接建立其单向顺序联系</li>
</ul>
<pre><code class="python"># 定义一个简单的表结点类
class LNode:
    def __init__(self, elem, next_ = None):
        self.elem = elem
        self.next = next_ # 为了避免与 python 标准函数 next 重名</code></pre>
<h3 id="基本链表操作"><a href="#基本链表操作" class="headerlink" title="基本链表操作"></a>基本链表操作</h3><h4 id="创建空链表"><a href="#创建空链表" class="headerlink" title="创建空链表"></a>创建空链表</h4><p>把相应的表头变量设置为空连接</p>
<h4 id="删除链表"><a href="#删除链表" class="headerlink" title="删除链表"></a>删除链表</h4><p>将表指针赋值为 <code>None</code></p>
<h4 id="判断表是否为空"><a href="#判断表是否为空" class="headerlink" title="判断表是否为空"></a>判断表是否为空</h4><p>检查表头指针是否为 <code>None</code></p>
<h4 id="判断表是否满"><a href="#判断表是否满" class="headerlink" title="判断表是否满"></a>判断表是否满</h4><p>一般链表不会满</p>
<h3 id="加入元素"><a href="#加入元素" class="headerlink" title="加入元素"></a>加入元素</h3><h4 id="表首端插入"><a href="#表首端插入" class="headerlink" title="表首端插入"></a>表首端插入</h4><ol>
<li>创建一个新结点并存入数据</li>
<li>把原链表首结点的链接存入新结点的链接域 <code>next</code></li>
<li>修改表头变量，使之指向新结点</li>
</ol>
<pre><code class="python">q = LNode(13)
q.next = head
head = q</code></pre>
<h4 id="一般情况的元素插入"><a href="#一般情况的元素插入" class="headerlink" title="一般情况的元素插入"></a>一般情况的元素插入</h4><ol>
<li>创建一个新结点并存入数据</li>
<li>把 <code>pre</code> 所指结点的 <code>next</code> 域的值存入新结点的链接域 <code>next</code></li>
<li>修改 <code>pre</code> 的 <code>next</code> 域，使之指向新结点</li>
</ol>
<p><img src="/2021/01/17/Data%20Structure/image/linear_insert_1.png" alt="image-20210103170529842"></p>
<pre><code class="python">q = LNode(13)
q.next = pre.next
pre.next = q</code></pre>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><h4 id="删除表首元素"><a href="#删除表首元素" class="headerlink" title="删除表首元素"></a>删除表首元素</h4><p>修改表头指针，令其指向表中的第二个结点</p>
<pre><code class="python">head = head.next</code></pre>
<h4 id="一般情况的元素删除"><a href="#一般情况的元素删除" class="headerlink" title="一般情况的元素删除"></a>一般情况的元素删除</h4><p><img src="/2021/01/17/Data%20Structure/image/linear_delete.png" alt="image-20210103170904240"></p>
<pre><code class="python">pre.next = pre.next.next</code></pre>
<h3 id="扫描、定位和遍历"><a href="#扫描、定位和遍历" class="headerlink" title="扫描、定位和遍历"></a>扫描、定位和遍历</h3><pre><code class="python">p = head
while p is not None and 还需要继续的其它条件:
    对 p 所指结点里的数据做所需操作
    p = p.next</code></pre>
<h4 id="按下标定位"><a href="#按下标定位" class="headerlink" title="按下标定位"></a>按下标定位</h4><pre><code class="python">p = head
while p is not None and i &gt; 0:
    i -= 1
    p = p.next</code></pre>
<h4 id="按元素定位"><a href="#按元素定位" class="headerlink" title="按元素定位"></a>按元素定位</h4><pre><code class="python">p = head
while p is not None and not pred(p.elem):
    p = p.next</code></pre>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><pre><code class="python">p = head
while p is not None:
    p = p.next</code></pre>
<h3 id="链表操作的复杂度"><a href="#链表操作的复杂度" class="headerlink" title="链表操作的复杂度"></a>链表操作的复杂度</h3><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">具体说明</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">创建空表</td>
<td align="center"></td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">删除表</td>
<td align="center"></td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">判断空表</td>
<td align="center"></td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">加入元素</td>
<td align="center">首端加入元素</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">尾端加入元素</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">定位加入元素</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">删除元素</td>
<td align="center">首端删除元素</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">尾端删除元素</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">定位删除元素</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">其它删除：通常需要扫描一整个表或者一部分</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<h3 id="求表的长度-O-n"><a href="#求表的长度-O-n" class="headerlink" title="求表的长度 O(n)"></a>求表的长度 O(n)</h3><pre><code class="python">def length(head):
    p, n = head, 0
    while p is not None:
        n += 1
        p = p.next
    return n</code></pre>
<h2 id="链表的变形和操作"><a href="#链表的变形和操作" class="headerlink" title="链表的变形和操作"></a>链表的变形和操作</h2><h3 id="单链表的简单变形"><a href="#单链表的简单变形" class="headerlink" title="单链表的简单变形"></a>单链表的简单变形</h3><p>在表对象中加入一个表尾引用域</p>
<h3 id="循环单链表（循环链表）"><a href="#循环单链表（循环链表）" class="headerlink" title="循环单链表（循环链表）"></a>循环单链表（循环链表）</h3><p>最后一个结点的 <code>next</code> 域不用 <code>None</code>，而是指向表的第一个结点。</p>
<h3 id="双向链接表（双链表）"><a href="#双向链接表（双链表）" class="headerlink" title="双向链接表（双链表）"></a>双向链接表（双链表）</h3><p>节点之间由双向链接: <code>prev</code>, <code>next</code></p>
<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><h3 id="链表的排序"><a href="#链表的排序" class="headerlink" title="链表的排序"></a>链表的排序</h3><p>排序操作见后文“内部排序”</p>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="栈、队列和数据使用顺序"><a href="#栈、队列和数据使用顺序" class="headerlink" title="栈、队列和数据使用顺序"></a>栈、队列和数据使用顺序</h3><h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h4><p>栈是保证元素<strong>后进先出</strong>（后存入先使用， Lat In First Out, LIFO） 关系的结构，简称 LIFO 结构。</p>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>队列是保证元素<strong>先进先出</strong>（先存入者先使用，First In First Out, FIFO）关系的结构，简称 FIFO 结构。</p>
<h3 id="应用环境"><a href="#应用环境" class="headerlink" title="应用环境"></a>应用环境</h3><ul>
<li>计算过程分为一些顺序执行的步骤</li>
<li>计算中执行的某些步骤会不断产生一些后面可能需要的中间数据</li>
<li>产生的数据中有些不能立即使用，但又需要在将来使用</li>
<li>需要保存的数据项数不能事先确定</li>
</ul>
<h2 id="栈：概念和实现"><a href="#栈：概念和实现" class="headerlink" title="栈：概念和实现"></a>栈：概念和实现</h2><h3 id="栈抽象数据类型"><a href="#栈抽象数据类型" class="headerlink" title="栈抽象数据类型"></a>栈抽象数据类型</h3><h4 id="栈的线性表实现"><a href="#栈的线性表实现" class="headerlink" title="栈的线性表实现"></a>栈的线性表实现</h4><ul>
<li>对于<strong>顺序表</strong>，<strong>后端</strong>插入和删除都是 O(1) 操作，应该用这一端作为栈项（采用顺序表实现）</li>
<li>对于<strong>连接表</strong>，<strong>前端</strong>插入和删除都是 O(1) 操作，应该用这端作为栈项</li>
</ul>
<h3 id="栈的顺序表实现"><a href="#栈的顺序表实现" class="headerlink" title="栈的顺序表实现"></a>栈的顺序表实现</h3><p>采用 Python 的 <code>list</code> 数据结构</p>
<ul>
<li>建立空栈：<code>lst = []</code></li>
<li>压栈：<code>lst.append()</code></li>
<li>弹栈：<code>lst.pop()</code></li>
</ul>
<h3 id="栈的连接表实现"><a href="#栈的连接表实现" class="headerlink" title="栈的连接表实现"></a>栈的连接表实现</h3><p>见前文连接表</p>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><pre><code class="python">def Conversion(n, d): # 十进制数 n 转化为 d 进制数
    st = []
    while n &gt; 0:
        st.append(n % d)
        n //= d
    while not st == []:
        print(st.pop(), end = &quot;&quot;)
    print(&#39;&#39;)

# 试着运行一下
Conversion(8,2)</code></pre>
<h3 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h3><h4 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h4><ul>
<li>顺序扫描被检查正文（一个字符串）中的每一个字符</li>
<li>检查中跳过无关字符（非括号字符）</li>
<li>遇到开括号”(“时将其压入栈</li>
<li>遇到闭括号时弹出当前的栈顶元素与之匹配</li>
<li>如果匹配成功则继续，发现不匹配时检查以失败结束</li>
</ul>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><pre><code class="python">def check_parens(text):
    &quot;&quot;&quot;括号匹配检查函数，text 是被检查的正文串&quot;&quot;&quot;
    parens = &quot;()[]&#123;&#125;&quot; # 所有括号字符
    open_parens = &quot;([&#123;&quot; # 开括号字符
    opposite = &#123;&quot;)&quot;:&quot;(&quot;, &quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;&#125; # 表示匹配关系的字典

    def parentheses(text):
        &quot;&quot;&quot;括号生成器，每次调用返回 text 里下一个括号及其位置&quot;&quot;&quot;
        i, text_len = 0, len(text)
        while True:
            while i &lt; text_len and text[i] not in parens:
                i += 1
            if i &gt;= text_len:
                return 
            yield text[i], i
            i += 1

    st = [] # 保存括号的栈
    for pr, i in parentheses(text): # 对 text 里各括号和位置迭代
        if pr in open_parens: # 开括号，压栈并继续
            st.append(pr)
        elif st == []: # 无法再弹栈
            return False
        elif st.pop() != opposite[pr]: # 不匹配就是失败，退出
            return False
        # else: 这是依次成功匹配，什么也不做，继续，因为上一步已经弹栈了
    if st == []:
        return True
    else:
        return False

# 应用一下试试看
re = check_parens(&quot;&#123;(]&quot;)
if re:
    print(&quot;All parentheses are correctly matched.&quot;)
else:
    print(&quot;Parentheses mismatched.&quot;)</code></pre>
<h3 id="表达式的表示，计算和变换"><a href="#表达式的表示，计算和变换" class="headerlink" title="表达式的表示，计算和变换"></a>表达式的表示，计算和变换</h3><h4 id="表达式和计算的描述"><a href="#表达式和计算的描述" class="headerlink" title="表达式和计算的描述"></a>表达式和计算的描述</h4><ul>
<li><p>中缀形式：<code>(3 - 5) * (6 + 17 * 4) / 3</code></p>
<blockquote>
<p>中缀表达式表达能力最弱，只有在添加括号后才可达到相同的表达能力</p>
</blockquote>
</li>
<li><p>前缀形式：<code>/ * - 3 5 + 6 * 17 4 3</code></p>
</li>
<li><p>后缀形式：<code>3 5 - 6 17 4 * + * 3 /</code></p>
</li>
</ul>
<h4 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h4><h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><ul>
<li>遇到运算对象是，应该记录它以便后续使用</li>
<li>遇到运算符时，应该根据其元数（假定都是二元运算符），取得前面最近遇到的几个运算对象或已完成运算的结果，应用这个运算符计算，并保存其结果</li>
</ul>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>需要记录的是已经掌握的数据</li>
<li>每次处理运算符，应使用的是此前最后记录的几个结果</li>
</ul>
<pre><code class="python"># 实现的伪代码如下：
# 假定 st 是一个栈，算法的核心是下面的循环
while 还有输入:
    x = nextItem() # 获取下一个输入
    if is_opend(x): # 如果是运算对象s
        st.append(float(x))
    else: # 如果是运算符
        b = st.pop() # 第二个运算对象 ################################## 特别注意，先弹出来的是第二个运算数
        a = st.pop() # 第一个运算对象 ################################## 特别注意，后弹出来的是第一个运算数
        根据运算符对 a, b 进行运算
        st.append(c) #计算结果压入栈</code></pre>
<pre><code class="python">def calculate(formula):
    formula = formula.split()
    st = [] # 栈
    for i in formula:
        if(i.isdigit()): # 若为数字
            st.append(int(i)) # 只支持整形运算
        else:
            b = st.pop() # 第二个运算数 ################################## 特别注意，先弹出来的是第二个运算数
            a = st.pop() # 第一个运算数 ################################## 特别注意，后弹出来的是第一个运算数
            if(i == &#39;+&#39;):
                c = a + b
            elif(i == &#39;-&#39;):
                c = a - b
            elif(i == &#39;*&#39;):
                c = a * b
            elif(i == &#39;/&#39;):
                c = a / b
            else:
                print(&quot;Illegal operator&quot;)
                return
            st.append(c)
    return st.pop()

# 试着运算看看
print(calculate(&quot;3 5 - 6 17 4 * + * 3 /&quot;))</code></pre>
<h4 id="中缀表达式到后缀表达式的转换"><a href="#中缀表达式到后缀表达式的转换" class="headerlink" title="中缀表达式到后缀表达式的转换"></a>中缀表达式到后缀表达式的转换</h4><ul>
<li>扫描中遇到一个运算符不能将其输出，只要看到下一个运算符的优先级<strong>不高于</strong>本运算符的时候，才能够取做本运算符要求的计算</li>
<li>应该用一个栈保存尚未处理的运算符</li>
<li>需要处理括号问题</li>
<li>在扫描完成后，栈里可能剩下一些运算符，应将其一一弹出并送到后缀表达式。</li>
</ul>
<h4 id="中缀表达式的求值"><a href="#中缀表达式的求值" class="headerlink" title="中缀表达式的求值"></a>中缀表达式的求值</h4><h3 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h3><h4 id="阶乘函数的递归计算"><a href="#阶乘函数的递归计算" class="headerlink" title="阶乘函数的递归计算"></a>阶乘函数的递归计算</h4><h4 id="栈与递归-函数调用"><a href="#栈与递归-函数调用" class="headerlink" title="栈与递归 / 函数调用"></a>栈与递归 / 函数调用</h4><p>为了支持递归定义函数的实现，需要一个栈（运行栈）保存递归函数执行时每层调用的局部信息</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h3><p><strong>先进先出</strong>（First In First Out, FIFO）结构</p>
<ul>
<li>入队（enqueue）</li>
<li>出队（dequeue）</li>
</ul>
<h3 id="队列的链接表实现"><a href="#队列的链接表实现" class="headerlink" title="队列的链接表实现"></a>队列的链接表实现</h3><p>需要使用<strong>尾端指针</strong></p>
<h3 id="队列的顺序表实现"><a href="#队列的顺序表实现" class="headerlink" title="队列的顺序表实现"></a>队列的顺序表实现</h3><ul>
<li>初始化 <code>front = rear = 0</code></li>
<li>入队：将新元素插入 <code>rear</code> 所指向的位置，然后 <code>rear</code> 加一</li>
<li>出队：删去 <code>front</code> 所指的元素，然后加 1 并返回被删元素</li>
<li>队列为空：<code>front = rear</code></li>
<li>队满：<code>rear = MAX_QUEUE_SIZE - 1 或 front = rear</code></li>
</ul>
<h4 id="基于顺序表实现队列的困难"><a href="#基于顺序表实现队列的困难" class="headerlink" title="基于顺序表实现队列的困难"></a>基于顺序表实现队列的困难</h4><p>假溢出</p>
<blockquote>
<p>在入队和出队操作中，头、尾指针只增加不减小，致使被删除元素的空间永远无法重新利用。因此，尽管队列中实际元素个数可能远远小于数组大小，但可能由于尾指针巳超出向量空间的上界而不能做入队操作。</p>
</blockquote>
<h4 id="循环顺序表（循环队列）"><a href="#循环顺序表（循环队列）" class="headerlink" title="循环顺序表（循环队列）"></a>循环顺序表（循环队列）</h4><blockquote>
<p>为循环队列所分配的空间可以被充分利用，除非向量空间真的被队列元素全部占用，否则不会上溢。</p>
</blockquote>
<ul>
<li><code>q.elems</code> —— 始终指向表元素区开始</li>
<li><code>q.head</code> —— 对头变量，记录当前队列里第一个元素的位置</li>
<li><code>q.rear</code> —— 队尾变量，记录当前队列里最后元素之后的第一个空位</li>
</ul>
<p><img src="/2021/01/17/Data%20Structure/image/circ_queue_0.png" alt="image-20210103210448289"></p>
<p><img src="/2021/01/17/Data%20Structure/image/circ_queue_1.png" alt="image-20210103210459953"></p>
<p>入队和出队分别需要更新变量 <code>q.head</code> 和 <code>q.rear</code></p>
<ul>
<li><code>q.head = (q.head + 1) % q.len</code></li>
<li><code>q.rear = (q.rear + 1) % q.len</code></li>
</ul>
<h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><p>BFS</p>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h2 id="字符集、字符串和字符串操作"><a href="#字符集、字符串和字符串操作" class="headerlink" title="字符集、字符串和字符串操作"></a>字符集、字符串和字符串操作</h2><h3 id="字符串的相关概念"><a href="#字符串的相关概念" class="headerlink" title="字符串的相关概念"></a>字符串的相关概念</h3><ul>
<li><p>字符串<strong>长度</strong></p>
</li>
<li><p>字符在字符串中的位置</p>
</li>
<li><p>字符串<strong>相等</strong></p>
</li>
<li><p><strong>字典序</strong></p>
</li>
<li><p>字符串<strong>拼接</strong></p>
</li>
<li><p><strong>子串</strong>关系</p>
<p>任何字符串也是该串自身的子串</p>
</li>
<li><p><strong>前缀</strong>，<strong>后缀</strong></p>
</li>
</ul>
<h3 id="字符串抽象数据类型"><a href="#字符串抽象数据类型" class="headerlink" title="字符串抽象数据类型"></a>字符串抽象数据类型</h3><h2 id="字符串的实现"><a href="#字符串的实现" class="headerlink" title="字符串的实现"></a>字符串的实现</h2><h3 id="基本实现问题和技术"><a href="#基本实现问题和技术" class="headerlink" title="基本实现问题和技术"></a>基本实现问题和技术</h3><h3 id="实际语言里的字符串"><a href="#实际语言里的字符串" class="headerlink" title="实际语言里的字符串"></a>实际语言里的字符串</h3><h3 id="Python-里的字符串"><a href="#Python-里的字符串" class="headerlink" title="Python 里的字符串"></a>Python 里的字符串</h3><h4 id="str-的操作"><a href="#str-的操作" class="headerlink" title="str 的操作"></a><code>str</code> 的操作</h4><ul>
<li><p>切分操作 <code>split</code></p>
<p><code>string.split(&#39;x&#39;)</code></p>
<ul>
<li>默认在<strong>空格处</strong>切分</li>
<li>返回切分后的 <code>list</code>，其中每个元素<strong>不包含</strong> ‘x’</li>
<li><strong>不改变</strong>原有字符串</li>
</ul>
</li>
<li><p>替换操作 <code>replace</code></p>
<p><code>string.replace(&#39;a&#39;, &#39;b&#39;)</code></p>
<ul>
<li>一次替换掉<strong>全部</strong>满足要求的元素</li>
<li>返回替换后的结果</li>
<li><strong>不改变</strong>原有字符串</li>
</ul>
</li>
<li><p>检查子串出现的次数 <code>count</code></p>
<p><code>TimesOccured = string.count(&#39;x&#39;, start(, end))</code></p>
</li>
<li><p>检查后缀 <code>endswith</code></p>
<p><code>string.endswith(&#39;Ending&#39;)</code></p>
<ul>
<li>返回 <code>Ture</code> 或 <code>False</code></li>
</ul>
</li>
<li><p>找子串的位置 <code>find/index</code></p>
<p><code>string.find(&quot;substring&quot;, start(, end))</code></p>
<p><code>string.index(&quot;substring&quot;, start(, end))</code></p>
<ul>
<li><code>index() </code>方法检测字符串中是否包含子字符串 <code>str</code> ，该方法与 python <code>find()</code>方法一样，只不过如果 <code>str</code> 不在 <code>string</code> 中<strong>会报一个异常</strong>。</li>
</ul>
</li>
</ul>
<h2 id="字符串匹配（子串查找）string-matching"><a href="#字符串匹配（子串查找）string-matching" class="headerlink" title="字符串匹配（子串查找）string matching"></a>字符串匹配（子串查找）string matching</h2><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p>假设有两个串（其中 $t_i, p_i$ 是字符）</p>
<p>$t = t_0t_1t_2…t_{n-1}$</p>
<p>$p = p_0p_1p_2…p_{m-1}$</p>
<p>在 $t$ 中查找与 $p$ 相同的子串</p>
<ul>
<li><strong>目标串</strong>：$t$</li>
<li><strong>模式串</strong>：$p$</li>
</ul>
<blockquote>
<p>通常有 m &lt;&lt; n, 即模式串长度远小于目标串长度</p>
</blockquote>
<h4 id="实际的串匹配问题"><a href="#实际的串匹配问题" class="headerlink" title="实际的串匹配问题"></a>实际的串匹配问题</h4><h3 id="串匹配和朴素匹配算法"><a href="#串匹配和朴素匹配算法" class="headerlink" title="串匹配和朴素匹配算法"></a>串匹配和朴素匹配算法</h3><h4 id="串匹配算法"><a href="#串匹配算法" class="headerlink" title="串匹配算法"></a>串匹配算法</h4><h4 id="朴素的串匹配算法-Brute-Force"><a href="#朴素的串匹配算法-Brute-Force" class="headerlink" title="朴素的串匹配算法 Brute Force"></a>朴素的串匹配算法 Brute Force</h4><pre><code>acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
 dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
  dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
   dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
    dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
     dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
      dsh</code></pre>
<h3 id="无回溯串匹配算法（KMP-算法）"><a href="#无回溯串匹配算法（KMP-算法）" class="headerlink" title="无回溯串匹配算法（KMP 算法）"></a>无回溯串匹配算法（KMP 算法）</h3><p><img src="/2021/01/17/Data%20Structure/image/KMP.png" alt="image-20210103215911275"></p>
<h4 id="基本考虑"><a href="#基本考虑" class="headerlink" title="基本考虑"></a>基本考虑</h4><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>当 $p_i$ 匹配失败时，所有的 $p_k(0\le k &lt; i)$ 都已经匹配成功 。因此，只需要根据模式串 $p$ 本身即可决定匹配失败时如何前移。</p>
<p>对 $p$ 中的每个 $i$，都有与之对应的下标 $k_i$，与之匹配的目标串无关。（$k_i$ 课通过对于模式串 $p$ 的预分析得到）假设模式串 $p$ 的长度为 $m$，则需要对每个 $i(0\le i&lt;m)$ 计算出对应的 $k_i$ 并将其保存起来，以便在匹配中使用。为此可以考虑一个长为 $m$ 的表 <code>pnext</code>，用表元素 <code>pnext[i]</code> 记录与 $i$ 对应的 $k_i$ 值。</p>
<h4 id="KMP-算法-O-n"><a href="#KMP-算法-O-n" class="headerlink" title="KMP 算法 O(n)"></a>KMP 算法 O(n)</h4><pre><code class="python">def matching_KMP(t, p, pnext):
    &quot;&quot;&quot;KMP 串匹配，主函数&quot;&quot;&quot;
    j, i = 0, 0
    n, m = len(t), len(p)
    while j &lt; n and i &lt; m: # i == m 说明找到了匹配
        if i == -1 or t[j] == p[i]: # 考虑 p 中下一个字符
            j, i = j + 1, i + 1
        else: # 失败！考虑 pnext 决定的下一字符
            i = pnext[i]
    if i == m: # 找到匹配，返回其下标
        return j-1
    return -1 # 无匹配，返回特殊值</code></pre>
<h4 id="构造-pnext-表：分析"><a href="#构造-pnext-表：分析" class="headerlink" title="构造 pnext 表：分析"></a>构造 <code>pnext</code> 表：分析</h4><ul>
<li>模式串移动之后，作为下一个用于匹配的字符的新位置，其前缀子串应该与匹配失败的字符串之前同样长度的子串相同。</li>
<li>如果匹配在模式串的位置 i 失败时，二位置 i 的前缀子串中满足上述条件的位置不止一处，那么只可能做最短的移动，将模式串移到最近的那个满足上述条件的位置，以保证不遗漏可能的匹配。</li>
<li>如果 $p_0…p_{i-1}$ 的最长相等前后缀的长度为 $k(0\le k&lt;i-1)$，在 $p_i\not=t_j$ 时，模式串就应该右移 $i-k$ 位，即应把 <code>pnext[i]</code> 设置为 $k$</li>
</ul>
<h4 id="递推计算最长相等前后缀的长度"><a href="#递推计算最长相等前后缀的长度" class="headerlink" title="递推计算最长相等前后缀的长度"></a>递推计算最长相等前后缀的长度</h4><p><img src="/2021/01/17/Data%20Structure/image/pnext.png" alt="image-20210104143909921"></p>
<p>已知 <code>pnext[0] = -1</code> 和直至 <code>pnext[i-1]</code> 的已有值求 <code>pnext[i]</code> 的算法：</p>
<ol>
<li>假设 <code>pnext[i-1] = k-1</code>。如果 $p_i = p_k$，那么 $p_0…p_i$ 的<strong>最长相等前后缀</strong>的长度就是 $k$，将其计入 <code>pnext[i]</code>，将 $i$ 的值加一后继续递推（循环）</li>
<li>如果 $p_i\not=p_k$，就将 $k$ 设置为 <code>pnext[k]</code> 的值</li>
<li>如果 $k$ 的值等于 -1（这个值一定是第 2 步而来自 <code>pnext</code>），那么 $p_0…p_i$ 的最长相同前后缀的长度就是 0，设置 <code>pnext[i] = 0</code>，将 $i$ 的值加 1 后继续递推。</li>
</ol>
<h4 id="pnext-生成算法的改进"><a href="#pnext-生成算法的改进" class="headerlink" title="pnext 生成算法的改进"></a><code>pnext</code> 生成算法的改进</h4><pre><code class="python">def gen_pnext(p):
    &quot;&quot;&quot;生成针对 p 中各位置 i 的下一个检查位置表，用于 KMP 算法，有稍许修改的优化版本&quot;&quot;&quot;
    i, k, m = 0, -1, len(p)
    pnext = [-1] * m
    while i &lt; m-1: # 生成下一个 pnext 元素
        if k == -1 or p[i] == p[k]:
            i, k = i + 1, k + 1
            if p[i] == p[k]:
                pnext[i] = pnext[k]
            else:
                pnext[i] = k
        else:
            k = pnext[k]
    return pnext</code></pre>
<h4 id="KMP-算法的时间复杂性及其它"><a href="#KMP-算法的时间复杂性及其它" class="headerlink" title="KMP 算法的时间复杂性及其它"></a>KMP 算法的时间复杂性及其它</h4><ul>
<li>构造 <code>pnext</code> O(m)</li>
<li>实际匹配 O(n)</li>
<li>综上： O(m+n)</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><h4 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h4><h4 id="数组的抽象数据类型定义"><a href="#数组的抽象数据类型定义" class="headerlink" title="数组的抽象数据类型定义"></a>数组的抽象数据类型定义</h4><h4 id="数组的顺序表示和实现"><a href="#数组的顺序表示和实现" class="headerlink" title="数组的顺序表示和实现"></a>数组的顺序表示和实现</h4><p>一般采用<strong>顺序存储</strong>的方法来表示数组</p>
<h5 id="行优先顺序（Row-Major-Order）"><a href="#行优先顺序（Row-Major-Order）" class="headerlink" title="行优先顺序（Row Major Order）"></a>行优先顺序（Row Major Order）</h5><p>$a_{11}\ a_{12}\ …\ a_{1n}\ a_{21}\ a_{22}\ …\ a_{2n}\ …\ a_{m1}\ a_{m2}\ …\ a_{mn}$</p>
<h5 id="列优先顺序（Column-Major-Order）"><a href="#列优先顺序（Column-Major-Order）" class="headerlink" title="列优先顺序（Column Major Order）"></a>列优先顺序（Column Major Order）</h5><p>$a_{11}\ a_{21}\ …\ a_{m1}\ a_{12}\ a_{22}\ …\ a_{m2}\ …\ a_{1n}\ a_{2n}\ …\ a_{mn}$</p>
<h5 id="不同存储方式的地址计算"><a href="#不同存储方式的地址计算" class="headerlink" title="不同存储方式的地址计算"></a>不同存储方式的地址计算</h5><h3 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h3><p>对于高阶矩阵，若其中非零元素呈某种规律分布或者矩阵中有大量的零元素，则考虑压缩存储</p>
<ul>
<li>多个相同的非零元素只分配一个存储空间</li>
<li>零元素不分配空间</li>
</ul>
<h4 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h4><p>是指非零元素或零元素的分布有一定规律的矩阵。</p>
<h5 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h5><blockquote>
<p>对称矩阵中的元素关于主对角线对称，因此，让每一对对称元素$a_{ij}$和$a_{ji}, (i\not=j)$分配一个存储空间，则$n^2$个元素压缩存储到$n(n+1)\over2$个存储空间，能节约近一半的存储空间。</p>
</blockquote>
<h5 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h5><blockquote>
<p>三角矩阵中的重复元素c可共享一个存储空间，其余的元素正好有$n(n+1)\over2$个，因此，三角矩阵可压缩存储到向量sa[$0…{n(n+1)\over2}$]中，其中c存放在向量的第1个分量中。</p>
</blockquote>
<h5 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h5><blockquote>
<p>矩阵中，除了主对角线和主对角线上或下方若干条对角线上的元素之外，其余元素皆为零。</p>
<p>对角矩阵可按行优先顺序或对角线顺序，将其压缩存储到一个向量中，并且也能找到每个非零元素和向量下标的对应关系。</p>
</blockquote>
<h4 id="稀疏矩阵-Sparse-Matrix"><a href="#稀疏矩阵-Sparse-Matrix" class="headerlink" title="稀疏矩阵 Sparse Matrix"></a>稀疏矩阵 Sparse Matrix</h4><h5 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h5><p>对于稀疏矩阵，采用压缩存储方法时，只存储非0元素。必须存储非0元素的行下标值、列下标值、元素值。因此，一个三元组$(i,\ j,\ a_{ij})$唯一确定稀疏矩阵的一个非零元素。</p>
<h5 id="三元组顺序表"><a href="#三元组顺序表" class="headerlink" title="三元组顺序表"></a>三元组顺序表</h5><blockquote>
<p>若以行序为主序，稀疏矩阵中所有非0元素的三元组，就可以得构成该稀疏矩阵的一个三元组顺序表。</p>
</blockquote>
<h5 id="求转置矩阵"><a href="#求转置矩阵" class="headerlink" title="求转置矩阵"></a>求转置矩阵</h5><ol>
<li>将矩阵的行、列下标值交换。即将三元组表中的行、列位置值i 、j相互交换；</li>
<li>重排三元组表中元素的顺序。即交换后仍然是<strong>按行优先顺序</strong>排序的。</li>
</ol>
<ul>
<li><p>方法一：</p>
<ul>
<li><p>算法思想：</p>
<p>按稀疏矩阵A的三元组表<code>a.data</code>中的列次序依次找到相应的三元组存入<code>b.data</code>中。</p>
</li>
<li><p>算法分析：</p>
<p>时间复杂度为$O(c_n\times t_n)$，即矩阵的列数和非0元素的个数的乘积成正比。</p>
</li>
</ul>
</li>
<li><p>方法二：（快速转置）</p>
<ul>
<li><p>算法思想：</p>
<p>直接按照稀疏矩阵A的三元组表<code>a.data</code>的次序依次顺序转换，并将转换后的三元组放置于三元组表<code>b.data</code>的恰当位置。    </p>
</li>
<li><p>前提：</p>
<p>若能预先确定原矩阵A中每一列的(即B中每一行)第一个非0元素在<code>b.data</code>中应有的位置，则在作转置时就可直接放在<code>b.data</code>中恰当的位置。因此，应先求得A中每一列的非0元素个数。</p>
</li>
<li><p>附设两个辅助向量<code>num[ ]</code>和<code>cpot[ ]</code> 。</p>
<ul>
<li><code>num[col]</code>：统计A中第<code>col</code>列中非0元素的个数；</li>
<li><code>cpot[col] </code>：指示A中第一个非0元素在<code>b.data</code>中的恰当位置。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="稀疏矩阵的乘法"><a href="#稀疏矩阵的乘法" class="headerlink" title="稀疏矩阵的乘法"></a>稀疏矩阵的乘法</h5><ul>
<li><p>算法思想：</p>
<p>对于A中的每个元素<code>a.data[p](p=1, 2, … , a.tn)</code>，找到B中所有满足条件：<code>a.data[p].col=b.data[q].row</code> 的元素<code>b.data[q]</code>，求得<code>a.data[p].value * b.data[q].value</code>，该乘积是$c_{ij}$中的一部分。求得所有这样的乘积并累加求和就能得到$c_{ij}$。</p>
</li>
</ul>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>矩阵非零元素结点所含有的域有：行、列、值、行指针（指向同一行的下一个非零元）、列指针（指向同一列的下一个非零元）</p>
<p><img src="/2021/01/17/Data%20Structure/image/cross_0.png" alt="image-20210104151844343"></p>
<p>由定义知，稀疏矩阵中同一行的非0元素的由<code>right</code>指针域链接成一个行链表， 由<code>down</code>指针域链接成一个列链表。则每个非0元素既是某个行链表中的一个结点，同时又是某个列链表中的一个结点，所有的非0元素构成一个十字交叉的链表。称为<strong>十字链表</strong>。</p>
<p>其次，十字交叉链表还有一个<strong>头结点</strong>，结点的结构如图所示。</p>
<p><img src="/2021/01/17/Data%20Structure/image/cross_1.png" alt="image-20210104152456025"></p>
<p><img src="/2021/01/17/Data%20Structure/image/cross_2.png" alt="image-20210104154357153"></p>
<h3 id="广义表-List"><a href="#广义表-List" class="headerlink" title="广义表 List"></a>广义表 List</h3><p>广义表是线性表的推广和扩充</p>
<h4 id="广义表的概念"><a href="#广义表的概念" class="headerlink" title="广义表的概念"></a>广义表的概念</h4><p><strong>广义表</strong>是由 $n(n\ge 0)$ 个元素组成的有穷序列：$Lst = (a_1, a_2, … a_n)$</p>
<p>其中 $a_i$ 或者是原子项（不可再分），或者是一个广义表</p>
<ul>
<li><p>表头</p>
</li>
<li><p>表尾</p>
</li>
<li><p>表深</p>
<blockquote>
<p>括号的最大层数</p>
</blockquote>
</li>
</ul>
<h4 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h4><p>由于广义表中的数据元素具有不同的结构，通常用<strong>链式</strong>存储结构表示，每个数据元素用一个结点表示。因此，广义表中就有两类结点：</p>
<ul>
<li><p>表结点：</p>
<p>用来表示广义表项，由标志域，表头指针域，表尾指针域组成</p>
</li>
<li><p>原子结点：</p>
<p>用来表示原子项，由标志域，原子的值域组成</p>
</li>
</ul>
<p><img src="/2021/01/17/Data%20Structure/image/gen_table.png" alt="image-20210104161411826"></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><strong>树形结构</strong>是由结点（结构中的逻辑单元，可用于保存数据）和结点之间的连接关系（一种后继关系）构成，其结构域线性结构（表）不同，主要特征有：</p>
<ul>
<li>一个结构如果不空，其中就存在着<strong>唯一</strong>的起始点，称为<strong>树根</strong>(root)</li>
<li>一个结点<strong>有且只有一个</strong>前驱，可以有 <strong>0 个或者多个后继</strong></li>
<li>结构里的所有结点都在树根结点通过后继关系可达的结点集合里</li>
<li>结点之间的联系<strong>不会</strong>构成循环关系</li>
<li>从任意俩能够不同的结点出发，通过后继关系可达的两个结点的集合，或者互不相交，或者一个为另一个的子集。</li>
</ul>
<h2 id="二叉树：概念和性质"><a href="#二叉树：概念和性质" class="headerlink" title="二叉树：概念和性质"></a>二叉树：概念和性质</h2><h3 id="概念和性质"><a href="#概念和性质" class="headerlink" title="概念和性质"></a>概念和性质</h3><h4 id="定义和图示"><a href="#定义和图示" class="headerlink" title="定义和图示"></a>定义和图示</h4><ul>
<li>二叉树</li>
<li>左子树</li>
<li>右子树</li>
<li>空树</li>
<li>单点树</li>
<li>子节点</li>
<li>父节点</li>
<li>树叶</li>
<li>度数——一个结点的子节点个数</li>
</ul>
<h4 id="路径、结点的层和树的高度"><a href="#路径、结点的层和树的高度" class="headerlink" title="路径、结点的层和树的高度"></a>路径、结点的层和树的高度</h4><h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><h4 id="满二叉树、扩充二叉树"><a href="#满二叉树、扩充二叉树" class="headerlink" title="满二叉树、扩充二叉树"></a>满二叉树、扩充二叉树</h4><ul>
<li><strong>满二叉树</strong>：二叉树中所有分支结点的度数都是 2</li>
<li><strong>扩充二叉树</strong>：将二叉树扩充为满二叉树，新增加的结点称为<strong>外部结点</strong>，原有结点称为<strong>内部结点</strong>。</li>
</ul>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>对于一棵高为 $h$ 的二叉树，如果其第 $0$ 层到第 $h-1$ 层的结点都满，最下一层的结点不满，且所有结点在最左边联系排列，空位都在右边。</p>
<p><img src="/2021/01/17/Data%20Structure/image/tree.png" alt="image-20210104163949799"></p>
<h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p><img src="/2021/01/17/Data%20Structure/image/BiTree.png" alt="image-20210104165302639"></p>
<p><code>A B C D E F G None H None I J K</code></p>
<h4 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历 (DFS)"></a>深度优先遍历 (DFS)</h4><ul>
<li><p><strong>先根序</strong>遍历（DLR）$\rightarrow$ 先根序列</p>
<blockquote>
<p>A B D H E I C F J K G</p>
</blockquote>
</li>
<li><p><strong>中根序</strong>遍历（LDR），也称对称序 $\rightarrow$ 中根序列</p>
<blockquote>
<p>D H B E I A J F K C G</p>
</blockquote>
</li>
<li><p><strong>后根序</strong>遍历（LRD）$\rightarrow$  后根序列</p>
<blockquote>
<p>H D I E B J K F G C A</p>
</blockquote>
</li>
</ul>
<h4 id="宽度优先遍历-BFS"><a href="#宽度优先遍历-BFS" class="headerlink" title="宽度优先遍历 (BFS)"></a>宽度优先遍历 (BFS)</h4><p><strong>按层次</strong>顺序遍历</p>
<blockquote>
<p>A B C D E F G H I J K</p>
</blockquote>
<h4 id="遍历与搜索"><a href="#遍历与搜索" class="headerlink" title="遍历与搜索"></a>遍历与搜索</h4><h2 id="二叉树的-list-实现"><a href="#二叉树的-list-实现" class="headerlink" title="二叉树的 list 实现"></a>二叉树的 <code>list</code> 实现</h2><h3 id="设计和实现"><a href="#设计和实现" class="headerlink" title="设计和实现"></a>设计和实现</h3><ul>
<li><p>空树用 <code>None</code> 表示</p>
</li>
<li><p>非空二叉树用包含桑元素的表<code>[d, l, r]</code> 表示，其中：</p>
<ul>
<li><code>d</code> 表示存在根节点的元素</li>
<li><code>l</code> 和 <code>r</code> 是两棵子树</li>
</ul>
</li>
<li><p>表示样例：</p>
<pre><code class="python">[&#39;A&#39;, [&#39;B&#39;, None, None],
      [&#39;C&#39;, [&#39;D&#39;, [&#39;F&#39;, None, None],
                  [&#39;G&#39;, None, None],
             &#39;E&#39;, [&#39;H&#39;, None, None],
                  [&#39;I&#39;, None, None]]]]</code></pre>
</li>
</ul>
<h2 id="二叉树的-class-实现与遍历"><a href="#二叉树的-class-实现与遍历" class="headerlink" title="二叉树的 class 实现与遍历"></a>二叉树的 <code>class</code> 实现与遍历</h2><h3 id="树类型定义"><a href="#树类型定义" class="headerlink" title="树类型定义"></a>树类型定义</h3><pre><code class="python">class TreeNode(object):
    def __init__(self, value, left, right):
        self.value = None
        self.left = None
        self.right = None</code></pre>
<h3 id="根据层序输入生成树"><a href="#根据层序输入生成树" class="headerlink" title="根据层序输入生成树"></a>根据层序输入生成树</h3><pre><code class="python">def CreateTree(root, tree):
    &quot;&quot;&quot;根据层序输入生成树&quot;&quot;&quot;
    queue = []
    queue.append(root)
    global i
    while(i &lt; len(tree)):
        t = queue[0]
        t.value = tree[i]
        queue.pop(0)
        t.left = TreeNode(None, None, None)
        t.right = TreeNode(None, None, None)
        queue.append(t.left)
        queue.append(t.right)
        i += 1</code></pre>
<h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><h4 id="递归前序遍历"><a href="#递归前序遍历" class="headerlink" title="递归前序遍历"></a>递归前序遍历</h4><pre><code class="python">def presearch(root):
    &quot;&quot;&quot;递归——前序遍历&quot;&quot;&quot;
    if not root:
        return None
    else:
        if not(root.value == &quot;None&quot; or root.value == None):
            print(root.value, end = &quot; &quot;)
        presearch(root.left)
        presearch(root.right)</code></pre>
<h4 id="递归中序遍历"><a href="#递归中序遍历" class="headerlink" title="递归中序遍历"></a>递归中序遍历</h4><pre><code class="python">def midsearch(root):
    &quot;&quot;&quot;递归——中序遍历&quot;&quot;&quot;
    if not root:
        return None
    else:        
        midsearch(root.left)
        if not(root.value == &quot;None&quot; or root.value == None):
            print(root.value, end = &quot; &quot;)
        midsearch(root.right)</code></pre>
<h4 id="递归后序遍历"><a href="#递归后序遍历" class="headerlink" title="递归后序遍历"></a>递归后序遍历</h4><pre><code class="python">def postsearch(root):
    &quot;&quot;&quot;递归——后序遍历&quot;&quot;&quot;
    if not root:
        return None
    else:        
        postsearch(root.left)        
        postsearch(root.right)
        if not(root.value == &quot;None&quot; or root.value == None):
            print(root.value, end = &quot; &quot;)</code></pre>
<h3 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><h4 id="非递归前序遍历"><a href="#非递归前序遍历" class="headerlink" title="非递归前序遍历"></a>非递归前序遍历</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="python">def nonrec_presearch(root):
    &quot;&quot;&quot;非递归——前序遍历&quot;&quot;&quot;
    dlr = []
    stk = [] # 栈空间
    now = root
    while not(now == None or now.value == None or now.value == &quot;None&quot;) and (len(stk) == 0)):
        elif now == None or now.value == None or now.value == &quot;None&quot;:
            now = stk.pop()
        else:
            dlr.append(now.value)
            stk.append(now.right)
            now = now.left  
    # 打印出遍历结果
    print(dlr)</code></pre>
<h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><pre><code class="python">while 当前结点不为空 or 栈空间不为空时:
    if 当前结点为空:
        当前结点 = stack.pop()
    else:
        1. 先访问当前结点（根节点）
        2. 右子节点进栈
        3. 当前结点设置为左子节点</code></pre>
<h4 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h4><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code class="python">def nonrec_midsearch(root):
    &quot;&quot;&quot;非递归——中序遍历&quot;&quot;&quot;
    ldr = []
    stk = [] # 栈空间
    now = root
    while not ((now.value == None or now.value == &quot;None&quot;) and (len(stk) == 0)):
        if now.value == None or now.value == &quot;None&quot;:
            now = stk.pop()
            ldr.append(now.value)
            now = now.right
        else:
            stk.append(now)
            now = now.left
    # 打印出遍历结果
    print(ldr)</code></pre>
<h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><pre><code class="python">while 当前结点不为空 or 栈空间不为空时:
    if 当前结点为空:
        当前结点 = stack.pop()
        访问当前节点
        当前结点设置为右子节点
    else:
        stack.push(当前节点)
        当前结点设置为左子节点</code></pre>
<h4 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h4><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><pre><code class="python">def nonrec_postsearch(root):
    &quot;&quot;&quot;非递归——后序遍历&quot;&quot;&quot;
    lrd = []
    stk = [] # 栈空间
    now = [root, 0]
    while not ((now[0].value == None or now[0].value == &quot;None&quot; or now[0] == None) and (len(stk) == 0)):
        if now[0].value == None or now[0].value == &quot;None&quot; or now[0] == None:
            now = stk.pop()
            now[1] += 1
        elif now[1] == 0:
            stk.append(now)
            now = [now[0].left,0]
        elif now[1] == 1:
            stk.append(now)
            now = [now[0].right,0]
        elif len(stk) == 0:
            lrd.append(now[0].value)
            break
        else:
            lrd.append(now[0].value)
            now = stk.pop()
            now[1] += 1
    # 打印出遍历结果
    print(lrd)</code></pre>
<h5 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h5><pre><code class="python">需要引入&quot;计数&quot;，即是否可以访问根节点
计数为 0: now = now.left
   为 1: now = now.right
   为 2: 访问当前结点</code></pre>
<h2 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h2><h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><h2 id="霍夫曼树的构造"><a href="#霍夫曼树的构造" class="headerlink" title="霍夫曼树的构造"></a>霍夫曼树的构造</h2><blockquote>
<p>设有实数集 $W = {w_0, w_1, …, w_{m-1}},\ T$ 是一棵扩充二叉树，其 m 个外部节点分别以 $w_i(i = 1,2,…,n-1)$ 为权，且 T 的带权外部路径长度 WPL 在所有这样的扩充二叉树中达到最小，则称 T 为 W 的最优二叉树或哈夫曼树。</p>
</blockquote>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="概念、性质与实现"><a href="#概念、性质与实现" class="headerlink" title="概念、性质与实现"></a>概念、性质与实现</h2><h3 id="定义与图示"><a href="#定义与图示" class="headerlink" title="定义与图示"></a>定义与图示</h3><ul>
<li>有向图</li>
<li>无向图</li>
</ul>
<h3 id="概念与性质"><a href="#概念与性质" class="headerlink" title="概念与性质"></a>概念与性质</h3><ul>
<li><strong>完全图</strong>：任意两个顶点之间都有边的图</li>
<li><strong>度</strong>：一个顶点的度就是与它邻接边的条数。<ul>
<li>入度</li>
<li>出度</li>
</ul>
</li>
</ul>
<h4 id="路径的相关性质"><a href="#路径的相关性质" class="headerlink" title="路径的相关性质"></a>路径的相关性质</h4><ul>
<li>路径的长度：该路径上边的条数</li>
<li><strong>回路</strong></li>
<li><strong>简单回路</strong>：一个环路，除起点和终点外其它顶点均不相同</li>
<li><strong>简单路径</strong>：内部不包含回路的路径</li>
<li><strong>有根图</strong>：在有向图里存在一个顶点 v，到其它每个顶点均有路径</li>
</ul>
<h4 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h4><ul>
<li><strong>连通</strong></li>
<li><strong>连通无向图</strong>：任意两个顶点之间都连通</li>
<li><strong><em>强</em></strong> <strong>连通有向图</strong>：任意两个顶点之间都有路径（要求两个方向的路径都存在）</li>
</ul>
<h4 id="子图、连通子图"><a href="#子图、连通子图" class="headerlink" title="子图、连通子图"></a>子图、连通子图</h4><ul>
<li><strong>极大连通子图</strong></li>
<li><strong>极大强连通子图</strong></li>
</ul>
<h4 id="带权图和网络"><a href="#带权图和网络" class="headerlink" title="带权图和网络"></a>带权图和网络</h4><ul>
<li><strong>带权图</strong></li>
<li><strong>网络</strong></li>
</ul>
<h3 id="图抽象数据类型"><a href="#图抽象数据类型" class="headerlink" title="图抽象数据类型"></a>图抽象数据类型</h3><h3 id="图的表示和实现"><a href="#图的表示和实现" class="headerlink" title="图的表示和实现"></a>图的表示和实现</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>$A_{ij} = \left{ \begin{array}{lr} 1, 如果顶点 v_i 到 v_j 有边 \ 0，如果顶点 v_i 到 v_j 无边\end{array}\right.$</p>
<h4 id="图的邻接表表示"><a href="#图的邻接表表示" class="headerlink" title="图的邻接表表示"></a>图的邻接表表示</h4><blockquote>
<p>对图的每个顶点建立一个单链表，存储该顶点所有邻接顶点及其相关信息。每一个单链表设一个表头结点。</p>
</blockquote>
<p><img src="/2021/01/17/Data%20Structure/image/graph.png" alt="image-20210105165157110"></p>
<h2 id="图的-Python-实现"><a href="#图的-Python-实现" class="headerlink" title="图的 Python 实现"></a>图的 Python 实现</h2><p>用字典实现</p>
<ul>
<li><p>字典的声明：</p>
<p><code>Graph = dict()</code></p>
</li>
<li><p>使用：</p>
<p><code>Graph[key] = value</code></p>
</li>
</ul>
<h3 id="由输入构造树"><a href="#由输入构造树" class="headerlink" title="由输入构造树"></a>由输入构造树</h3><pre><code class="python"># get input
NodeNum, PathNum, Start, End = input().split()
NodeNum = int(NodeNum)
PathNum = int(PathNum)
Start = int(Start)
End = int(End)
# Create Graph
Graph = dict()
for i in range(NodeNum):
    Graph[i+1] = dict()
for i in range(PathNum):
    temp = input().split()
    Graph[int(temp[0])][int(temp[1])] = int(temp[2])</code></pre>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><h4 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h4><h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><blockquote>
<p>条件：<strong>连通无向图</strong> 或 <strong>强连通有向图</strong></p>
</blockquote>
<blockquote>
<p>如果图 G 有 n 个顶点，必然可以找到 G 中的一个包含 n-1 条边的集合，这个集合里包含了从 $v_0$ 到其它所有点的路径。</p>
</blockquote>
<h4 id="遍历和生成树"><a href="#遍历和生成树" class="headerlink" title="遍历和生成树"></a>遍历和生成树</h4><h5 id="构造-DFS-生成树"><a href="#构造-DFS-生成树" class="headerlink" title="构造 DFS 生成树"></a>构造 DFS 生成树</h5><h5 id="构造-BFS-生成树"><a href="#构造-BFS-生成树" class="headerlink" title="构造 BFS 生成树"></a>构造 BFS 生成树</h5><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h3><p>最小生成树 —— 带权树中权值最小的生成树</p>
<h3 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h3><h5 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h5><pre><code class="python">将图看作离散的点和一堆边
dot = []
while num(边) &lt; n - 1:
    从未选择的边中找到满足：&lt;m ,n&gt;
    1. 权重最小
    2. 两个端点不同时出现在已连接的点中
    dot.append(m)
    dot.append(n)
    将边从未选择中删除
    num(边) ++</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/3755117-2656ffcd5cdb097d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3755117-8392698e3388fece.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h3><p><img src="https://upload-images.jianshu.io/upload_images/3755117-4491cf0d977af08c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3755117-ac654c5400c4a97e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><h3 id="求单原点最短路径的-Dijikstra-算法"><a href="#求单原点最短路径的-Dijikstra-算法" class="headerlink" title="求单原点最短路径的 Dijikstra 算法"></a>求单原点最短路径的 Dijikstra 算法</h3><p><img src="https://wiki.mbalib.com/w/images/6/65/Dijkstra%E7%AE%97%E6%B3%95%E5%9B%BE.jpg" alt="See the source image"></p>
<p><img src="/2021/01/17/Data%20Structure/image/Dijikstra.png"></p>
<pre><code class="python"># FindPath
Path[Start] = (Start,0)
for i in Graph[Start]:
    CanReach.append((Graph[Start][i],i,Start))
while(len(Arrive) &lt; NodeNum):
    CanReach = sorted(CanReach)
    i = 0
    while(CanReach[i][1] in Arrive):
        i += 1
    at = CanReach[i][1]
    length = CanReach[i][0]
    Arrive.append(at)
    Path[at] = ((CanReach[i][2], CanReach[i][0]))
    for j in Graph[at]:
        if(j not in Arrive):
            CanReach.append((length + Graph[at][j],j,at))</code></pre>
<h3 id="求任意顶点间的最短路径的-Floyd-算法"><a href="#求任意顶点间的最短路径的-Floyd-算法" class="headerlink" title="求任意顶点间的最短路径的 Floyd 算法"></a>求任意顶点间的最短路径的 Floyd 算法</h3><p>基于图的邻接矩阵表示</p>
<ol>
<li>若不允许经过任何中间点，则最短路径就是邻接矩阵</li>
<li>允许经过第一个顶点，与邻接矩阵比较，算出最小值</li>
<li>允许经过第一个和第二个顶点，…</li>
<li>…</li>
</ol>
<pre><code class="python">def Floyd(graph):
    N = len(graph)
    for i in range(N): # pass point i
        for m in range(N):
            for n in range(N): #&lt;m, n&gt;
                old = graph[m][n]
                new = graph[m][i] + graph[i][n]
                if(new &lt; old):
                    graph[m][n] = new
    return graph

inf = 1000
Graph = [[0,2,6,4],
         [inf,0,3,inf],
         [7,inf,0,1],
         [5,inf,12,0]]
print(Floyd(Graph))</code></pre>
<h2 id="AOV-AOE-网及其算法"><a href="#AOV-AOE-网及其算法" class="headerlink" title="AOV / AOE 网及其算法"></a>AOV / AOE 网及其算法</h2><blockquote>
<p><strong>AOV 网</strong>，又称顶点活动网(activity on vertex network)，表示各项活动之间的先后顺序关系</p>
</blockquote>
<h3 id="AOV-网、拓扑排序和拓扑序列"><a href="#AOV-网、拓扑排序和拓扑序列" class="headerlink" title="AOV 网、拓扑排序和拓扑序列"></a>AOV 网、拓扑排序和拓扑序列</h3><h4 id="拓扑排序和拓扑序列"><a href="#拓扑排序和拓扑序列" class="headerlink" title="拓扑排序和拓扑序列"></a>拓扑排序和拓扑序列</h4><blockquote>
<p><strong>拓扑排序</strong> $S$：如果 $N$ 中存在顶点 $v_i$ 到 $v_j$ 的路径，那么 $S$ 里 $v_i$ 就排在 $v_j$ 之前</p>
</blockquote>
<p>拓扑序列<strong>不唯一</strong></p>
<p>拓扑序列<strong>不包含</strong>回路</p>
<h3 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h3><h4 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h4><ol>
<li>从 $N$ 中选出一个入度为 0 的顶点作为序列的下一顶点</li>
<li>从 $N$ 网中删除所选顶点及其所有的出边</li>
<li>反复执行上述步骤，直至已经选出了所有图中的顶点</li>
</ol>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre><code class="python"># get input
temp = input().split()
NodeNum = int(temp[0])
PathNum = int(temp[1])
Start = int(temp[2])
End = int(temp[3])
# Create Graph
Graph = dict()
ReGraph = dict()
From = dict()
EE = dict()
LE = dict()
Topology = [Start]
for i in range(NodeNum):
    Graph[i+1] = dict()
    From[i+1] = []
    ReGraph[i+1] = dict()
# Find Topology Order
now = Start
while not(now == End):
    for i in From:
        if now in From[i]:
            From[i].remove(now)
        if ((len(From[i]) == 0) and not (i in Topology)):
            Next = i
    Topology.append(Next)
    now = Next</code></pre>
<h3 id="AOE-网和关键路径"><a href="#AOE-网和关键路径" class="headerlink" title="AOE 网和关键路径"></a>AOE 网和关键路径</h3><blockquote>
<p><strong>AOE 网</strong> (Activity On Edge Network) 是另一类带权有向图</p>
<p>抽象来看，AOE 网是一种无环带权有向图，其中：</p>
<ul>
<li>顶点表示<strong>事件</strong>，有向边表示<strong>活动</strong>，边上的权值表示活动的<strong>持续时间</strong></li>
<li>图中一个顶点表示的事件，也就是它的入边所表示的活动<strong>都已完成</strong>，它的出边活动<strong>可以开始</strong>的那个状态。</li>
<li>AOE 网中描述的活动可以<strong>并行</strong>地执行。</li>
</ul>
<p><strong>关键路径</strong>：完成整个工程所需的最短时间，就是从开始顶点到完成顶点的最长路径的长度。</p>
</blockquote>
<h3 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h3><h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><ul>
<li>事件 $v_j$ 最早可能发生时间 $ee[j]$<ul>
<li><code>ee[0] = 0</code>（初始时间总是在 0 时刻发生）</li>
<li><code>ee[j] = max&#123;ee[i] + w[i, j]&#125;</code></li>
</ul>
</li>
<li>事件 $v_j$ 最迟允许发生时间 $le[j]$<ul>
<li>根据已知 <code>ee[j]</code> 反向推算</li>
<li><code>le[n - 1] = ee[n - 1]</code> （最后一个事件绝不能再延迟）</li>
<li><code>le[i] = min&#123;le[j] + w[i, j]&#125;</code></li>
</ul>
</li>
</ul>
<h4 id="定义概念"><a href="#定义概念" class="headerlink" title="定义概念"></a>定义概念</h4><ul>
<li>关键活动<ul>
<li><code>ee[j] == le[j]</code></li>
</ul>
</li>
<li>时间余量<ul>
<li><code>t[j] = le[j] - ee[j]</code></li>
</ul>
</li>
</ul>
<h4 id="关键路径：算法"><a href="#关键路径：算法" class="headerlink" title="关键路径：算法"></a>关键路径：算法</h4><ol>
<li>生成 AOE 网的一个拓扑序列</li>
<li>按照拓扑正序，生成 <code>ee</code> 表的值</li>
<li>按照拓扑逆序，生成 <code>le</code> 表的值</li>
<li>将 <code>e</code> 与 <code>l</code> 一起计算，得到关键路径</li>
</ol>
<pre><code class="python">import copy
def DFS(now, path):
    global Result, Critical, Graph, End
    if(now == End):
        Result.append(copy.copy(path))
        return
    for i in Graph[now]:
        if((i in Critical) and (Graph[path[-1]][i] == EE[i] - EE[path[-1]])):
            path.append(i)
            DFS(i, path)
            path.remove(i)
    return
# get input
temp = input().split()
NodeNum = int(temp[0])
PathNum = int(temp[1])
Start = int(temp[2])
End = int(temp[3])
# Create Graph
Graph = dict()
ReGraph = dict()
From = dict()
EE = dict()
LE = dict()
Topology = [Start]
for i in range(NodeNum):
    Graph[i+1] = dict()
    From[i+1] = []
    ReGraph[i+1] = dict()
for i in range(PathNum):
    temp = input().split()
    Graph[int(temp[0])][int(temp[1])] = int(temp[2])
    From[int(temp[1])].append(int(temp[0]))
    ReGraph[int(temp[1])][int(temp[0])] = int(temp[2])
print(Graph)
print(From)
# Find Topology Order
now = Start
while not(now == End):
    for i in From:
        if now in From[i]:
            From[i].remove(now)
        if ((len(From[i]) == 0) and not (i in Topology)):
            Next = i
    Topology.append(Next)
    now = Next
print(Topology)
# Find Critical Path
for i in Topology:
    if(i == Start):
        EE[Start] = 0
    else:
        can = []
        for j in ReGraph[i]:
            can.append(EE[j] + ReGraph[i][j])
        EE[i] = max(can)
print(EE)
Topology.reverse()
for i in Topology:
    if(i == End):
        LE[End] = EE[End]
    else:
        can = []
        for j in Graph[i]:
            can.append(LE[j] - Graph[i][j])
        LE[i] = min(can)
print(LE)
# Critical Path
Critical = []
for i in Graph:
    if(EE[i] == LE[i]):
        Critical.append(i)
Result = []
p = [Start]
DFS(Start, p)
Result = sorted(Result)
print(Result)</code></pre>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><blockquote>
<p>从表的一端开始逐个将记录的关键字和给定K值进行比较，若某个记录的关键字和给定K值相等，查找成功；否则，若扫描完整个表，仍然没有找到相应的记录，则查找失败。</p>
</blockquote>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><blockquote>
<p>折半查找又称为二分查找，是一种效率较高的查找方法。<br>前提条件：查找表中的所有记录是按关键字有序(升序或降序) 。<br>查找过程中，先确定待查找记录在表中的范围，然后逐步缩小范围(每次将待查记录所在区间缩小一半)，直到找到或找不到记录为止。</p>
</blockquote>
<h2 id="索引查找"><a href="#索引查找" class="headerlink" title="索引查找"></a>索引查找</h2><blockquote>
<p>分块查找(Blocking Search)又称索引顺序查找，是前面两种查找方法的综合。</p>
</blockquote>
<h3 id="索引树"><a href="#索引树" class="headerlink" title="索引树"></a>索引树</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B_树"></a>B_树</h3><blockquote>
<p>一棵 m 阶 B 树或者为空，或者具有下面特征：</p>
<ul>
<li>树中分支结点至多有 m-1 个排序存放的关键码。根结点至少有一个关键码，其他结点至少有 $\lfloor (m-1)/2\rfloor$ 个关键码</li>
<li>如果一个分支节点有 j 个关键码，它就有 j + 1 棵子树，这一结点中保存的是一个序列 $&lt;p_0, k_0, p_1, k_1, …, p_{j-1}, k_{j-1}, p_j&gt;$, 其中 $k_j$ 为关键码，$p_j$ 为子结点引用，而且 $k_i$ 大于 $p_i$ 所引子树里所有的关键码，小于 $p_{i+1}$ 所引子树里所有的关键码</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36118365/article/details/103648782">B_ 树图文详解</a></p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26222859/article/details/80631121">B+ 树图文详解</a></p>
<h2 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 AVL"></a>平衡二叉树 AVL</h2><h3 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h3><blockquote>
<p><strong>平衡二叉排序树</strong>是一类特殊的二叉排序树，它或为孔数，或者其左右子树都是平衡二叉排序树，而且其左右子树的<strong>高度之差的绝对值不超过 1</strong>。</p>
</blockquote>
<p><strong>平衡因子 BF</strong>（Balance Factor）：该结点的左子树高度减去右子树高度之差，可能的取指只有 1, -1, 0</p>
<h3 id="AVL-树类"><a href="#AVL-树类" class="headerlink" title="AVL 树类"></a>AVL 树类</h3><blockquote>
<p>如果能维持平衡二叉树的结构，检索操作就能在 $O(\log{n})$ 时间内完成</p>
</blockquote>
<h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>为了实现 AVL 树，每个结点里需要增加一个平衡因子记录</p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><h4 id="插入后的失衡与调整"><a href="#插入后的失衡与调整" class="headerlink" title="插入后的失衡与调整"></a>插入后的失衡与调整</h4><ul>
<li>不失衡的情况<ul>
<li>若在检索树的过程中，所有途径的结点 BF 均为 0，那么实际上插入结点也不会导致失衡</li>
</ul>
</li>
<li>失衡的情况<ul>
<li>若失衡，则一定存在一棵包含实际插入点的<strong>最小非平衡子树</strong>，即包含新结点插入位置的、其根节点的 BF 非零的最小子树。如果插入新结点后这颗子树仍保持平衡，而且其高度不变，那么整棵二叉排序树也将保持平衡（由于该子树的高度不变，在它外面的树的结点的 BF 值都不变）。进一步说，如果插入新结点后的结构调整和 BF 值修改都能在子树内部的一条路径上完成，插入的复杂度将不超过 $O(\log{n})$</li>
<li>类型<ul>
<li>$LL$ 型调整【a 的左子树较高，新结点插入在 a 的左子树的左子树】</li>
<li>$LR$ 型调整【a 的左子树较高，新结点插入在 a 的左子树的右子树】</li>
<li>$RR$ 型调整【a 的右子树较高，新结点插入在 a 的左子树的右子树】</li>
<li>$RL$ 型调整【a 的右子树较高，新结点插入在 a 的左子树的左子树】</li>
</ul>
</li>
<li>在插入新结点并完成调整之后，这棵子树与插入之前这个位置上的子<strong>树高度相同</strong>，其结构变化对子树之外的部分<strong>无影响</strong>。</li>
</ul>
</li>
</ul>
<h4 id="LL-RR-失衡与调整"><a href="#LL-RR-失衡与调整" class="headerlink" title="LL(RR) 失衡与调整"></a>LL(RR) 失衡与调整</h4><ul>
<li><p>LL</p>
<p><img src="/2021/01/17/Data%20Structure/image/LL.png" alt="image-20210109104205737"></p>
<p><img src="https://img-blog.csdnimg.cn/20191109203211331.gif" alt="在这里插入图片描述"></p>
</li>
<li><p>RR</p>
<p><img src="/2021/01/17/Data%20Structure/image/RR.png" alt="image-20210109104640685"></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2019110920332691.gif" alt="在这里插入图片描述"></p>
<h4 id="LR-RL-失衡和调整"><a href="#LR-RL-失衡和调整" class="headerlink" title="LR(RL) 失衡和调整"></a>LR(RL) 失衡和调整</h4><ul>
<li><p>LR</p>
<p><img src="/2021/01/17/Data%20Structure/image/LR.png" alt="image-20210109111448478"></p>
</li>
<li><p>RL</p>
<img src="/2021/01/17/Data%20Structure/image/RL.png" alt="image-20210111155857041">

</li>
</ul>
<h4 id="插入操作的实现"><a href="#插入操作的实现" class="headerlink" title="插入操作的实现"></a>插入操作的实现</h4><ol>
<li>查找新结点的插入位置，并在查找过程中记录遇到的最小不平衡子树的根<ul>
<li>用一个变量 a 记录距插入位置最近的平衡因子非零的结点，由于可能需要修改这棵子树，在此过程中用另一变量 pa 记录 a 的父结点</li>
<li>如果不存在这种结点，需要考虑的 a 就是树根</li>
<li>如果在新结点插入后出现失衡，a 就是平衡位置</li>
<li>实际插入新结点</li>
</ul>
</li>
<li>修改从 a 的子结点到新结点的路径上各结点的平衡因子<ul>
<li>由于 a 的定义，这段结点原来都有 BF = 0</li>
<li>插入后用一个扫描变量 p 从 a 的子结点开始遍历，如果新结点插入在 p 的左子树，就把 p 的平衡因子改为 1，否则改为 -1</li>
</ul>
</li>
<li>检查以 a 为根的子树是否失衡，失衡时做出调整<ul>
<li>如果 a.bf == 0，插入后不会失衡，简单修改平衡因子并结束</li>
<li>如果 a.bf == 1，而且新结点插入其左子树，就出现了失衡<ul>
<li>新结点在 a 的左子节点的左子树时做 LL 调整</li>
<li>新结点在 a 的右子节点的左子树时做 LR 调整</li>
</ul>
</li>
<li>如果 a.bf == -1，而且新结点插入其右子树，就出现了失衡<ul>
<li>新结点在 a 的左子节点的左子树时做 RL 调整</li>
<li>新结点在 a 的右子节点的左子树时做 RR 调整</li>
</ul>
</li>
</ul>
</li>
<li>连接好调整后的子树，它可能作为整棵树的根，或作为 a 原来的父节点的相应方向的子结点（左子结点或右子结点）</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="python">class AVLNode(object):
    def __init__(self, value, left, right, bf):
        self.value = value
        self.left = left
        self.right = right
        self.bf = bf

def LL(a, b): # LL 型调整
    a.left = b.right
    b.right = a
    a.bf = b.bf = 0
    return b

def RR(a, b): # RR 型调整
    a.right = b.left
    b.left = a
    a.bf = b.bf = 0
    return b

def LR(a, b): # LR 型调整
    c = b.right
    a.left, b.right = c.right, c.left
    c.left, c.right = b, a
    if c.bf == 0: # c 本身就是插入结点
        a.bf= b.bf= 0
    elif c.bf == 1: # 新结点在 c 的左子树
        a.bf = -1
        b.bf = 0
    else: # 新结点在 c 的右子树
        a.bf = 0
        b.bf = 1
    c.bf = 0
    return c

def RL(a, b): # RL 型调整
    c = b.left
    a.right, b.left = c.left, c.right
    c.left, c.right = a, b
    if c.bf == 0: # c 本身就是新结点
        a.bf = 0
        b.bf = 0
    elif c.bf == 1: # 新结点在 c 的左子树
        a.bf = 0
        b.bf = -1
    else: # 新结点在 c 的右子树
        a.bf = 1
        b.bf = 0
    c.bf = 0
    return c

def insert(root, value):
    a = p = root
    if a is None: # 若是一棵空树
        root = AVLNode(value, None, None, 0)
        return
    pa = q = None # 维持 pa, q 为 a, p 的父节点
    while p is not None:
        if p.bf != 0:
            pa, a = q, p # 已知最小非平衡子树
        q = p
        if value &lt; p.value:
            p = p.left
        else:
            p = p.right
    # q 是插入点的父节点, pa, a记录最小非平衡子树
    node = AVLNode(value, None, None, 0)
    if value &lt; q.value:
        q.left = node # 作为左子结点
    else:
        q.right = node # 作为右子结点
    # 新结点已插入，a 是最小不平衡子树
    if value &lt; a.value: # 新结点在 a 的左子树
        p = b = a.left
        d = 1
    else:
        p = b = a.right
        d = -1
    # 修改 b 到新结点路径上各结点的 bf 值, b 为 a 的子结点
    while p != node: # node 一定存在，不用判断 b 空
        if value &lt; p.value: # p 的左子树增高
            p.bf =  1
            p = p.left
        else:
            p.bf = -1
            p = p.right
    if a.bf == 0: # a 的原 bf 为 0，不会失衡
        a.bf = d
        return
    if a.bf == -d: # 新结点在较低子树里
        a.bf = 0
        return
    # 新结点在较高子树，失衡，必须调整
    if d == 1: # 新结点在 a 的左子树
        if b.bf == 1:
            b = LL(a, b) # LL
        else:
            b = LR(a, b) # RL
    else: # 新结点在 a 的右子树
        if b.bf == -1:
            b = RR(a, b) # RR 调整
        else:
            b = RL(a, b) # RL 调整
    if pa is None: # 原 a 为树根，修改 root
        root = b
    else:
        if pa.left == a:
            pa.left = b
        else:
            pa.right = b</code></pre>
<pre><code class="python"># 以下为加入一些遍历与输入操作后的代码
# -*- coding: utf-8 -*-
&quot;&quot;&quot;
Created on Sat Jan  9 19:45:52 2021

@author: Ericaaaaaaaa
&quot;&quot;&quot;

class AVLNode(object):
    def __init__(self, value, left, right, bf):
        self.value = value
        self.left = left
        self.right = right
        self.bf = bf
    def __str__(self):
        return &quot;[AVLNode value: &#123;0&#125; bf: &#123;1&#125;]&quot;.format(self.value, self.bf)

def insert(root, value):
    a = p = root
    if a is None:
        root = AVLNode(value, None, None, 0)
        return
    pa = q = None # 维持 pa, q 为 a, p 的父节点
    while p is not None:
        if p.bf != 0:
            pa, a = q, p # 已知最小非平衡子树
        q = p
        if value &lt; p.value:
            p = p.left
        else:
            p = p.right
    # q 是插入点的父节点, pa, a记录最小非平衡子树
    node = AVLNode(value, None, None, 0)
    if value &lt; q.value:
        q.left = node # 作为左子结点
    else:
        q.right = node # 作为右子结点
    # 新结点已插入，a 是最小不平衡子树
    if value &lt; a.value: # 新结点在 a 的左子树
        p = b = a.left
        d = 1
    else:
        p = b = a.right
        d = -1
    # 修改 b 到新结点路径上各结点的 bf 值, b 为 a 的子结点
    while p != node: # node 一定存在，不用判断 b 空
        if value &lt; p.value: # p 的左子树增高
            p.bf =  1
            p = p.left
        else:
            p.bf = -1
            p = p.right
    if a.bf == 0: # a 的原 bf 为 0，不会失衡
        a.bf = d
        return
    if a.bf == -d: # 新结点在较低子树里
        a.bf = 0
        return
    # 新结点在较高子树，失衡，必须调整
    if d == 1: # 新结点在 a 的左子树
        if b.bf == 1:
            b = LL(a, b) # LL
        else:
            b = LR(a, b) # RL
    else: # 新结点在 a 的右子树
        if b.bf == -1:
            b = RR(a, b) # RR 调整
        else:
            b = RL(a, b) # RL 调整
    if pa is None: # 原 a 为树根，修改 root
        root = b
    else:
        if pa.left == a:
            pa.left = b
        else:
            pa.right = b

def LL(a, b):
    a.left = b.right
    b.right = a
    a.bf = b.bf = 0
    return b

def RR(a, b):
    a.right = b.left
    b.left = a
    a.bf = b.bf = 0
    return b

def LR(a, b):
    c = b.right
    a.left, b.right = c.right, c.left
    c.left, c.right = b, a
    if c.bf == 0: # c 本身就是插入结点
        a.bf= b.bf= 0
    elif c.bf == 1: # 新结点在 c 的左子树
        a.bf = -1
        b.bf = 0
    else: # 新结点在 c 的右子树
        a.bf = 0
        b.bf = 1
    c.bf = 0
    return c

def RL(a, b):
    c = b.left
    a.right, b.left = c.left, c.right
    c.left, c.right = a, b
    if c.bf == 0: # c 本身就是新结点
        a.bf = 0
        b.bf = 0
    elif c.bf == 1: # 新结点在 c 的左子树
        a.bf = 0
        b.bf = -1
    else: # 新结点在 c 的右子树
        a.bf = 1
        b.bf = 0
    c.bf = 0
    return c

def print_tree(root):
    queue = []
    now = root
    while not((len(queue) == 0) and (now == None or now.value == None or now.value == &quot;None&quot;)):
        print(now)
        left = now.left
        right = now.right
        if not(left == None or left.value == None or left.value == &quot;None&quot;):
            queue.append(left)
        if not(right == None or right.value == None or right.value == &quot;None&quot;):
            queue.append(right)
        if(len(queue) == 0):
            now = None
        else:
            now = queue.pop(0)

initial = int(input())
root = AVLNode(initial, None, None, 0)
while True:
    l = input()
    if l == &quot;finish&quot;:
        break
    else:
        insert(root, int(l))
        print_tree(root)</code></pre>
<h1 id="内部排序问题和性质"><a href="#内部排序问题和性质" class="headerlink" title="内部排序问题和性质"></a>内部排序问题和性质</h1><h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="基于比较的排序"><a href="#基于比较的排序" class="headerlink" title="基于比较的排序"></a>基于比较的排序</h4><h4 id="基本操作、性质和评价"><a href="#基本操作、性质和评价" class="headerlink" title="基本操作、性质和评价"></a>基本操作、性质和评价</h4><p>在讨论各个算法时，总是以被排序序列的长度（即序列中元素的个数）作为问题的规模参数 n</p>
<ul>
<li>任何算法的<strong>时间复杂度</strong>都不可能优于 $O(n\log{n})$</li>
<li>算法的性质<ul>
<li><strong>稳定性</strong>：<ul>
<li>对于待排序序列里的任一对排序码相同的记录 $R_i$ 和 $R_j$，在排序后的序列里 $R_i$ 和 $R_j$ 的前后顺序不变</li>
<li>稳定性是一个具体算法的性质，而不是排序方法的性质</li>
</ul>
</li>
<li><strong>适应性</strong>：<ul>
<li>如果一个排序算法对接近有序的序列工作的更快，就称这种算法具有适应性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="简单排序算法"><a href="#简单排序算法" class="headerlink" title="简单排序算法"></a>简单排序算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法的思路"><a href="#算法的思路" class="headerlink" title="算法的思路"></a>算法的思路</h4><ol>
<li>从一个没有元素的列表开始</li>
<li>选择一个未排序的元素</li>
<li>将所选元素与列表中的元素一一比较，并插入到正确的位置</li>
<li>重复 2、3 直至所有元素都被插入到列表中为止。</li>
</ol>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><pre><code class="python">def insert_sort(lst):
    for i in range(1, len(lst)): # 开始时片段 [lst[0]] 已排序
        x = lst[i] # 选择元素
        j = i
        while j &gt; 0 and lst[j-1] &gt; x: # 逐一向前比较
            lst[j] = lst[j-1] # 反序逐个后移元素，决定插入位置
            j -= 1
        lst[j] = x
    return lst # 有没有都行，因为 python 其实已经改变了原有的 lst 了</code></pre>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><strong>平均时间复杂度</strong>： $O(n^2)$</li>
<li><strong>最坏时间复杂度</strong>：$O(n^2)$</li>
<li><strong>空间复杂度</strong>：$O(1)$</li>
</ul>
<h4 id="算法特性分析"><a href="#算法特性分析" class="headerlink" title="算法特性分析"></a>算法特性分析</h4><ul>
<li><p>有稳定性</p>
<blockquote>
<p><code>lst[j-1] &gt; x</code></p>
</blockquote>
</li>
<li><p>有适应性</p>
</li>
</ul>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>采用<strong>二分法</strong>检索插入位置</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h4><ol>
<li>顺序扫描未排序序列中的元素，记住遇到的最小的元素</li>
<li>将最小元素于未排序的第一位交换</li>
<li>重复 1、2，直至序列排序完毕</li>
</ol>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><pre><code class="python">def select_sort(lst):
    &quot;&quot;&quot;选择排序&quot;&quot;&quot;
    for i in range(len(lst) - 1): # 只需循环 len(lst) - 1 次
        k = i
        for j in range(i, len(lst)): # k 是已知最小元素的位置
            if lst[j] &lt; lst[k]:
                k = j
        if i != k: # lst[k] 是已知确定最小的元素，检查是否需要交换
            lst[i], lst[k] = lst[k], lst[i] # 交换
    return lst # 有没有都行，因为 python 其实已经改变了原有的 lst 了</code></pre>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><strong>平均时间复杂度</strong>： $O(n^2)$</li>
<li><strong>最坏时间复杂度</strong>：$O(n^2)$</li>
<li><strong>空间复杂度</strong>：$O(1)$</li>
</ul>
<h4 id="算法特性分析-1"><a href="#算法特性分析-1" class="headerlink" title="算法特性分析"></a>算法特性分析</h4><ul>
<li><p>没有适应性</p>
<blockquote>
<p>任何情况下的时间复杂度都是 $O(n^2)$</p>
</blockquote>
</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><p>优先队列是一种<strong>缓存结构</strong>，保证在任何时候访问或弹出的，总是当时这个结构里保存的所有元素里<strong>优先级最高的</strong>（在存数数据时会同时存入优先级）</p>
<h5 id="树形结构和堆"><a href="#树形结构和堆" class="headerlink" title="树形结构和堆"></a>树形结构和堆</h5><h6 id="堆及其性质"><a href="#堆及其性质" class="headerlink" title="堆及其性质"></a>堆及其性质</h6><ul>
<li>采用<strong>树形结构</strong>实现<strong>优先队列</strong>的一种有效技术称为堆。</li>
<li>从结构上看，堆就是结点里存储数据的<strong>完全二叉树</strong></li>
<li><strong>堆序</strong>：任意一个结点里存储的数据的优先级<strong>先于（或等于）</strong>其子节点里的数据<ul>
<li>堆中优先级最高的元素必在<strong>堆顶</strong></li>
<li>大顶堆 &amp; 小顶堆</li>
</ul>
</li>
</ul>
<h5 id="优先队列的堆实现"><a href="#优先队列的堆实现" class="headerlink" title="优先队列的堆实现"></a>优先队列的堆实现</h5><h6 id="插入元素和向上筛选"><a href="#插入元素和向上筛选" class="headerlink" title="插入元素和向上筛选"></a>插入元素和向上筛选</h6><h6 id="弹出元素和向下筛选"><a href="#弹出元素和向下筛选" class="headerlink" title="弹出元素和向下筛选"></a>弹出元素和向下筛选</h6><h4 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h4><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><pre><code class="python">def heap_sort(elems): # 堆排序
    &quot;&quot;&quot;
    堆排序：
    采用小顶堆，因此输出顺序为从大到小
    若希望得到从小到大的输入，只需要将 ① 与 ② 处改为 &quot;&gt;&quot; 即可
    &quot;&quot;&quot;
    def siftdown(elems, e, begin, end): # elems 按层序方式存储的堆，e 为要插入的元素（向下筛选），begin, end 为已有堆的 begin, end 下标
        i, j = begin, begin*2+1 # j 为 i 的左子结点
        while j &lt; end: # invariant: j == 2 *i + 1
            if j+1 &lt; end and elems[j+1] &lt; elems[j]: # ① # 使得 j 为 i 子结点中最小的结点的下标
                j += 1 # elems[j] 小于等于其兄弟结点的数据
            if e &lt; elems[j]: # e 在三者中最小 ②
                break
            elems[i] = elems[j] # elems[j] 最小，上移
            i, j = j, 2*j+1 # i 下移， j 为 i 的左子结点
        elems[i] = e # 将 e 放入合适的位置（i 处的元素已经被移走）

    end = len(elems)
    # 循环建堆
    for i in range(end//2, -1, -1): # 从最下层开始，逐步向上使得序列满足小顶堆条件
        siftdown(elems, elems[i], i, end)
    # 循环逐个取出最小元素，将其积累在表的最后，放一个退一步
    for i in range((end-1), 0, -1):
        e = elems[i]
        elems[i] = elems[0]
        siftdown(elems, e, 0, i)</code></pre>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：$O(n\log{n})$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h4 id="算法特性分析-2"><a href="#算法特性分析-2" class="headerlink" title="算法特性分析"></a>算法特性分析</h4><h3 id="交换排序（冒泡排序）"><a href="#交换排序（冒泡排序）" class="headerlink" title="交换排序（冒泡排序）"></a>交换排序（冒泡排序）</h3><h4 id="算法思路-5"><a href="#算法思路-5" class="headerlink" title="算法思路"></a>算法思路</h4><p>通过交换元素<strong>消除逆序</strong></p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><pre><code class="python">def bubble_sort(lst):
    &quot;&quot;&quot;冒泡排序&quot;&quot;&quot;
    for i in range(len(lst)):
        found = False
        for j in range(1, len(lst) - i):
            if lst[j-1] &gt; lst[j]: # 找到逆序
                lst[j-1], lst[j] = lst[j], lst[j-1]
                found =True
        if not found: # 如果序列中已经没有逆序了
            break
    return lst # 有没有都行，因为 python 其实已经改变了原有的 lst 了</code></pre>
<h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><strong>平均时间复杂度</strong>： $O(n^2)$</li>
<li><strong>最坏时间复杂度</strong>：$O(n^2)$</li>
<li><strong>空间复杂度</strong>：$O(1)$</li>
</ul>
<h4 id="算法特性分析-3"><a href="#算法特性分析-3" class="headerlink" title="算法特性分析"></a>算法特性分析</h4><ul>
<li><p>有稳定性</p>
</li>
<li><p>有适应性</p>
<p><code>if not found:</code></p>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h4 id="算法思路-6"><a href="#算法思路-6" class="headerlink" title="算法思路"></a>算法思路</h4><ol>
<li>若序列长度为 0 或 1，证明已经完成排序，返回，若不然，执行 2</li>
<li>取待排序序列中的任意一个元素（通常是第一个）作为标准</li>
<li>将其他元素与之比较，并分成【比标准小】、【比标准大】两部分</li>
<li>将分好的两部分视为新的未排序序列，递归执行 2 操作</li>
</ol>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><pre><code class="python">def qsort_rec(lst, l, r):
    if l &gt;= r:
        return # 分段无记录或只有一个记录
    i, j = l, r
    pivot = lst[i] # lst[i] 是初始空位
    while i &lt; j: # 找 pivot 的最终位置
        while i &lt; j and lst[j] &gt; pivot:
            j -= 1 # 用 j 向左扫描找小于 pivot 的记录
        if i &lt; j:
            lst[i] = lst[j]
            i += 1 # 小记录移到左边
        while i &lt; j and lst[i] &lt;= pivot:
            i += 1 # 用 i 向右扫描找大于 pivot 的记录
        if i &lt; j:
            lst[j] = lst[i]
            j -= 1 # 大记录移到右边
    lst[i] = pivot # 将 pivot 存入其最终位置
    qsort_rec(lst, l, i-1) # 递归处理左半区间
    qsort_rec(lst, i+1, r) # 递归处理右半区间

lst = [1,6,4,3,2,7,8,9,5]
qsort_rec(lst, 0, len(lst) - 1)
print(lst)</code></pre>
<h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><strong>平均</strong>时间复杂度： $O(n\log{n})$</li>
<li><strong>最坏</strong>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(\log{n})$</li>
</ul>
<h4 id="算法特性分析-4"><a href="#算法特性分析-4" class="headerlink" title="算法特性分析"></a>算法特性分析</h4><ul>
<li>不稳定</li>
<li>不具有适应性</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h4 id="算法思路-7"><a href="#算法思路-7" class="headerlink" title="算法思路"></a>算法思路</h4><ol>
<li>开始时，将每个记录看成单独的有序序列，则 n 个待排序的记录就是 n 个长度为 1 的有序子序列</li>
<li>对所有有序子序列进行两两归并，得到 n/2 个长度为 2 或 1 的有序子序列——一趟归并</li>
<li>重复 2，直到得到长度为 n 的有序序列为止。</li>
</ol>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><pre><code class="python">def merge(lfrom, lto, low, mid, high):
    &quot;&quot;&quot;
    归并排序最下层函数
    实现表中相邻的一对有序序列的归并工作，将归并的结果存入另一个顺序表里的相同位置
    需要归并的两有序段分别为：lfrom[low:mid] 和 lfrom[mid:high]
    归并结果应存入 lto[low:high]
    &quot;&quot;&quot;
    i, j, k = low, mid, low # i, j 遍历两个有序子序列，k 写入结果序列
    while i &lt; mid and j &lt; high: # 反复赋值两分段首最小的
        if lfrom[i] &lt;= lfrom[j]:
            lto[k] = lfrom[i]
            i += 1
        else:
            lto[k] = lfrom[j]
            j += 1
        k += 1
    while i &lt; mid: # 复制第一段剩余记录
        lto[k] = lfrom[i]
        i += 1
        k += 1
    while j &lt; high: # 复制第二段剩余记录
        lto[k] = lfrom[j]
        j += 1
        k += 1

def merge_pass(lfrom, lto, llen, slen):
    &quot;&quot;&quot;
    归并排序中间层函数
    实现对整个表里顺序各对有序序列的归并，完成一遍归并，
    各对序列的归并结果顺序存入另一顺序表里的同位置分段
    slen: 需要归并的每小段长度
    llen: 序列总长度
    &quot;&quot;&quot;
    i = 0
    while i + 2 * slen &lt; llen: # 归并长 slen 的两段
        merge(lfrom, lto, i, i + slen, i + 2 * slen)
        i += 2 * slen
    if i + slen &lt; llen: # 剩下两端，后段长度小于 slen
        merge(lfrom, lto, i, i + slen, llen)
    else: # 只剩下一段，复制给表 lto
        for j in range(i, llen):
            lto[j] = lfrom[j]

def merge_sort(lst):
    &quot;&quot;&quot;
    归并排序主函数（最顶层函数）
    在两个顺序表中往复执行中间层操作，直至排序全部完成
    &quot;&quot;&quot;
    slen, llen = 1, len(lst)
    templst = [None] * llen
    while slen &lt; llen: # 未形成长度为总长度的顺序序列
        merge_pass(lst, templst, llen, slen)
        slen *= 2
        # 排序完成时，结果可能存放在 templst 中，无论如何，再执行一次下一步，将结果存回 lst 中
        merge_pass(templst, lst, llen, slen) # 结果存回原位
        slen *= 2</code></pre>
<h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：$O(n\log{n})$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<h4 id="算法特性分析-5"><a href="#算法特性分析-5" class="headerlink" title="算法特性分析"></a>算法特性分析</h4><ul>
<li>有稳定性</li>
<li>无适应性</li>
</ul>
<h2 id="其他排序方法"><a href="#其他排序方法" class="headerlink" title="其他排序方法"></a>其他排序方法</h2><h3 id="分配排序和基数排序"><a href="#分配排序和基数排序" class="headerlink" title="分配排序和基数排序"></a>分配排序和基数排序</h3><h4 id="算法思路-8"><a href="#算法思路-8" class="headerlink" title="算法思路"></a>算法思路</h4><p>如果关键码只有很少几个不同的值，</p>
<ol>
<li>为每个关键码设置一个桶</li>
<li>遍历序列，根据关键码把记录放在不同的桶中</li>
<li>顺序手机各个桶的记录，得到排序的序列</li>
</ol>
<h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<h3 id="多轮分配和排序"><a href="#多轮分配和排序" class="headerlink" title="多轮分配和排序"></a>多轮分配和排序</h3><h4 id="算法思路-9"><a href="#算法思路-9" class="headerlink" title="算法思路"></a>算法思路</h4><ul>
<li>高位优先（Most Significant Digit first, MSD）</li>
<li>低位优先（Least Significant Digit first, LSD）</li>
</ul>
<h3 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序 Shell Sort"></a>希尔排序 Shell Sort</h3><h4 id="算法思路-10"><a href="#算法思路-10" class="headerlink" title="算法思路"></a>算法思路</h4><ol>
<li>先取一个正整数d1(d1&lt;n)作为第一个增量，将全部n个记录分成d1组，把所有相隔d1的记录放在一组中，即对于每个k(k=1, 2,  … d1)，R[k], R[d1+k], R[2d1+k] , …分在同一组中，在各组内进行直接插入排序。这样一次分组和排序过程称为一趟希尔排序；</li>
<li>取新的增量d2&lt;d1，重复 1 的分组和排序操作；直至所取的增量di=1为止，即所有记录放进一个组中排序为止。</li>
</ol>
<p><img src="/2021/01/17/Data%20Structure/image/Shell.png" alt="image-20210106192442516"></p>
<p><img src="/2021/01/17/Data%20Structure/image/Shell_1.png" alt="image-20210106193116456"></p>
<h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件的组织方式"><a href="#文件的组织方式" class="headerlink" title="文件的组织方式"></a>文件的组织方式</h3><h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>索引结构(称为索引文件)由<strong>索引表</strong>和数据表两部分</p>
<ul>
<li>数据表：存储实际的数据记录</li>
<li>索引表：存储记录的关键字和记录(存储)地址之间的对照表，每个元素称为一个索引项</li>
</ul>
<h5 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h5><h5 id="非稠密索引"><a href="#非稠密索引" class="headerlink" title="非稠密索引"></a>非稠密索引</h5><h3 id="ISAM"><a href="#ISAM" class="headerlink" title="ISAM"></a>ISAM</h3><blockquote>
<p><strong>ISAM</strong>(Indexed Sequential Access Method，<strong>顺序索引存取方法</strong>)，是专为<strong>磁盘</strong>存取设计的一种文件组织方式，采用<strong>静态</strong>索引结构，是一种三级索引结构的顺序文件。</p>
</blockquote>
<p><img src="/2021/01/17/Data%20Structure/image/ISAM.png" alt="image-20210106203126494"></p>
<p><img src="/2021/01/17/Data%20Structure/image/ISAM_1.png" alt="image-20210106203143277"></p>
<h3 id="VSAM"><a href="#VSAM" class="headerlink" title="VSAM"></a>VSAM</h3><blockquote>
<p><strong>VSAM</strong>(Virtual Storage Access Method，<strong>虚拟存取方法</strong>)，也是一种索引顺序文件组织方式，利用OS的虚拟存储器功能，采用的是基于B+树的动态索引结构。</p>
</blockquote>
<p><img src="/2021/01/17/Data%20Structure/image/VSAM.png" alt="image-20210106203231777"><img src="/2021/01/17/Data%20Structure/image/VSAM_1.png" alt="image-20210106203249607"></p>
<h3 id="散列文件"><a href="#散列文件" class="headerlink" title="散列文件"></a>散列文件</h3><blockquote>
<p><strong>散列文件</strong>(直接存取文件) ：利用散列存储方式组织的文件。类似散列表，即根据文件中记录关键字的特点，设计一个散列函数和冲突处理方法，将记录散列到存储介质上。</p>
</blockquote>
<h3 id="多关键字文件"><a href="#多关键字文件" class="headerlink" title="多关键字文件"></a>多关键字文件</h3><h3 id="多重表文件"><a href="#多重表文件" class="headerlink" title="多重表文件"></a>多重表文件</h3><blockquote>
<p><strong>多重表文件</strong>(Multilist Files)的特点是：记录按主关键字的顺序构成一个串联文件(物理上的) ，并建立主关键字索引(称为主索引)；对每个次关键字都建立次关键字索引(称为次索引)，所有具有同一次关键字值的记录构成一个链表(逻辑上的)。</p>
</blockquote>
<h3 id="倒排文件"><a href="#倒排文件" class="headerlink" title="倒排文件"></a>倒排文件</h3><blockquote>
<p><strong>倒排文件</strong>又称逆转表文件。与多重表文件类似，可以处理多关键字查询。</p>
</blockquote>
<h2 id="外部排序-1"><a href="#外部排序-1" class="headerlink" title="外部排序"></a>外部排序</h2><blockquote>
<p>外部排序最基本的方法是归并。这种方法是由两个相对独立的阶段组成：<br>① 按内存(缓冲区)的大小，将n个记录的数据文件分成若干个长度为l的段或子文件，依次读入内存并选择有效的内部排序方法进行排序；然后将排好序的有序子文件重新写入到外存。子文件称为归并段或顺串。<br>② 采用归并的办法对归并段进行逐趟归并，使归并段的长度逐渐增大，直到最后合并成只有一个归并段的文件—排好序的文件。</p>
</blockquote>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="兄弟伙伴算法"><a href="#兄弟伙伴算法" class="headerlink" title="兄弟伙伴算法"></a>兄弟伙伴算法</h3><blockquote>
<p><strong>伙伴系统</strong>是一种<strong>非顺序</strong>内存管理方法，不是以顺序片段来分配内存，是把内存分为两个部分，只要有可能，这两部分就可以合并在一起; 且这两部分从来不是自由的，程序可以使用伙伴系统中的一部分或者两部分都不使用。与边界标识法类似，所不同是：无论占用块或空闲块，其大小均为2的k次幂。</p>
</blockquote>
<blockquote>
<p>当程序释放所占用的块时，系统将该新的空闲块插入到可利用空闲表中，需要考虑合并成大块问题。在伙伴系统中，只有“互为伙伴”的两个子块均空闲时才合并；即使有两个相邻且大小相同的空闲块，如果不是“互为伙伴” (从同一个大块中分裂出来的)也不合并。</p>
</blockquote>
<blockquote>
<p>设要回收的空闲块的首地址是p，其大小为2k的，算法思想是：<br>⑴ 判断其 “互为伙伴”的两个空闲块是否为空：<br>若不为空，仅将要回收的空闲块直接插入到相应的子表中；否则转⑵；<br>⑵  按以下步骤进行空闲块的合并：<br>◆ 在相应子表中找到其伙伴并删除之；<br>◆ 合并两个空闲块；<br>⑶ 重复⑵，直到合并后的空闲块的伙伴不是空闲块为止。6</p>
</blockquote>
</article><div id="paginator"></div></div><footer id="bottom"><span>© </span><span>ericaaaaaaaa</span><span>. Powered By </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>HEXO</span></a><span>. Theme </span><a target="_blank" rel="noopener" href="https://github.com/lixuetaoleo/hexo-theme-leo">leo</a></footer></div><script src="/js/style.js"></script><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script></body></html>