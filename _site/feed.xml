<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-03-08T17:06:07+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Erica’s Blog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>ericaaaaaaaa</name></author><entry><title type="html">现代软件工程</title><link href="http://localhost:4000/softwareengineering/2022/03/08/ModernSoftwareEngineering.html" rel="alternate" type="text/html" title="现代软件工程" /><published>2022-03-08T00:00:00+08:00</published><updated>2022-03-08T00:00:00+08:00</updated><id>http://localhost:4000/softwareengineering/2022/03/08/ModernSoftwareEngineering</id><content type="html" xml:base="http://localhost:4000/softwareengineering/2022/03/08/ModernSoftwareEngineering.html">&lt;h1 id=&quot;读书笔记构建之法现代软件工程&quot;&gt;【读书笔记】构建之法：现代软件工程&lt;/h1&gt;

&lt;h1 id=&quot;第一章-概论&quot;&gt;第一章 概论&lt;/h1&gt;

&lt;h2 id=&quot;11-软件--程序--软件工程&quot;&gt;1.1 软件 = 程序 + 软件工程&lt;/h2&gt;

&lt;p&gt;一个复杂的软件不但要有合理的软件架构 (Software Architecture)、软件设计与实现 (software Design, Implementation and Debug)，还要有各种文件和数据来描述各个程序文件之间的依赖关系、编译参数、链接参数，等等。&lt;/p&gt;

&lt;h2 id=&quot;12-软件工程是什么&quot;&gt;1.2 软件工程是什么&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;软件工程&lt;/strong&gt;是把系统的、有序的、可量化的方法应用到软件的开发、运营和维护上的过程。&lt;/p&gt;

&lt;p&gt;软件工程包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;软件需求分析&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;软件设计&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;软件构件&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;软件测试&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;软件维护&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;121-软件的特殊性&quot;&gt;1.2.1 软件的特殊性&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;复杂性 (Complexity)&lt;/li&gt;
  &lt;li&gt;不可见性 (Invisibility)&lt;/li&gt;
  &lt;li&gt;易变性 (Changeability)&lt;/li&gt;
  &lt;li&gt;服从性 (Conformity)&lt;/li&gt;
  &lt;li&gt;非连续型 (Discontinuity)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;122-软件工程与计算机科学的关系&quot;&gt;1.2.2 软件工程与计算机科学的关系&lt;/h3&gt;

&lt;p&gt;工程：创造性的运用科学原理，设计和实现建筑、及其、装置或生产过程；或者是在实践中使用一个或多个上述实体；或者是在实现这些实体的过程。&lt;/p&gt;

&lt;h3 id=&quot;123-软件工程的知识领域&quot;&gt;1.2.3 软件工程的知识领域&lt;/h3&gt;

&lt;h3 id=&quot;124-软件工程的目标构建足够好的软件&quot;&gt;1.2.4 软件工程的目标——构建“足够好”的软件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;用户满意度&lt;/li&gt;
  &lt;li&gt;可靠性&lt;/li&gt;
  &lt;li&gt;软件流程的质量&lt;/li&gt;
  &lt;li&gt;可维护性&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;研发出符合用户需求的软件说明&lt;/li&gt;
  &lt;li&gt;通过一定的软件流程，在预计时间内发布“足够好”的软件说明&lt;/li&gt;
  &lt;li&gt;通过数据和其他方式展现所开发的软件是可以维护和继续发展的说明&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;软件的种类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ShrinkWrap （在包装盒子里面的软件）&lt;/li&gt;
  &lt;li&gt;Web APP （基于网页的软件）&lt;/li&gt;
  &lt;li&gt;Internal Software （企业或学校或某组织内部的软件）&lt;/li&gt;
  &lt;li&gt;Games （游戏）&lt;/li&gt;
  &lt;li&gt;Mobile Apps （手机应用）&lt;/li&gt;
  &lt;li&gt;Operating Systems （操作系统）&lt;/li&gt;
  &lt;li&gt;Tools （工具软件）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;第二章-个人技术和流程&quot;&gt;第二章 个人技术和流程&lt;/h1&gt;

&lt;p&gt;PSP (Personal Software Process) 个人软件开发流程&lt;/p&gt;

&lt;h2 id=&quot;单元测试&quot;&gt;单元测试&lt;/h2&gt;

&lt;h3 id=&quot;211-用-vsts-写单元测试&quot;&gt;2.1.1 用 VSTS 写单元测试&lt;/h3&gt;

&lt;h3 id=&quot;212-好的单元测试的标准&quot;&gt;2.1.2 好的单元测试的标准&lt;/h3&gt;

&lt;p&gt;单元测试应该准确、快速地保证程序基本模块的正确性。&lt;/p&gt;

&lt;p&gt;单元测试需要有程序的作者编写，因为代码作者最了解代码的目的、特点和实现的局限性。&lt;/p&gt;

&lt;p&gt;单元测试应：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;速度快&lt;/li&gt;
  &lt;li&gt;认为构造数据，而非用随机数（可能导致错误不可复现）&lt;/li&gt;
  &lt;li&gt;覆盖所有代码路径，包括错误处理路径&lt;/li&gt;
  &lt;li&gt;测试公开的和私有的函数 / 方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;100% 代码覆盖率不能保证 100% 程序正确性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;未处理问题，如内存未释放&lt;/li&gt;
  &lt;li&gt;代码效能问题&lt;/li&gt;
  &lt;li&gt;多线程环境中的同步问题&lt;/li&gt;
  &lt;li&gt;其他与外部条件相关的问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单元测试的运行与维护&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;团队一般在每日构建之后运行单元测试&lt;/li&gt;
  &lt;li&gt;单元测试一般与产品代码一起保存和维护&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;213-回归测试&quot;&gt;2.1.3 回归测试&lt;/h3&gt;

&lt;p&gt;在单元测试的基础上，建立关于某一模块的回归测试 (Regression Test)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Regress: return to a worse or less developed state.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一旦有关的测试用例通过，我们就得到了此模块的功能基准线 (Baseline)，一个模块的所有单元测试就是这个模块最初的 Baseline。&lt;/p&gt;

&lt;p&gt;工程师们应该在新版本上运行所有已通过的测试用例，以验证有没有“退化”情况发生。&lt;/p&gt;

&lt;p&gt;如果倒退是由于模块功能发生了正常变化引起的，那么要修改测试用例，以便和新功能保持一致。&lt;/p&gt;

&lt;p&gt;针对一个 Bug Fix，也要做 Regression Test，目的是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;验证新代码的确改正了缺陷&lt;/li&gt;
  &lt;li&gt;同时验证新代码有没有破坏模块的现有功能，有没有 Regression&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回归测试最好自动化，因为这样就可以对每一个构建你快速运行所有的回归测试。&lt;/p&gt;

&lt;p&gt;在一个项目的最后稳定阶段，需要做全面的回归测试，确保所有已修复的 Bug 的确得到了修复，且没有复发。&lt;/p&gt;

&lt;p&gt;除回归测试外，还有功能测试——从用户的角度检查功能的完成情况。&lt;/p&gt;

&lt;h2 id=&quot;效能分析工具&quot;&gt;效能分析工具&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;抽样 (Sampling)
    &lt;ul&gt;
      &lt;li&gt;当程序运行时，每隔一段时间记录程序运行在哪个函数内，得到程序运行时间的大致印象&lt;/li&gt;
      &lt;li&gt;优点：无需改动程序，运行较快&lt;/li&gt;
      &lt;li&gt;缺点：结果不精确，不能准确表示代码中的调用关系树 (Call Tree)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;代码注入 (Instrumentation)
    &lt;ul&gt;
      &lt;li&gt;将检测的代码注入到每个函数中&lt;/li&gt;
      &lt;li&gt;优点：测量结果精确&lt;/li&gt;
      &lt;li&gt;缺点：程序运行时间长&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;效能分析名词&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;调用者 Caller&lt;/td&gt;
      &lt;td&gt;函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo()&lt;/code&gt; 调用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bar()&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo()&lt;/code&gt; 就是调用者&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;被调用函数 Callee&lt;/td&gt;
      &lt;td&gt;见上，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bar()&lt;/code&gt; 就是被调用函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;调用关系树 Call Tree&lt;/td&gt;
      &lt;td&gt;从程序的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Main()&lt;/code&gt; 函数开始，调用者和被调用函数形成树形关系——调用树&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;消失时间 Elapsed Time&lt;/td&gt;
      &lt;td&gt;从用户的角度看程序运行所花的时间。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;应用程序事件 Application Time&lt;/td&gt;
      &lt;td&gt;应用程序占用 CPU 的事件，不包括调用者使用时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;本函数时间 Exclusive Time&lt;/td&gt;
      &lt;td&gt;所有在本函数花费的时间，不包括被调用者使用的时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;所有时间 Inclusive Time&lt;/td&gt;
      &lt;td&gt;包含本函数和所有调用者使用的时间&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;个人开发流程&quot;&gt;个人开发流程&lt;/h2&gt;

&lt;h1 id=&quot;第三章-软件工程师的成长&quot;&gt;第三章 软件工程师的成长&lt;/h1&gt;

&lt;h2 id=&quot;个人能力的衡量与发展&quot;&gt;个人能力的衡量与发展&lt;/h2&gt;

&lt;p&gt;软件开发的工作量与质量衡量标准&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;项目的大小
    &lt;ul&gt;
      &lt;li&gt;一般用代码行数表示&lt;/li&gt;
      &lt;li&gt;用功能点表示&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;项目耗时&lt;/li&gt;
  &lt;li&gt;项目质量
    &lt;ul&gt;
      &lt;li&gt;代码缺陷与代码行数比&lt;/li&gt;
      &lt;li&gt;re-work 数量（不与最终质量成正比关系）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;项目是否按时交付&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;问题的层次&quot;&gt;问题的层次&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;低层次问题（变成自动操作）&lt;/li&gt;
  &lt;li&gt;中间层次问题（花脑力解决）&lt;/li&gt;
  &lt;li&gt;高层次问题（无暇顾及）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;第四章-两人合作&quot;&gt;第四章 两人合作&lt;/h1&gt;

&lt;h2 id=&quot;41-代码规范&quot;&gt;4.1 代码规范&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;代码风格规范
主要是文字上的规定&lt;/li&gt;
  &lt;li&gt;代码设计规范
牵涉到程序设计、模块之间的关系、设计模式等通用原则&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;42-代码风格规范&quot;&gt;4.2 代码风格规范&lt;/h2&gt;

&lt;p&gt;代码风格的原则是：简明，易读，无二义性。&lt;/p&gt;

&lt;h3 id=&quot;421-缩进&quot;&gt;4.2.1 缩进&lt;/h3&gt;

&lt;p&gt;用 4 个空格&lt;/p&gt;

&lt;h3 id=&quot;422-行宽&quot;&gt;4.2.2 行宽&lt;/h3&gt;

&lt;p&gt;100 字符&lt;/p&gt;

&lt;h3 id=&quot;423-括号&quot;&gt;4.2.3 括号&lt;/h3&gt;

&lt;p&gt;在复杂的条件表达式中，用括号清楚地表示逻辑优先级&lt;/p&gt;

&lt;h3 id=&quot;424-断行与空白的--行&quot;&gt;4.2.4 断行与空白的 {} 行&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DoSomethingElse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;425-分行&quot;&gt;4.2.5 分行&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;不要把多条语句放在一行上&lt;/li&gt;
  &lt;li&gt;更严格地说，不要把多个变量定义在一行上&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;426-命名&quot;&gt;4.2.6 命名&lt;/h3&gt;

&lt;h3 id=&quot;427-下划线&quot;&gt;4.2.7 下划线&lt;/h3&gt;

&lt;p&gt;下划线用来分隔变量名字中的作用域标注和变量的语义。&lt;/p&gt;

&lt;h3 id=&quot;428-大小写&quot;&gt;4.2.8 大小写&lt;/h3&gt;

&lt;p&gt;一个通用的做法是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;所有的类型 / 类 / 函数名都用 Pascal 形式&lt;/li&gt;
  &lt;li&gt;所有变量都用 Camel 形式。&lt;/li&gt;
  &lt;li&gt;类 / 类型 / 变量用名词或组合名词形式&lt;/li&gt;
  &lt;li&gt;函数用动词或动宾组合词表示&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;429-注释&quot;&gt;4.2.9 注释&lt;/h3&gt;

&lt;p&gt;注释（包括所有源代码）应该只用 ASCII 字符，不用中文或其他特殊字符。&lt;/p&gt;

&lt;h2 id=&quot;43-代码设计规范&quot;&gt;4.3 代码设计规范&lt;/h2&gt;

&lt;h3 id=&quot;431-函数&quot;&gt;4.3.1 函数&lt;/h3&gt;

&lt;h3 id=&quot;432-goto&quot;&gt;4.3.2 goto&lt;/h3&gt;

&lt;p&gt;函数最好有单一的出口，为达到此目的，可以使用 goto&lt;/p&gt;

&lt;h3 id=&quot;433-错误处理&quot;&gt;4.3.3 错误处理&lt;/h3&gt;

&lt;h3 id=&quot;434-如何处理-c-中的类&quot;&gt;4.3.4 如何处理 c++ 中的类&lt;/h3&gt;

&lt;h2 id=&quot;44-代码复审&quot;&gt;4.4 代码复审&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;自我复审&lt;/li&gt;
  &lt;li&gt;同伴复审
    &lt;ul&gt;
      &lt;li&gt;不止一人&lt;/li&gt;
      &lt;li&gt;找熟悉代码且有经验的人&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;团队复审&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;441-为什么要代码复审&quot;&gt;4.4.1 为什么要代码复审&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;发现代码问题
    &lt;ul&gt;
      &lt;li&gt;编码错误&lt;/li&gt;
      &lt;li&gt;风格问题&lt;/li&gt;
      &lt;li&gt;逻辑错误&lt;/li&gt;
      &lt;li&gt;算法错误&lt;/li&gt;
      &lt;li&gt;潜在错误与回归性错误&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;发现可能的改进之处&lt;/li&gt;
  &lt;li&gt;从代码中学习&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;442-代码复审的步骤&quot;&gt;4.4.2 代码复审的步骤&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;代码必须通过编译&lt;/li&gt;
  &lt;li&gt;代码必须通过测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;复审结果&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;打回&lt;/li&gt;
  &lt;li&gt;有条件同意&lt;/li&gt;
  &lt;li&gt;放行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;45-结对编程&quot;&gt;4.5 结对编程&lt;/h2&gt;

&lt;h3 id=&quot;结对编程的优点&quot;&gt;结对编程的优点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;提供更好的设计质量和代码质量，两人合作解决问题的能力更强&lt;/li&gt;
  &lt;li&gt;带来更多信心，高质量的产出带来满足感&lt;/li&gt;
  &lt;li&gt;更有效的交流，相互学习和传递经验，分享知识，更好的应对人员流动&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;第五章-团队和流程&quot;&gt;第五章 团队和流程&lt;/h1&gt;

&lt;h2 id=&quot;51-非团队和团队&quot;&gt;5.1 非团队和团队&lt;/h2&gt;

&lt;h2 id=&quot;52-软件团队的模式&quot;&gt;5.2 软件团队的模式&lt;/h2&gt;

&lt;h2 id=&quot;53-开发流程&quot;&gt;5.3 开发流程&lt;/h2&gt;

&lt;h3 id=&quot;531-写了再改模式-code-and-fix&quot;&gt;5.3.1 写了再改模式 (Code-and-Fix)&lt;/h3&gt;

&lt;p&gt;适用场景：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;“只用一次”的程序&lt;/li&gt;
  &lt;li&gt;“看过了就扔”的原型&lt;/li&gt;
  &lt;li&gt;一些不实用的演示程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;532-瀑布模型-waterfall-model&quot;&gt;5.3.2 瀑布模型 (Waterfall Model)&lt;/h3&gt;

&lt;p&gt;局限性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;各步骤之间相互分离&lt;/li&gt;
  &lt;li&gt;回溯修改困难，甚至不可能&lt;/li&gt;
  &lt;li&gt;最终产品知道最后才出现&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;532-瀑布模型的各种变形&quot;&gt;5.3.2 瀑布模型的各种变形&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;生鱼片模型&lt;/li&gt;
  &lt;li&gt;大瀑布带小瀑布&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;534-rational-unified-process-rup&quot;&gt;5.3.4 Rational Unified Process (RUP)&lt;/h3&gt;

&lt;p&gt;重计划，重事先设计，重文档表达。&lt;/p&gt;

&lt;p&gt;规程 (Discipline) 或工作流 (Workflow)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;业务建模
    &lt;ul&gt;
      &lt;li&gt;用精确的语言（通常是 UML）把用户的活动描述出来&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;需求
    &lt;ul&gt;
      &lt;li&gt;分析并确认软件系统提供什么样的功能满足用户需求&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分析和设计
    &lt;ul&gt;
      &lt;li&gt;将需求转化成系统设计&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实现&lt;/li&gt;
  &lt;li&gt;测试&lt;/li&gt;
  &lt;li&gt;部署
    &lt;ul&gt;
      &lt;li&gt;将最终版本分发给最终用户&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置和变更管理&lt;/li&gt;
  &lt;li&gt;项目管理
    &lt;ul&gt;
      &lt;li&gt;平衡各种可能产生冲突的目标，管理风险&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;环境
    &lt;ul&gt;
      &lt;li&gt;向软件开发组织提供软件开发环境，包括过程和工具&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;阶段&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;初始阶段
    &lt;ul&gt;
      &lt;li&gt;分析软件系统大概的构成，系统与外部的边界在哪里&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;细化阶段
    &lt;ul&gt;
      &lt;li&gt;分析问题领域，建立健全的体系结构基础，编制项目计划，按优先级处理项目中的风险。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;构造阶段（beta）
    &lt;ul&gt;
      &lt;li&gt;开发出所有的功能集，有秩序地把功能集成为经过各种测试验证过的产品&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;交付阶段
    &lt;ul&gt;
      &lt;li&gt;确保软件能满足最终用户的实际需求&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;535-老板驱动的流程-boss-driven-process&quot;&gt;5.3.5 老板驱动的流程 (Boss-Driven Process)&lt;/h3&gt;

&lt;h3 id=&quot;536-渐进交付的流程-evolutionary-delivery-mvp-和-mbp&quot;&gt;5.3.6 渐进交付的流程 (Evolutionary Delivery), MVP 和 MBP&lt;/h3&gt;

&lt;p&gt;[开发 $\rightarrow$ 发布 $\rightarrow$ 听取反馈 $\rightarrow$ 根据反馈做改进]&lt;/p&gt;

&lt;h1 id=&quot;第六章-敏捷流程&quot;&gt;第六章 敏捷流程&lt;/h1&gt;

&lt;h2 id=&quot;61-敏捷的流程&quot;&gt;6.1 敏捷的流程&lt;/h2&gt;

&lt;h3 id=&quot;611-敏捷开发原则&quot;&gt;6.1.1 敏捷开发原则&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;尽早&lt;/strong&gt;并&lt;strong&gt;持续&lt;/strong&gt;地交付有价值的软件以满足顾客需求&lt;/li&gt;
  &lt;li&gt;敏捷流程欢迎&lt;strong&gt;需求的变化&lt;/strong&gt;，并利用这种变化来提高用户的竞争优势&lt;/li&gt;
  &lt;li&gt;经常发布可用的软件，发布间隔可以从几周到几个月，&lt;strong&gt;能短则短&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;业务人员和开发人员&lt;/strong&gt;在项目开发过程中应该每天共同工作&lt;/li&gt;
  &lt;li&gt;以&lt;strong&gt;有进取心&lt;/strong&gt;的人为项目核心，充分信任他们&lt;/li&gt;
  &lt;li&gt;无论团队内外，&lt;strong&gt;面对面&lt;/strong&gt;的交流始终是最有效的沟通方式&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可用&lt;/strong&gt;的软件是衡量项目进展的主要指标&lt;/li&gt;
  &lt;li&gt;敏捷流程应能保持可持续发展。领导、团队和用户应该按照目前的步调持续合作下去&lt;/li&gt;
  &lt;li&gt;只有不断关注技术和设计，才能越来越敏捷&lt;/li&gt;
  &lt;li&gt;保持&lt;strong&gt;简明&lt;/strong&gt;——尽可能简化工作量&lt;/li&gt;
  &lt;li&gt;只有能自我管理的软对才能创造优秀的架构、需求和设计&lt;/li&gt;
  &lt;li&gt;时时总结如何提高团队效率，并付诸行动&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;612-敏捷流程概述&quot;&gt;6.1.2 敏捷流程概述&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;找出产品需要做的事情——Product Back-log&lt;/li&gt;
  &lt;li&gt;决定当前的冲刺 (Sprint) 需要解决的事情——Sprint Backlog&lt;/li&gt;
  &lt;li&gt;冲刺 (Sprint)
    &lt;ul&gt;
      &lt;li&gt;每日例会 (Scrum Meeting)&lt;/li&gt;
      &lt;li&gt;燃尽图 (Burn Down Chart)
        &lt;ul&gt;
          &lt;li&gt;实际剩余时间 (Remaining Hour)&lt;/li&gt;
          &lt;li&gt;预估剩余时间 (Projected Remaining Hour)&lt;/li&gt;
          &lt;li&gt;实际花费时间 (Completed Hour)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;看版图 (Kanban)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;得到软件的一个增量版本，发布给用户。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;62-敏捷流程的问题和解法&quot;&gt;6.2 敏捷流程的问题和解法&lt;/h2&gt;

&lt;h2 id=&quot;63-敏捷的团队&quot;&gt;6.3 敏捷的团队&lt;/h2&gt;

&lt;h2 id=&quot;64-敏捷总结&quot;&gt;6.4 敏捷总结&lt;/h2&gt;

&lt;h2 id=&quot;65-敏捷的故事&quot;&gt;6.5 敏捷的故事&lt;/h2&gt;

&lt;h1 id=&quot;第七章-msf&quot;&gt;第七章 MSF&lt;/h1&gt;

&lt;h2 id=&quot;71-msf-简史&quot;&gt;7.1 MSF 简史&lt;/h2&gt;

&lt;h2 id=&quot;72-msf-基本原则&quot;&gt;7.2 MSF 基本原则&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;推动信息共享与沟通 (Foster open communications)&lt;/li&gt;
  &lt;li&gt;为共同的远景而工作 (Work toward a shared vision)&lt;/li&gt;
  &lt;li&gt;充分授权和信任 (Empower team members)&lt;/li&gt;
  &lt;li&gt;各司其职，对项目共同负责 (Establish clear accountability and shared responsibility)&lt;/li&gt;
  &lt;li&gt;交付增量的价值 (Deliver incremental value)&lt;/li&gt;
  &lt;li&gt;保持敏捷，预期和适应变化 (Stay agile, expect and adapt change)&lt;/li&gt;
  &lt;li&gt;投资质量 (Invest in quality)&lt;/li&gt;
  &lt;li&gt;学习所有经验 (Learn from all experiences)&lt;/li&gt;
  &lt;li&gt;与顾客合作 (Partner with internal and external customers)&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;第八章-需求分析&quot;&gt;第八章 需求分析&lt;/h1&gt;

&lt;h2 id=&quot;81-软件需求&quot;&gt;8.1 软件需求&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;获取和引导需求 (Elicitation)
软件企业 = 软件 + 商业模式&lt;/li&gt;
  &lt;li&gt;分析和定义需求 (Analysis &amp;amp; Specification)&lt;/li&gt;
  &lt;li&gt;验证需求 (Validation)&lt;/li&gt;
  &lt;li&gt;在软件产品的生命周期中管理需求 (Management)
    &lt;ul&gt;
      &lt;li&gt;功能性要求&lt;/li&gt;
      &lt;li&gt;产品开发过程的需求&lt;/li&gt;
      &lt;li&gt;非功能性需求（服务质量需求）&lt;/li&gt;
      &lt;li&gt;综合需求&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;82-软件产品的利益相关者&quot;&gt;8.2 软件产品的利益相关者&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;用户（最终用户）&lt;/li&gt;
  &lt;li&gt;顾客（客户）&lt;/li&gt;
  &lt;li&gt;软件工程师&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;83-获取用户需求用户调查&quot;&gt;8.3 获取用户需求——用户调查&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;焦点小组 (Focus Group)
找到目标用户的代表，加上项目的利益相关者&lt;/li&gt;
  &lt;li&gt;深入面谈 (In-depth Interview)&lt;/li&gt;
  &lt;li&gt;卡片分类 (Card Sorting)&lt;/li&gt;
  &lt;li&gt;用户调查问卷 (User Survey)
常见错误
    &lt;ul&gt;
      &lt;li&gt;问题定义不准确&lt;/li&gt;
      &lt;li&gt;使用含糊不清的形容词&lt;/li&gt;
      &lt;li&gt;让用户花额外的努力来回答问题&lt;/li&gt;
      &lt;li&gt;问题带有有引导性的倾向&lt;/li&gt;
      &lt;li&gt;问题涉及用户隐私
问题形式&lt;/li&gt;
      &lt;li&gt;全开放式问题&lt;/li&gt;
      &lt;li&gt;二项选择题&lt;/li&gt;
      &lt;li&gt;多项选择题&lt;/li&gt;
      &lt;li&gt;顺位选择题（优先级）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用户日志研究 (User Diary Study)&lt;/li&gt;
  &lt;li&gt;人类学调查 (Ethnographic Study)&lt;/li&gt;
  &lt;li&gt;眼动跟踪研究&lt;/li&gt;
  &lt;li&gt;快速原型调研&lt;/li&gt;
  &lt;li&gt;A/B 测试 (A/B Testing)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;84-竞争性需求分析的框架&quot;&gt;8.4 竞争性需求分析的框架&lt;/h2&gt;

&lt;p&gt;NABCD 模型&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;N (Need，需求)&lt;/li&gt;
  &lt;li&gt;A (Approach，做法)&lt;/li&gt;
  &lt;li&gt;B (Benefit，好处)&lt;/li&gt;
  &lt;li&gt;C (Competitors，竞争)&lt;/li&gt;
  &lt;li&gt;D (Delivery，推广)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;85-功能的定位和优先级&quot;&gt;8.5 功能的定位和优先级&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;功能和需求分类&lt;/li&gt;
  &lt;li&gt;杀手功能&lt;/li&gt;
  &lt;li&gt;外围功能&lt;/li&gt;
  &lt;li&gt;必要需求&lt;/li&gt;
  &lt;li&gt;辅助需求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;做法的分类&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;维持&lt;/li&gt;
  &lt;li&gt;抵消&lt;/li&gt;
  &lt;li&gt;优化&lt;/li&gt;
  &lt;li&gt;差异化&lt;/li&gt;
  &lt;li&gt;不做&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;86-计划和估计&quot;&gt;8.6 计划和估计&lt;/h2&gt;

&lt;p&gt;整个软件项目的时间估计：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;自底向上&lt;/li&gt;
  &lt;li&gt;回溯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在敏捷开发中不需要精确的估计，只需要粗粒度的估计，然后进入实现阶段并不断复盘即可。&lt;/p&gt;

&lt;h2 id=&quot;87-分而治之-work-breakdown-structure-wbs&quot;&gt;8.7 分而治之 (Work Breakdown Structure, WBS)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;保证所有子结点覆盖了全部父节点包含的内容&lt;/li&gt;
  &lt;li&gt;保证各个子结点不要相互覆盖&lt;/li&gt;
  &lt;li&gt;叶子结点要保证足够小，能在一个里程碑中完成&lt;/li&gt;
  &lt;li&gt;从结果 (Outcome) 出发构建 WBS，而不是从团队的活动 (Action) 出发&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;第九章-项目经理&quot;&gt;第九章 项目经理&lt;/h1&gt;

&lt;h2 id=&quot;91-pm-是啥&quot;&gt;9.1 PM 是啥&lt;/h2&gt;

&lt;p&gt;PM&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Product Manager: 产品经理&lt;/li&gt;
  &lt;li&gt;Program Manager: 项目经理&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;92-微软-pm-的来历&quot;&gt;9.2 微软 PM 的来历&lt;/h2&gt;

&lt;h1 id=&quot;第十章-典型用户和场景&quot;&gt;第十章 典型用户和场景&lt;/h1&gt;

&lt;h1 id=&quot;第十一章-软件设计与实现&quot;&gt;第十一章 软件设计与实现&lt;/h1&gt;

&lt;h1 id=&quot;第十二章-用户体验&quot;&gt;第十二章 用户体验&lt;/h1&gt;

&lt;h1 id=&quot;第十三章-软件测试&quot;&gt;第十三章 软件测试&lt;/h1&gt;

&lt;h2 id=&quot;131-基本名词解释及分类&quot;&gt;13.1 基本名词解释及分类&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Bug: 软件的缺陷&lt;/li&gt;
  &lt;li&gt;Test Case: 测试用例&lt;/li&gt;
  &lt;li&gt;Test Suite: 测试用例集&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1311-按测试设计的方法分类&quot;&gt;13.1.1 按测试设计的方法分类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;黑箱 (Black Box)&lt;/li&gt;
  &lt;li&gt;白箱 (White Box)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1312-按测试的目的分类&quot;&gt;13.1.2 按测试的目的分类&lt;/h3&gt;

&lt;h3 id=&quot;1313-按测试的时机和作用分类&quot;&gt;13.1.3 按测试的时机和作用分类&lt;/h3&gt;

&lt;h2 id=&quot;132-各种测试方法&quot;&gt;13.2 各种测试方法&lt;/h2&gt;

&lt;h3 id=&quot;1321-单元测试-unit-test&quot;&gt;13.2.1 单元测试 (Unit Test)&lt;/h3&gt;

&lt;h3 id=&quot;1322-代码覆盖率测试-code-coverage-analysis&quot;&gt;13.2.2 代码覆盖率测试 (Code Coverage Analysis)&lt;/h3&gt;

&lt;h3 id=&quot;1323-构建验证测试-build-verification-test-bvt&quot;&gt;13.2.3 构建验证测试 (Build Verification Test, BVT)&lt;/h3&gt;

&lt;h3 id=&quot;1324-验收测试-acceptance-test&quot;&gt;13.2.4 验收测试 (Acceptance Test)&lt;/h3&gt;

&lt;h3 id=&quot;1325-探索式的测试-ad-hoc-test&quot;&gt;13.2.5 “探索式”的测试 (Ad hoc Test)&lt;/h3&gt;

&lt;h3 id=&quot;1326-回归测试-regression-test&quot;&gt;13.2.6 回归测试 (Regression Test)&lt;/h3&gt;

&lt;h3 id=&quot;1327-场景--集成--系统测试-scenario--integration--system-test&quot;&gt;13.2.7 场景 / 集成 / 系统测试 (Scenario / Integration / System Test)&lt;/h3&gt;

&lt;h3 id=&quot;1328-伙伴测试-buddy-test&quot;&gt;13.2.8 伙伴测试 (Buddy Test)&lt;/h3&gt;

&lt;h3 id=&quot;1329-效能测试-performance-test&quot;&gt;13.2.9 效能测试 (Performance Test)&lt;/h3&gt;

&lt;h3 id=&quot;13210-压力测试-stress-test&quot;&gt;13.2.10 压力测试 (Stress Test)&lt;/h3&gt;

&lt;h3 id=&quot;13211-内部--外部公开测试-alpha--beta-test&quot;&gt;13.2.11 内部 / 外部公开测试 (Alpha / Beta Test)&lt;/h3&gt;

&lt;h3 id=&quot;13212-易用性测试-usability-test&quot;&gt;13.2.12 易用性测试 (Usability Test)&lt;/h3&gt;

&lt;h3 id=&quot;13213-小强大扫荡-bug-bash&quot;&gt;13.2.13 “小强”大扫荡 (Bug Bash)&lt;/h3&gt;

&lt;h1 id=&quot;第十四章-质量保障&quot;&gt;第十四章 质量保障&lt;/h1&gt;

&lt;h2 id=&quot;141-软件的质量&quot;&gt;14.1 软件的质量&lt;/h2&gt;

&lt;h2 id=&quot;1411-程序的质量&quot;&gt;14.1.1 程序的质量&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;准确度 (Precision)&lt;/li&gt;
  &lt;li&gt;覆盖率 (Recall)&lt;/li&gt;
  &lt;li&gt;速度&lt;/li&gt;
  &lt;li&gt;吞吐量&lt;/li&gt;
  &lt;li&gt;用户数量&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1412-软件工程的质量&quot;&gt;14.1.2 软件工程的质量&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;软件开发过程的可见性 (Visibility)&lt;/li&gt;
  &lt;li&gt;软件开发过程的风险控制 (Risk Management)&lt;/li&gt;
  &lt;li&gt;软件内部模块，项目中间阶段的交付质量，项目管理工具的因素&lt;/li&gt;
  &lt;li&gt;软件开发成本的控制 (Cost Control)&lt;/li&gt;
  &lt;li&gt;内部质量指标的完成情况 (Internal Benchmarks)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1413-软件工程的质量&quot;&gt;14.1.3 软件工程的质量&lt;/h3&gt;

&lt;p&gt;CMMI (Capacity Maturity Model Integrated，能力成熟度模型集成)&lt;/p&gt;

&lt;h1 id=&quot;第十五章-稳定和发布阶段&quot;&gt;第十五章 稳定和发布阶段&lt;/h1&gt;

&lt;h1 id=&quot;第十六章-it-行业的创新&quot;&gt;第十六章 IT 行业的创新&lt;/h1&gt;

&lt;h1 id=&quot;第十七章-人绩效和职业道德&quot;&gt;第十七章 人、绩效和职业道德&lt;/h1&gt;</content><author><name>ericaaaaaaaa</name></author><category term="SoftwareEngineering" /><category term="book-report" /><category term="software-engineering" /><summary type="html">【读书笔记】构建之法：现代软件工程</summary></entry><entry><title type="html">提问的智慧</title><link href="http://localhost:4000/others/2022/03/05/HowToAskQuestion.html" rel="alternate" type="text/html" title="提问的智慧" /><published>2022-03-05T00:00:00+08:00</published><updated>2022-03-05T00:00:00+08:00</updated><id>http://localhost:4000/others/2022/03/05/HowToAskQuestion</id><content type="html" xml:base="http://localhost:4000/others/2022/03/05/HowToAskQuestion.html">&lt;center&gt;&lt;h1&gt;提问的智慧&lt;/h1&gt;&lt;/center&gt;

&lt;blockquote&gt;
  &lt;p&gt;提问的目的绝不是为了轻而易举地获得答案，而是为了逐步培养自己的思考能力，去形成自己分析问题、解决问题的思路。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;提问前&quot;&gt;提问前&lt;/h2&gt;

&lt;h3 id=&quot;试图寻找答案&quot;&gt;试图寻找答案&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;手册&lt;/li&gt;
  &lt;li&gt;FAQ&lt;/li&gt;
  &lt;li&gt;网络 (Google)&lt;/li&gt;
  &lt;li&gt;熟人&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;准备好问题&quot;&gt;准备好问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;前提是否正确&lt;/li&gt;
  &lt;li&gt;说明&lt;strong&gt;做了哪些准备&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;说明&lt;strong&gt;期待的结果&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;准备好心态&quot;&gt;准备好心态&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;可能无法得到回答&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;提问时&quot;&gt;提问时&lt;/h2&gt;

&lt;h3 id=&quot;谨慎选择论坛&quot;&gt;谨慎选择论坛&lt;/h3&gt;

&lt;p&gt;难度、方向、面向人群&lt;/p&gt;

&lt;h3 id=&quot;语言组织&quot;&gt;语言组织&lt;/h3&gt;

&lt;p&gt;用词贴切、语法正确、拼写无误&lt;/p&gt;

&lt;h3 id=&quot;标题选择&quot;&gt;标题选择&lt;/h3&gt;

&lt;p&gt;使用含义丰富、描述准确的标题&lt;/p&gt;

&lt;h3 id=&quot;内容描述&quot;&gt;内容描述&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;谨慎明确的描述症状&lt;/li&gt;
  &lt;li&gt;提供发生问题的环境
    &lt;ul&gt;
      &lt;li&gt;操作系统&lt;/li&gt;
      &lt;li&gt;环境配置&lt;/li&gt;
      &lt;li&gt;版本&lt;/li&gt;
      &lt;li&gt;……&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;说明提问前的理解&lt;/li&gt;
  &lt;li&gt;说明提问前的尝试&lt;/li&gt;
  &lt;li&gt;罗列近期可能有影响的软硬件变更&lt;/li&gt;
  &lt;li&gt;话不在多&lt;/li&gt;
  &lt;li&gt;只说症状，&lt;strong&gt;不说猜想&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;按时间顺序列出症状&lt;/li&gt;
  &lt;li&gt;明白想问什么&lt;/li&gt;
  &lt;li&gt;不要问应该自己解决的问题&lt;/li&gt;
  &lt;li&gt;去除无意义的提问&lt;/li&gt;
  &lt;li&gt;谦逊的提问
    &lt;ul&gt;
      &lt;li&gt;在提问中预先道谢&lt;/li&gt;
      &lt;li&gt;在收到回答后也发出感谢&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;提问模板&quot;&gt;提问模板&lt;/h3&gt;

&lt;h4 id=&quot;工具使用&quot;&gt;工具使用&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;我使用XXXX程序时，环境情况是（操作系统版本，浏览器版本，…）,我做了XXX操作，结果出现了XXX问题，我在搜索引擎上找到XXX解答，我的理解是XXXX，我操作时出现了XXXX问题，还是无法解决问题，我也请教了同学ＸＸＸ，也没有解决问题，老师，您能帮我看看是怎么回事吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;教材学习&quot;&gt;教材学习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在每个问题后面，请说明哪一章节的什么内容引起了你的提问，提供一些&lt;strong&gt;上下文&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;列出一些&lt;strong&gt;事例或资料&lt;/strong&gt;，支持你的提问 。&lt;/li&gt;
  &lt;li&gt;说说你&lt;strong&gt;提问题的原因&lt;/strong&gt;，你说因为自己的假设和书中的不同而提问，还是不懂书中的术语，还是对推理过程有疑问，还是书中的描述和你的经验（直接经验或间接经验）矛盾?&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;我看了这一段文字 （引用文字），有这个问题 （提出问题）。 我查了资料，有这些说法（引用说法），根据我的实践，我得到这些经验（描述自己的经验）。 但是我还是不太懂，我的困惑是（说明困惑）。
【或者】我反对作者的观点（提出作者的观点，自己的观点，以及理由）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;教材代码&quot;&gt;教材代码&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;教材ＰXX代码运行结查为什么是xxxx呢？我原来认为这个地方应该是XXX，我写的代码的码云链接是XXXX。
教材ＰXX代码第X行是什么意思？这个问题我查找了XXXX资料，我的困惑是XXX。我写的代码的码云链接是XXXX。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;提问后&quot;&gt;提问后&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;问题解决
    &lt;ul&gt;
      &lt;li&gt;发个简短的说明，表达谢意，说明实践情况&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;问题未解决
    &lt;ul&gt;
      &lt;li&gt;不要重复发帖&lt;/li&gt;
      &lt;li&gt;先尝试搜索资料，说明做过的努力再提出新问题&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;问题无答案
    &lt;ul&gt;
      &lt;li&gt;不要重复发帖&lt;/li&gt;
      &lt;li&gt;向产品公司寻求帮助&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://www.dianbo.org/9238/stone/tiwendezhihui.htm&quot;&gt;提问的智慧 D.H.Grand&lt;/a&gt;
[2] &lt;a href=&quot;https://www.cnblogs.com/rocedu/p/5167941.html&quot;&gt;如何提问 娄老师&lt;/a&gt;&lt;/p&gt;</content><author><name>ericaaaaaaaa</name></author><category term="Others" /><category term="others" /><summary type="html">提问的智慧</summary></entry><entry><title type="html">概率论与数理统计</title><link href="http://localhost:4000/statistics/2022/02/17/Statistics.html" rel="alternate" type="text/html" title="概率论与数理统计" /><published>2022-02-17T00:00:00+08:00</published><updated>2022-02-17T00:00:00+08:00</updated><id>http://localhost:4000/statistics/2022/02/17/Statistics</id><content type="html" xml:base="http://localhost:4000/statistics/2022/02/17/Statistics.html">&lt;h1 id=&quot;样本空间与概率&quot;&gt;样本空间与概率&lt;/h1&gt;

&lt;h2 id=&quot;集合&quot;&gt;集合&lt;/h2&gt;

&lt;h3 id=&quot;集合运算&quot;&gt;集合运算&lt;/h3&gt;

&lt;h3 id=&quot;集合的代数&quot;&gt;集合的代数&lt;/h3&gt;

&lt;h2 id=&quot;概率模型&quot;&gt;概率模型&lt;/h2&gt;

&lt;h3 id=&quot;样本空间和事件&quot;&gt;样本空间和事件&lt;/h3&gt;

&lt;h3 id=&quot;选择适当的样本空间&quot;&gt;选择适当的样本空间&lt;/h3&gt;

&lt;h3 id=&quot;序贯模型&quot;&gt;序贯模型&lt;/h3&gt;

&lt;h3 id=&quot;概率律&quot;&gt;概率律&lt;/h3&gt;

&lt;h3 id=&quot;离散模型&quot;&gt;离散模型&lt;/h3&gt;

&lt;h3 id=&quot;连续模型&quot;&gt;连续模型&lt;/h3&gt;

&lt;h3 id=&quot;概率律的性质&quot;&gt;概率律的性质&lt;/h3&gt;

&lt;h3 id=&quot;模型和现实&quot;&gt;模型和现实&lt;/h3&gt;

&lt;h2 id=&quot;条件概率&quot;&gt;条件概率&lt;/h2&gt;

&lt;h3 id=&quot;条件概率是一个概率律&quot;&gt;条件概率是一个概率律&lt;/h3&gt;

&lt;h3 id=&quot;利用条件概率定义概率模型&quot;&gt;利用条件概率定义概率模型&lt;/h3&gt;

&lt;h2 id=&quot;全概率定义和贝叶斯准则&quot;&gt;全概率定义和贝叶斯准则&lt;/h2&gt;

&lt;h2 id=&quot;独立性&quot;&gt;独立性&lt;/h2&gt;

&lt;h3 id=&quot;条件独立&quot;&gt;条件独立&lt;/h3&gt;

&lt;h3 id=&quot;一组事件的独立性&quot;&gt;一组事件的独立性&lt;/h3&gt;

&lt;h3 id=&quot;可靠性&quot;&gt;可靠性&lt;/h3&gt;

&lt;h3 id=&quot;独立试验和二项概率&quot;&gt;独立试验和二项概率&lt;/h3&gt;

&lt;h2 id=&quot;计数法&quot;&gt;计数法&lt;/h2&gt;

&lt;h3 id=&quot;计数准则&quot;&gt;计数准则&lt;/h3&gt;

&lt;h3 id=&quot;n-选-k-排列&quot;&gt;n 选 k 排列&lt;/h3&gt;

&lt;h3 id=&quot;组合&quot;&gt;组合&lt;/h3&gt;

&lt;h3 id=&quot;分割&quot;&gt;分割&lt;/h3&gt;

&lt;h1 id=&quot;离散随机变量&quot;&gt;离散随机变量&lt;/h1&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;与随机变量有关的主要概念&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;随机变量&lt;/strong&gt;是试验结果的实值函数。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;注意：随机变量需要有数学取值（随机变量的取值），而不能是一个序列或其它无明显取值的量。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;随机变量的函数&lt;/strong&gt;定义了另一个随机变量。&lt;/li&gt;
  &lt;li&gt;对于一个随机变量，可以定义一些平均量，如&lt;strong&gt;均值&lt;/strong&gt;和&lt;strong&gt;方差&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;可以在某事件或随机变量的&lt;strong&gt;条件&lt;/strong&gt;之下定义一个随机变量。&lt;/li&gt;
  &lt;li&gt;存在一个随机变量与某事件或某随机变量相互&lt;strong&gt;独立&lt;/strong&gt;的概念。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;随机变量的分类&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;离散随机变量&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;连续随机变量&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;与离散随机变量相关的概念&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;离散随机变量&lt;/strong&gt;是试验结果的一个实值函数，但是它的取值范围只能是有限多个值或可数无限多个值。&lt;/li&gt;
  &lt;li&gt;一个随机变量有一个&lt;strong&gt;分布列&lt;/strong&gt;，它对于随机变量的每一个取值，给出一个概率。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;离散随机变量函数&lt;/strong&gt;也是一个离散随机变量，它的分布列可以从原随机变量的分布列得到。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;分布列&quot;&gt;分布列&lt;/h2&gt;

&lt;p&gt;用&lt;strong&gt;分布列&lt;/strong&gt;表示离散随机变量的取值概率的特征。用 $p_X$ 表示随机变量 $X$ 的分布列。设 $x$ 是随机变量 $X$ 的取值，则 $X$ 取值为 $x$ 的概率定义为事件 ${X=x}$ 的概率，即所有与 $x$ 对应的试验结果所组成的事件的概率，用 $p_X(x)$ 表示。&lt;/p&gt;

\[p_X(x) = P(\{X=x\})\]

&lt;blockquote&gt;
  &lt;p&gt;约定：用大写字母表示随机变量，用小写字母表示实数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;分布列的性质&lt;/strong&gt;：&lt;/p&gt;

\[\sum_x p_X(x) = 1\\
P(X\in S) = \sum_{x\in S}p_X(x)\]

&lt;h3 id=&quot;伯努利随机变量&quot;&gt;伯努利随机变量&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;背景：抛掷一枚硬币，正面向上的概率为 $p$，反面向上的概率为 $1-p$。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;伯努利随机变量呈 0-1 分布，其分布列为：&lt;/p&gt;

\[p_X(k) =
\left\{
    \begin{array}{l}
        p &amp;amp; 若 k=1\\
        1-p &amp;amp; 若 k=0
    \end{array}
\right.\]

&lt;h3 id=&quot;二项随机变量&quot;&gt;二项随机变量&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;背景：将一枚硬币抛掷 $n$ 次，每次抛掷，正面出现的概率为 $p$，反面出现的概率为 $1-p$，而且各次抛掷是相互独立的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;分布列：&lt;/p&gt;

\[p_X(k) =
\left(
    \begin{array}{l}
        n \\
        k
    \end{array}
\right)
p^k(1-p)^{n-k}\]

&lt;h3 id=&quot;几何随机变量&quot;&gt;几何随机变量&lt;/h3&gt;

&lt;h3 id=&quot;泊松随机变量&quot;&gt;泊松随机变量&lt;/h3&gt;

&lt;h2 id=&quot;随机变量的函数&quot;&gt;随机变量的函数&lt;/h2&gt;

&lt;h2 id=&quot;期望均值和方差&quot;&gt;期望、均值和方差&lt;/h2&gt;

&lt;h3 id=&quot;方差矩和随机变量的函数的期望规则&quot;&gt;方差、矩和随机变量的函数的期望规则&lt;/h3&gt;

&lt;h3 id=&quot;均值和方差的性质&quot;&gt;均值和方差的性质&lt;/h3&gt;

&lt;h3 id=&quot;某些常用的随机变量的均值和方差&quot;&gt;某些常用的随机变量的均值和方差&lt;/h3&gt;

&lt;h3 id=&quot;利用期望值进行决策&quot;&gt;利用期望值进行决策&lt;/h3&gt;

&lt;h2 id=&quot;多个随机变量的联合分布列&quot;&gt;多个随机变量的联合分布列&lt;/h2&gt;

&lt;h3 id=&quot;多个随机变量的函数&quot;&gt;多个随机变量的函数&lt;/h3&gt;

&lt;h3 id=&quot;多于两个随机变量的情况&quot;&gt;多于两个随机变量的情况&lt;/h3&gt;

&lt;h2 id=&quot;条件&quot;&gt;条件&lt;/h2&gt;

&lt;h3 id=&quot;某个事件发生的条件下的随机变量&quot;&gt;某个事件发生的条件下的随机变量&lt;/h3&gt;

&lt;h3 id=&quot;给定另一个随机变量的值的条件下的随机变量&quot;&gt;给定另一个随机变量的值的条件下的随机变量&lt;/h3&gt;

&lt;h3 id=&quot;条件期望&quot;&gt;条件期望&lt;/h3&gt;

&lt;h2 id=&quot;独立性-1&quot;&gt;独立性&lt;/h2&gt;

&lt;h3 id=&quot;随机变量与事件的相互独立性&quot;&gt;随机变量与事件的相互独立性&lt;/h3&gt;

&lt;h3 id=&quot;随机变量之间的相互独立性&quot;&gt;随机变量之间的相互独立性&lt;/h3&gt;

&lt;h3 id=&quot;几个随机变量的相互独立性&quot;&gt;几个随机变量的相互独立性&lt;/h3&gt;

&lt;h3 id=&quot;若干个相互毒瘤的随机变量的和的方差&quot;&gt;若干个相互毒瘤的随机变量的和的方差&lt;/h3&gt;

&lt;h1 id=&quot;一般随机变量&quot;&gt;一般随机变量&lt;/h1&gt;

&lt;h2 id=&quot;连续随机变量和概率密度函数&quot;&gt;连续随机变量和概率密度函数&lt;/h2&gt;

&lt;h1 id=&quot;经典统计推断&quot;&gt;经典统计推断&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;本章中认为未知参数 $\theta$ 是确定（非随机）的，而取值未知。观测 $X$ 是随机的，根据 $\theta$ 取值的不同，服从 $p_X(x;\theta)$（若 $X$ 是离散的）或 $f_X(x;\theta)$（若 $X$ 是连续的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;本章的主要术语、问题和方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;经典估计&lt;/strong&gt;是将未知参数看作是待确定的常数。对于未知参数的每个可能取值都假设一个单独的概率模型。&lt;/li&gt;
  &lt;li&gt;在&lt;strong&gt;参数估计&lt;/strong&gt;中，希望找到在未知参数取任何可能值的情况下都基本正确的估计。&lt;/li&gt;
  &lt;li&gt;在&lt;strong&gt;假设检验&lt;/strong&gt;中，未知参数对应于对立假设取有限的 $m(m\ge 2)$ 个值，想要选择一个假设，使得在任何可能的假设下错误的概率最小。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本章主要的经典推断方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;最大似然估计&lt;/strong&gt;：选择参数使得被观测到的数据“最有可能”出现，比如使获得当前数据的概率最大。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;线性回归&lt;/strong&gt;：在这样的意义下找出一组成对数据之间最合适的线性关系：这种线性关系使得模型与真实数据之间的差值的平方和最小&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;似然比检验&lt;/strong&gt;：给定两个假设，根据它们发生“可能性”的比值选择其一，使得犯错的概率适当小。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;显著性检验&lt;/strong&gt;：给定一个假设，当且仅当观测数据落在某个拒绝域的时候拒绝该假设，特别设计的拒绝域使得错误的概率低于某个给定阈值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;经典参数估计&quot;&gt;经典参数估计&lt;/h2&gt;

&lt;p&gt;将参数 $\theta$ 看作未知常数，而不是随机变量。&lt;/p&gt;

&lt;h3 id=&quot;估计量的性质&quot;&gt;估计量的性质&lt;/h3&gt;

&lt;p&gt;给定观测 $X=(X_1, …, X_n)$，&lt;strong&gt;估计量&lt;/strong&gt;是指形式为 $\hat{\Theta}=g(X)$ 的随机变量。注意，由于 $X$ 的分布依赖于 $\theta$，因而 $\hat{\theta}$ 的分布也一样。估计量 $\theta$ 的取值称为&lt;strong&gt;估计值&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;估计量的相关术语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$\hat{\Theta}$ 是未知参数 $\theta$ 的一个&lt;strong&gt;估计量&lt;/strong&gt;，也即关于 $n$ 个观测 $X_1, …, X_n$（服从依赖参数 $\theta$ 的分布）的一个函数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;估计误差&lt;/strong&gt;，记为 $\tilde{\Theta}_n$，定义为 $\tilde{\Theta}_n=\hat{\Theta}_n-\theta$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;估计量的偏差&lt;/strong&gt;，记为 $b_\theta(\hat{\Theta}_n)$，是估计误差的期望值
\(b_\theta(\hat{\Theta}_n) = \textnormal{E}_\theta[\hat{\Theta}_n]-\theta\)&lt;/li&gt;
  &lt;li&gt;$\hat{\Theta}$ 的期望值、方差和偏差都依赖于 $\theta$，而估计误差同时还依赖于观测 $X_1, …, X_n$&lt;/li&gt;
  &lt;li&gt;称 $\hat{\Theta}&lt;em&gt;n$ &lt;strong&gt;无偏&lt;/strong&gt;，若 $\textnormal{E}&lt;/em&gt;\theta[\hat{\Theta}_n] = \theta$ 对于 $\theta$ 所有可能的取值都成立。&lt;/li&gt;
  &lt;li&gt;称 $\hat{\Theta}&lt;em&gt;n$ &lt;strong&gt;渐近无偏&lt;/strong&gt;，若 $\lim&lt;/em&gt;{n\rightarrow\infty}\textnormal{E}_\theta[\hat{\Theta}_n] = \theta$ 对于所有可能的取值都成立。&lt;/li&gt;
  &lt;li&gt;称 $\hat{\Theta}_n$ 为 $\theta$ 的&lt;strong&gt;相合&lt;/strong&gt;估计序列，如果对于 $\theta$ 所有可能的取值，序列 $\hat{\Theta}_n$ 依概率收敛到参数 $\theta$ 的真值。&lt;/li&gt;
&lt;/ul&gt;

\[\textnormal{E}_\theta[\tilde{\Theta}_n^2]=b_\theta^2(\hat{\Theta}_n)+\textnormal{var}_\theta(\hat{\Theta}_n)\]

&lt;h3 id=&quot;最大似然估计&quot;&gt;最大似然估计&lt;/h3&gt;

&lt;p&gt;设观测向量 $X=(X_1,…,X_n)$ 的联合分布列为 $p_X(x;\theta)=p_X(x_1, …, x_n;\theta)$（$\theta$ 可为向量或数量），其中 $X = (X_1, …, X_n)$ 为 $X$ 的观测值。那么，&lt;strong&gt;最大似然估计&lt;/strong&gt;是使（$\theta$ 的）数值函数 $p_X=(x_1, …, x_n;\theta)$ 达到最大的参数值：&lt;/p&gt;

\[\hat{\theta}_n=\underset{\theta}{\argmax} p_X(x_1, ..., x_n;\theta)\]

&lt;p&gt;当 $X$ 为连续型随机变量时，可将同样的方法用于联合概率密度函数 $f_X(x;\theta)$&lt;/p&gt;

\[\hat{\theta}_n=\underset{\theta}{\argmax} f_X(x_1, ..., x_n;\theta)\]

&lt;p&gt;称 $p_X(x;\theta)$（或 $f_X(x;\theta)$，若 $X$ 为连续型随机变量）为&lt;strong&gt;似然函数&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于已知 $X$ 的观测值 $x$，$p_X(x;\theta)$ 不是未知参数等于 $\theta$ 的概率，而是当参数取值为 $\theta$ 时，观测值 $x$ 可能出现的概率。
为取定 $\theta$ 的估计值时，会考虑基于已知的观测，$\theta$ 取什么值可使观测值最可能出现，这就是“似然”的本意。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很多应用中都假设观测 $X_i$ 独立，从而对于每个 $i$，$X_i$ 是离散的随机变量，似然函数的形式为&lt;/p&gt;

\[p_X(x_1,...,x_n;\theta)=\prod_{i=1}^n p_{X_i}(x_i;\theta)\]

&lt;p&gt;在这种情况下，为了分析和计算的方便可让其对数达到最大，下面的式子称为&lt;strong&gt;对数似然函数&lt;/strong&gt;。&lt;/p&gt;

\[\ln p_X(x_1,...,x_n;\theta) =\ln \prod_{i=1}^n p_{X_i}(x_i;\theta) = \sum_{i=1}^n\ln p_{X_i}(x_i;\theta)\]

&lt;p&gt;当 $X$ 为连续型随机变量时，类似的用概率密度函数取代分布列：&lt;/p&gt;

\[\ln f_X(x_1,...,x_n;\theta) =\ln \prod_{i=1}^n f_{X_i}(x_i;\theta) = \sum_{i=1}^n\ln f_{X_i}(x_i;\theta)\]

&lt;h3 id=&quot;随机变量均值和方差的估计&quot;&gt;随机变量均值和方差的估计&lt;/h3&gt;

&lt;h3 id=&quot;置信区间&quot;&gt;置信区间&lt;/h3&gt;

&lt;h3 id=&quot;基于方差近似估计量的置信区间&quot;&gt;基于方差近似估计量的置信区间&lt;/h3&gt;

&lt;h2 id=&quot;线性回归&quot;&gt;线性回归&lt;/h2&gt;

&lt;h3 id=&quot;最小二乘公式的合理性&quot;&gt;最小二乘公式的合理性&lt;/h3&gt;

&lt;h3 id=&quot;贝叶斯线性回归&quot;&gt;贝叶斯线性回归&lt;/h3&gt;

&lt;h3 id=&quot;非线性回归&quot;&gt;非线性回归&lt;/h3&gt;

&lt;h2 id=&quot;简单假设检验&quot;&gt;简单假设检验&lt;/h2&gt;

&lt;h3 id=&quot;假设检验的基本思想与概念&quot;&gt;假设检验的基本思想与概念&lt;/h3&gt;

&lt;h4 id=&quot;假设检验问题&quot;&gt;假设检验问题&lt;/h4&gt;

&lt;p&gt;假如试验结果与假设 H 发生矛盾就拒绝原假设 H，否则就接受原假设。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;假设&lt;/strong&gt;：如 $\theta\in\Theta_0$ 或 $\theta\in\Theta_1$&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;检验&lt;/strong&gt;或&lt;strong&gt;检验法则&lt;/strong&gt;：通过样本对一个假设作出“对”或“不对”的具体判断的规则称为该假设的一个检验或检验法则。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;检验的结果若是肯定该命题，则接受这个假设，否则就拒绝该假设。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;参数假设检验问题&lt;/strong&gt; &amp;amp; &lt;strong&gt;非参数假设检验问题&lt;/strong&gt;：若假设可用一个参数的集合表示，该假设问题称为&lt;strong&gt;参数假设检验问题&lt;/strong&gt;，否则称为&lt;strong&gt;非参数假设检验问题&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;假设检验的基本步骤&quot;&gt;假设检验的基本步骤&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般情况下，寻找某对假设的显著性检验的步骤如下：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;根据实际问题，建立统计假设 $H_0$ vs $H_1$&lt;/li&gt;
    &lt;li&gt;选取一个合适的检验统计量 $T(X)$，使得当 $H_0$ 成立时（或 $H_0$ 中某个具体参数下），$T$ 的分布完全已知，并根据 $H_0$ 及 $H_1$ 的特点，确定拒绝域 $W$ 的形状&lt;/li&gt;
    &lt;li&gt;确定显著性水平 $\alpha$，确定具体的拒绝域 $W$&lt;/li&gt;
    &lt;li&gt;由样本观测值 $x_1,x_2,…,x_n$，计算检验统计量的 $T(x_1,…,x_n)$，由 $T(x_1,…,x_n)$ 是否属于 $W$，做出最终判断。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;一建立假设&quot;&gt;一、建立假设&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;背景：
设有来自某一个参数分布族 ${F(x,\theta)|\theta\in\Theta}$ 的样本 $x_1, x_2,…,x_n$，其中 $\Theta$ 为&lt;strong&gt;参数空间&lt;/strong&gt;，设 $\Theta_0\subset \Theta$，且 $\Theta_0\not ={\emptyset}$，则命题 $H_0:\theta\in\Theta_0$ 称为一个假设或&lt;strong&gt;原假设&lt;/strong&gt;或&lt;strong&gt;零假设&lt;/strong&gt; (null hypothesis)，若有另一个 $\Theta_1(\Theta_1\subset\Theta$，$\Theta_1\Theta_0=\emptyset$，常见的一种情况是 $\Theta_1=\Theta-\Theta_0)$，则命题 $H_1:\theta\in\Theta_1$ 称为 $H_0$ 的&lt;strong&gt;对立假设&lt;/strong&gt;或&lt;strong&gt;备择假设&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;$H_0:\theta\in\Theta_0\qquad vs\qquad H_1:\theta\in\Theta_1$&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;简单原假设&lt;/strong&gt;与&lt;strong&gt;复杂原假设&lt;/strong&gt;：如果 $\Theta_0$ 只含一个点，我们称之为&lt;strong&gt;简单原假设&lt;/strong&gt;，否则称之为&lt;strong&gt;复杂&lt;/strong&gt;或&lt;strong&gt;复合&lt;/strong&gt;原假设。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;双侧假设&lt;/strong&gt;或&lt;strong&gt;双边假设&lt;/strong&gt;：备择假设分散在原假设两侧，如 $H_1’:\theta\not ={\theta_0}$，$H_1’’:\theta&amp;lt;\theta_0$……&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;单侧假设&lt;/strong&gt;或&lt;strong&gt;单边假设&lt;/strong&gt;：备择假设位于原假设的一侧&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;二选择检验统计量给出拒绝域形式&quot;&gt;二、选择检验统计量，给出拒绝域形式&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;假设的检验&lt;/strong&gt;：对于假设的&lt;strong&gt;检验&lt;/strong&gt;是指这样的一个法则：当有了具体的样本后，按该法则就可以决定是接受 $H_0$ 还是拒绝 $H_0$，即检验就等于把样本空间划分为两个互不相交的部分 $W$ 和 $\overline{W}$，当样本属于 $W$ 时，拒绝 $H_0$；否则接受 $H_0$。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;拒绝域&lt;/strong&gt;与&lt;strong&gt;接受域&lt;/strong&gt;：称 $W$ 为该假设的&lt;strong&gt;拒绝域&lt;/strong&gt;，而 $\overline{W}$ 称为&lt;strong&gt;接受域&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;检验统计量&lt;/strong&gt;：由样本对原假设进行检验通过的统计量。&lt;/li&gt;
  &lt;li&gt;检验的&lt;strong&gt;判断准则&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;若 $(x_1,…,x_n)\in W$，则拒绝 $H_0$&lt;/li&gt;
      &lt;li&gt;若 $(x_1,…,x_n)\in \overline{W}$，则接受 $H_0$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;三选择显著性水平&quot;&gt;三、选择显著性水平&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;第一类错误&lt;/strong&gt;与&lt;strong&gt;第二类错误&lt;/strong&gt;
| 观测数据情况 | $H_0$ 为真 | $H_1$ 为真 |
| — | — | — |
| $(x_1, x_2,…, x_n)\in W$ | 犯第一类错误 | 正确 |
} $(x_1, x_2,…, x_n)\in \overline{W}$ | 正确 | 犯第二类错误 |
    &lt;ul&gt;
      &lt;li&gt;称第一类错误为&lt;strong&gt;拒真错误&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;称第二类错误为&lt;strong&gt;取伪错误&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;$\alpha$：犯第一类错误的概率：$\alpha=P_\theta{X\in W},\theta\in\Theta_0$，也记为 $P{X\in W&lt;/td&gt;
          &lt;td&gt;H_0}$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;$\beta$：犯第二类错误的概率：$\beta=P_\theta{X\in\overline{W}&lt;/td&gt;
          &lt;td&gt;H_1}$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;势函数&lt;/strong&gt;或&lt;strong&gt;功效函数&lt;/strong&gt; (power function)
设检验问题 $H_0:\theta\in\Theta_0\qquad vs\qquad H_1:\theta\in\Theta_1$ 的拒绝域为 $W$，则样本观测值 $X$ 落在拒绝域 $W$ 内的概率称为该检验的&lt;strong&gt;势函数&lt;/strong&gt;，记为 $g(\theta)=P_\theta(X\in W)$，$\theta\in\Theta=\Theta_0\cup\Theta_1$&lt;/li&gt;
&lt;/ul&gt;

\[g(\theta) = 
\left\{
  \begin{array}
    \alpha(\theta) &amp;amp; \theta\in\Theta_0\\
    1-\beta(\theta) &amp;amp; \theta\in\Theta_1
  \end{array}
\right.\]

&lt;p&gt;或&lt;/p&gt;

\[g(\theta) = 
\left\{
  \begin{array}
    \alpha(\theta) = g(\theta) &amp;amp; \theta\in\Theta_0 \\
    \beta(\theta) = 1-g(\theta) &amp;amp; \theta\in\Theta_1
  \end{array}
\right.\]

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;显著性水平为 $\alpha$ 的显著性检验&lt;/strong&gt;：对检验问题 $H_0:\theta\in\Theta_0\qquad vs\qquad H_1:\theta\in\Theta_1$，如果一个检验满足对任意的$\theta\in\Theta_0$，都有 $g(\theta)\le\alpha$，则称该检验是显著性水平为 $\alpha$ 的显著性检验。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;常用的选择是 $\alpha = 0.05$，有时也可以选择 $\alpha=0.10$ 或 $\alpha=0.01$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;四给出拒绝域&quot;&gt;四、给出拒绝域&lt;/h5&gt;

&lt;h5 id=&quot;五做出判断&quot;&gt;五、做出判断&lt;/h5&gt;

&lt;h4 id=&quot;检验的-p-值&quot;&gt;检验的 p 值&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;检验的 p 值&lt;/strong&gt;：再一个假设检验问题中，利用样本观测能够做出拒绝原假设的最小显著性水平称为检验的 p 值。
    &lt;ul&gt;
      &lt;li&gt;如果 $\alpha \ge p$，则再显著性水平 $\alpha$ 下拒绝 $H_0$&lt;/li&gt;
      &lt;li&gt;如果 $\alpha &amp;lt; p$，则在显著性水平 $\alpha$ 下接受 $H_0$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;正态总体参数假设检验&quot;&gt;正态总体参数假设检验&lt;/h2&gt;

&lt;h3 id=&quot;单个正态总体均值的检验&quot;&gt;单个正态总体均值的检验&lt;/h3&gt;

&lt;p&gt;设 $x_1, …, x_n$ 是来自 $N(\mu,\sigma^2)$ 的样本，考虑如下三种关于 $\mu$ 的检验问题：&lt;/p&gt;

\[I\qquad H_0:\mu\le \mu_0 \qquad vs \qquad H_1:\mu&amp;gt;\mu_0\\
II\qquad H_0:\mu\ge\mu_0\qquad vs\qquad H_1:\mu&amp;lt;\mu_0 \\
III\qquad H_0:\mu = \mu_0\qquad vs\qquad H_1:\mu\not ={\mu_0}\]

&lt;p&gt;其中 $\mu_0$ 是已知常数。&lt;/p&gt;

&lt;h4 id=&quot;一sigma-已知时的-u-检验&quot;&gt;一、$\sigma$ 已知时的 $u$ 检验&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;检验统计量&lt;/strong&gt; $u = \frac{\overline{x}-\mu_0}{\sigma/\sqrt{n}}$
    &lt;ul&gt;
      &lt;li&gt;由于 $\mu$ 的点估计是 $\overline{x}$，且 $\overline{x}\sim N(\mu, \sigma^2/n)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;拒绝域&lt;/strong&gt; $W_1={(x_1,…,x_n):u\ge c}$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;显著性检验&quot;&gt;显著性检验&lt;/h2&gt;

&lt;h3 id=&quot;一般方法&quot;&gt;一般方法&lt;/h3&gt;

&lt;h3 id=&quot;广义似然比和拟合优度检验&quot;&gt;广义似然比和拟合优度检验&lt;/h3&gt;</content><author><name>ericaaaaaaaa</name></author><category term="Statistics" /><category term="note" /><category term="statistics" /><category term="math" /><summary type="html">样本空间与概率</summary></entry><entry><title type="html">机器学习</title><link href="http://localhost:4000/machinelearning/2022/02/13/WatermelonBook.html" rel="alternate" type="text/html" title="机器学习" /><published>2022-02-13T00:00:00+08:00</published><updated>2022-02-13T00:00:00+08:00</updated><id>http://localhost:4000/machinelearning/2022/02/13/WatermelonBook</id><content type="html" xml:base="http://localhost:4000/machinelearning/2022/02/13/WatermelonBook.html">&lt;h1 id=&quot;概念&quot;&gt;概念&lt;/h1&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;

&lt;h3 id=&quot;机器学习&quot;&gt;机器学习&lt;/h3&gt;

&lt;h3 id=&quot;数据&quot;&gt;数据&lt;/h3&gt;

&lt;h4 id=&quot;训练集&quot;&gt;训练集&lt;/h4&gt;

&lt;h4 id=&quot;验证集&quot;&gt;验证集&lt;/h4&gt;

&lt;h4 id=&quot;测试集&quot;&gt;测试集&lt;/h4&gt;

&lt;h2 id=&quot;模型评估&quot;&gt;模型评估&lt;/h2&gt;

&lt;h3 id=&quot;错误率-error-rate&quot;&gt;错误率 (error rate)&lt;/h3&gt;

&lt;p&gt;分类&lt;strong&gt;错误&lt;/strong&gt;的样本数占样本总数的比例称为“错误率”。&lt;/p&gt;

&lt;h3 id=&quot;精度-accuracy&quot;&gt;精度 (accuracy)&lt;/h3&gt;

&lt;p&gt;分类&lt;strong&gt;正确&lt;/strong&gt;的样本数占样本总数的比例称为“精度”。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;精度 = 1 - 错误率&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;误差-error&quot;&gt;误差 (error)&lt;/h3&gt;

&lt;p&gt;把学习器的实际预测输出与样本的真实输出之间的差异称为“误差”。&lt;/p&gt;

&lt;h4 id=&quot;训练误差-training-error--经验误差-empirical-error&quot;&gt;训练误差 (training error) / 经验误差 (empirical error)&lt;/h4&gt;

&lt;p&gt;学习器再训练集上的误差。&lt;/p&gt;

&lt;h4 id=&quot;泛化误差-generalization-error&quot;&gt;泛化误差 (generalization error)&lt;/h4&gt;

&lt;p&gt;学习器在新样本上的误差。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目标：得到泛化误差最小的学习器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;拟合&quot;&gt;拟合&lt;/h3&gt;

&lt;h4 id=&quot;欠拟合-underfitting&quot;&gt;欠拟合 (underfitting)&lt;/h4&gt;

&lt;h4 id=&quot;过拟合-overfitting&quot;&gt;过拟合 (overfitting)&lt;/h4&gt;

&lt;h3 id=&quot;模型参数&quot;&gt;模型参数&lt;/h3&gt;

&lt;h4 id=&quot;超参数&quot;&gt;超参数&lt;/h4&gt;

&lt;p&gt;算法的参数，一般数量较少。&lt;/p&gt;

&lt;h4 id=&quot;其它参数&quot;&gt;其它参数&lt;/h4&gt;

&lt;p&gt;模型的参数，一般数量较多。&lt;/p&gt;

&lt;h2 id=&quot;模型&quot;&gt;模型&lt;/h2&gt;

&lt;h3 id=&quot;线性模型-linear-model&quot;&gt;线性模型 (linear model)&lt;/h3&gt;

&lt;h4 id=&quot;概念-1&quot;&gt;概念&lt;/h4&gt;

&lt;p&gt;线性模型试图学得一个通过属性的线性组合来进行预测的函数，即&lt;/p&gt;

\[f(x) = w_1x_1+w_2x_2+...+w_dx_d+b\]

&lt;p&gt;一般用向量形式写成&lt;/p&gt;

\[f(x) = w^Tx+b\]

&lt;p&gt;其中 $w=(w_1;w_2;…;2_d$。 $w$ 和 $b$ 学得之后，模型就得以确定。&lt;/p&gt;

&lt;h4 id=&quot;优缺点&quot;&gt;优缺点&lt;/h4&gt;

&lt;h3 id=&quot;非线性模型&quot;&gt;非线性模型&lt;/h3&gt;

&lt;h1 id=&quot;方法&quot;&gt;方法&lt;/h1&gt;

&lt;h2 id=&quot;模型评估-1&quot;&gt;模型评估&lt;/h2&gt;

&lt;h3 id=&quot;留出法-hold-out&quot;&gt;留出法 (hold-out)&lt;/h3&gt;

&lt;p&gt;将数据集 $D$ 划分为两个互斥的集合，其中一个作为训练集 $S$，另一个作为测试集 $T$，即 $D=S\cup T$, $S\cap T=\empty$，在$S$ 上训练出模型后，用 $T$ 来评估其测试误差，作为对泛化误差的估计。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要注意的是，训练 / 测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程中引入额外的偏差而对最终结果产生映像。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于存在多种划分方式对初始数据集 $D$ 进行分割，因此单次使用留出法的估计结果往往不够稳定可靠，在使用留出法时，一般采用若干次随机划分、重复进行实验评估后取平均值作为留出法的评估结果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;常见的做法是将大约 $2/3\sim 4/5$ 的样本用于训练、剩余样本用于测试。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;交叉验证法-cross-validation&quot;&gt;交叉验证法 (cross validation)&lt;/h3&gt;

&lt;p&gt;先将数据集 $D$ 划分为 $k$ 个大小相似的互斥子集，即 $D=D_1\cup D_2\cup…\cup D_k$, $D_i\cap D_j=\empty (i\not= j)$，每个子集 $D_i$ 都尽可能保持数据分布的一致性，即从 $D$ 中通过分层采样得到。然后每次用 $k-1$ 个子集的并集作为训练集，余下的那个子集作为测试集；这样就可以获得 $k$ 组训练 / 测试集，从而可以进行 $k$ 次训练 / 测试，最终返回的是这 $k$ 个测试结果的均值。&lt;/p&gt;

&lt;p&gt;交叉验证法评估结果的稳定性和保真性很大程度上取决于 $k$ 的取值，通常把交叉验证法称为&lt;strong&gt;k 折交叉验证&lt;/strong&gt; (k-fold cross validation)。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$k$ 最常用的取值是 10。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将数据集 $D$ 划分为 $k$ 个子集，随机使用不同的划分重复 $p$ 次，最终的评估结果是这 $p$ 次 $k$ 折交叉验证结果的均值，称为 $p$ 次 $k$ 折交叉验证。&lt;/p&gt;

&lt;h4 id=&quot;留一法-leave-one-out-loo&quot;&gt;留一法 (Leave-One-Out, LOO)&lt;/h4&gt;

&lt;p&gt;假定数据集 $D$ 中包含 $m$ 个样本，若令 $k=m$，则得到交叉验证法的一个特例——留一法。&lt;/p&gt;

&lt;p&gt;由于留一法不受随机样本划分方式的映像，因此在绝大多数情况下，留一法中被实际评估的模型与期望评估的用 $D$ 训练出来的模型很相似。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;留一法的评估结果往往被认为比较准确。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;留一法在数据集较大的情况下的开销是巨大的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;自助法-bootstrapping&quot;&gt;自助法 (bootstrapping)&lt;/h3&gt;

&lt;p&gt;自助法直接以自助采样法 (bootstrapping sampling) 为基础。给定包含 $m$ 个样本的数据集 $D$，对它进行采样产生数据集 $D’$。每次随机从 $D$ 中挑选一个样本，将其拷贝放入 $D’$，然后再将该样本放回初始数据集 $D$ 中，使得该样本在下次采样时仍有可能被采到。上述过程重复执行 $m$ 次后，得到包含 $m$ 个样本的数据集 $D’$，这就是自助采样的结果。&lt;/p&gt;

&lt;p&gt;$D$ 中有一部分样本会在 $D’$ 中多次出现，而另一部分样本不出现。估计样本在 $m$ 次采样中始终不被采到的概率是 $(1-\frac{1}{m})^m$，取极限得到
\(\lim_{m\rightarrow \infty}(1-\frac{1}{m})^m = \frac{1}{e}\approx 0.368\)
由上式可得，通过自助采样，初始数据集 $D$ 中约有 36.8% 的样本未出现在采样数据集 $D’$ 中。将 $D’$ 用作训练集，$D/D’$ 用作测试集；这样，实际评估的模型与期望评估的模型都使用 $m$ 个训练样本，而我们仍有数据总量约 $1/3$ 的，没在训练集中出现过的样本用于测试，这样的测试结果，亦称为“&lt;strong&gt;包外估计&lt;/strong&gt;” (out-of-bag estimate)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;自助法在数据集较小、难以有效划分训练 / 测试集时很有用。&lt;/li&gt;
      &lt;li&gt;自助法能从初始数据集中产生多个不同的训练集，这对集成学习等方法有很大好处。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;自助法产生的数据集改变了初始数据集的分布，会引入估计偏差。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;调参与最终模型&quot;&gt;调参与最终模型&lt;/h3&gt;

&lt;h2 id=&quot;性能度量-performance-measure&quot;&gt;性能度量 (performance measure)&lt;/h2&gt;

&lt;p&gt;衡量模型泛化能力的评价标准。&lt;/p&gt;

&lt;p&gt;不同的任务需求会有不同的性能度量方式。&lt;/p&gt;

&lt;h3 id=&quot;分类任务&quot;&gt;分类任务&lt;/h3&gt;

&lt;h4 id=&quot;错误率与精度&quot;&gt;错误率与精度&lt;/h4&gt;

&lt;h5 id=&quot;错误率&quot;&gt;错误率&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;错误率&lt;/strong&gt;是分类错误的样本数占样本总数的比例。&lt;/p&gt;

&lt;p&gt;对于样例集 $D$，错误率 $E$ 定义为：
\(E(f;D)=\frac{1}{m}\sum_{i=l}^{m}\mathbb{I}(f(x_i)\not= y_i)\)&lt;/p&gt;

&lt;h5 id=&quot;精度&quot;&gt;精度&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;精度&lt;/strong&gt;是分类正确的样本数占样本总数的比例。&lt;/p&gt;

&lt;p&gt;对于样例集 $D$，精度 $acc$ 定义为：
\(acc(f;D)=\frac{1}{m}\sum_{i=1}^{m}\mathbb{I}(f(x_i)=y_i)=1-E(f;D)\)
更一般的，对于数据分布 $D$ 和概率密度函数 $p(\cdot)$，错误率和精度可以分别描述为
\(E(f;D)=\int_{x\sim D}\mathbb{I}(f(x)\not= y)p(x)dx\\
acc(f;D)=\int_{x\sim D}\mathbb{I}(f(x)= y)p(x)dx = 1-E(f;D)\)&lt;/p&gt;

&lt;h4 id=&quot;查准率查全率与-f1&quot;&gt;查准率、查全率与 F1&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/Precisionrecall.svg/700px-Precisionrecall.svg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;真实情况 \ 预测结果&lt;/th&gt;
      &lt;th&gt;正例&lt;/th&gt;
      &lt;th&gt;反例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;正例&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;$TP$ （真正例）&lt;/td&gt;
      &lt;td&gt;$FN$（假反例）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;反例&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;$FP$（假正例）&lt;/td&gt;
      &lt;td&gt;$TN$（真反例）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;查准率-precision&quot;&gt;查准率 (precision)&lt;/h5&gt;

&lt;p&gt;预测正例中真实正例的占比。
\(P = \frac{TP}{TP+FP}\)&lt;/p&gt;

&lt;h5 id=&quot;查全率-recall&quot;&gt;查全率 (recall)&lt;/h5&gt;

&lt;p&gt;真实正例中预测正例的占比。
\(P = \frac{TP}{TP+FN}\)
查准率和查全率是一对矛盾的变量，查准率高时，查全率往往偏低。&lt;/p&gt;

&lt;h5 id=&quot;p-r-曲线查准率-查全率曲线&quot;&gt;P-R 曲线（查准率-查全率曲线）&lt;/h5&gt;

&lt;p&gt;根据学习器的预测结果对样例进行排序，从最有可能为正例的样本开始，到最不可能为正例的样本，按此顺序逐一将样本作为正例进行预测，每次可以计算出当前的查全率、查准率。以查准率为纵轴，以查全率为横轴作图，得到查准率-查全率曲线，简称“P-R 曲线”，显示该曲线的图称为“P-R 图”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://media.geeksforgeeks.org/wp-content/uploads/20190611002050/pr_roc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;P-R 曲线越靠外，模型效果越好。&lt;/p&gt;

&lt;h6 id=&quot;度量&quot;&gt;度量&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;平衡点&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;”&lt;strong&gt;平衡点&lt;/strong&gt;“ (Break-Even Point, BEP) 是查准率和查全率的一个性能度量，它是”&lt;strong&gt;查准率 = 查全率&lt;/strong&gt;“时的取值。平衡点值越高，可以认为模型越优。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;$F1$ 度量&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;F1 基于查准率与查全率的调和平均 (harmonic mean) 定义：
\(\frac{1}{F1} = \frac{1}{2} \cdot (\frac{1}{P} + \frac{1}{R}) \\
F1 = \frac{2\times P\times R}{P+R} = \frac{2\times TP}{样例总数+TP-TN}\)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;$F_\beta$ 度量&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;在一些任务中，对查准率和查全率的重视程度有所不同，因此引入 $F1$ 度量的一般形式——$F_\beta$，它能够表达出对查准率 / 查全率的不同偏好，定义为查准率和查全率的加权调和平均：
\(\frac{1}{F_\beta} = \frac{1}{1+\beta^2} \cdot (\frac{1}{P} + \frac{\beta^2
}{R}) \\
F_\beta = \frac{(1+\beta^2)\times P\times R}{(\beta^2\times P)+R}\)
其中 $\beta&amp;gt;0$ 度量了查全率对查准率的相对重要性，$\beta=1$ 时退化为标准的 $F1$；$\beta&amp;gt;1$ 时查全率有更大影响；$0&amp;lt;\beta&amp;lt;1$ 时查准率有更大影响。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;全局&quot;&gt;全局&lt;/h6&gt;

&lt;p&gt;先在各混淆矩阵上分别计算出查准率和查全率，记为 $(P_1, R_1),(P_2,R_2),…,(P_n,R_n)$，再计算平均值，这样就得到“宏查准率” (macro-P)，“宏查全率” (“macro-R”)，以及相应的“宏-$F1$” (macro-$F1$)
\(macro{\textit-}P= \frac{1}{n}\sum_{i=1}^n P_i\\
macro{\textit-}R = \frac{1}{n}\sum_{i=1}^n R_i\\
macro{\textit-}F1 = \frac{2\times macro{\textit-}P\times macro{\textit-}R}{macro{\textit-}P+macro{\textit-}R}\)&lt;/p&gt;

&lt;h6 id=&quot;局部&quot;&gt;局部&lt;/h6&gt;

&lt;p&gt;先将各混淆矩阵的对应元素进行平均，得到 $TP$、$FP$、$TN$、$FN$ 的平均值，分别记为 $\overline{TP}$、$\overline{FP}$、$\overline{TN}$、$\overline{FN}$，再基于这些平均值计算出“微查准率” ($micro{\textit-}P$)、“微查全率” ($micro{\textit-}R$) 和“微 $F1$” ($micro{\textit-}F1$)：
\(micro{\textit-}P = \frac{\overline{TP}}{\overline{TP}+\overline{FP}}\\
micro{\textit-}R = \frac{\overline{TP}}{\overline{TP}+\overline{FN}}\\
micro{\textit-}F1 = \frac{2\timesmicro{\textit-}P\timesmicro{\textit-}R}{micro{\textit-}P+micro{\textit-}R}\)&lt;/p&gt;

&lt;h4 id=&quot;roc-与-auc&quot;&gt;ROC 与 AUC&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;很多学习器是测试样本产生一个实值或概率预测，然后将这个预测值与一个分类域值 (threshold) 进行比较，若大于域值则分正类，否则为反类。这个分类域值直接决定了学习器的泛化能力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ROC 的全称是“受试者工作特征”（Receiver Operating Characteristic）曲线。其&lt;strong&gt;以“真正例率 (True Positive Rate, TPR)” 为纵轴&lt;/strong&gt;，&lt;strong&gt;以“假正例率 (False Positive Rate, FPR)” 为横轴&lt;/strong&gt;。&lt;/p&gt;

\[TPR = \frac{TP}{TP+TN}\\
FPR = \frac{FP}{TN+FP}\]

&lt;p&gt;显示 ROC 曲线的图称为“ROC”图。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;图像分析&lt;/strong&gt;：ROC 图中对角线对应于“随机猜测”模型，而点 (0,1) 对应将所有正例排在所有反例之前的“理想模型”。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;绘图过程&lt;/strong&gt;：给定 $m^+$ 个正例和 $m^-$ 个反例，根据学习器预测结果对样例进行排序，然后把分类域值设为最大，即把所有样例均预测为反例，此时真正例率和假正例率均为 0，在坐标 (0, 0) 处标记一个点。然后，将分类域值依次设置为每个样例的预测值，即依次将每个样例划分为正例，设前一个标记点坐标为 (x, y)，当前若为真正例，则对应标记点的坐标为 (x, y+$\frac{1}{m^+}$)，当前若为假正例，则对应标记点的坐标为 (x+$\frac{1}{m^-}$, y)，然后用线段连接相应点即得。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;学习器比较&lt;/strong&gt;：比较 ROC 曲线下的面积，即 &lt;strong&gt;AUC(Area Under ROC Curve)&lt;/strong&gt;，AUC 越大，则学习器效果越好。
\(AUC = \frac{1}{2}+\sum_{i=1}^{m-1}(x_{i+1}-x_i)\cdot(y_i+y_{i+1})\)
定义排序“损失” (loss) 为：
\(l_{rank} = \frac{1}{m^+m^-}\sum_{x^+\in D^+}\sum_{x^-\in D^-}(\mathbb{I}(f(x^+)&amp;lt;f(x^-))+\frac{1}{2}\mathbb{I}(f(x^+)=f(x^-)))\)
从几何意义上看，$l_{rank}$ 对应的是 ROC 曲线之上的面积，故有：
\(AUC + l_{rank} = 1\)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;代价敏感错误率与代价曲线&quot;&gt;代价敏感错误率与代价曲线&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在现实任务中，不同类型的错误所造成的后果不同。，为权衡不同类型错误所造成的不同损失，可为错误赋予“非均等代价” (unequal cost)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据任务的领域知识设定一个“代价矩阵” (cost matrix)，其中 $cost_{ij}$ 表示将第 $i$ 类样本预测为第 $j$ 类样本的代价。一般来说，$cost_{ii}=0$&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般情况下，重要的是 $cost$ 之间的&lt;em&gt;比值&lt;/em&gt;而非&lt;em&gt;绝对值&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目标：最小化“总体代价” (total cost)。&lt;/p&gt;

&lt;p&gt;以二分类为例，将第 0 类作为正类，第 1 类作为反类，$D^+$ 与 $D^-$ 分别代表样例集 $D$ 的正例子集和反例子集，则“代价敏感” (cost-sensitive) 错误率为：&lt;/p&gt;

\[E(f;D;cost) = \frac{1}{m}(\sum_{x_i\in D^+}\mathbb{I}(f(x_i)\not ={y_i})\times cost_{01} +
                          \sum_{x_i\in D^-}\mathbb{I}(f(x_i)\not ={y_i})\times cost_{10})\]

&lt;p&gt;在非均等代价下，ROC 曲线不能直接反映出学习器的期望总体代价，而“代价曲线” (cost curve) 则可以达到该目的，代价曲线图的横轴是取值为 [0, 1] 的正例概率代价&lt;/p&gt;

\[p(+)cost = \frac{\times cost_{01}}{p\times cost_{01}+(1-p)\times cost_{10}}\]

&lt;p&gt;其中 $p$ 的样例为正例的概率；纵轴是取值为 [0, 1] 的归一化代价。&lt;/p&gt;

\[cost_{norm} = \frac{FNR\times p\times cost_{01}+FPR\times(1-p)\times cost_{10}}{p\times cost_{01}+(1-p)\times cost_{10}}\]

&lt;h3 id=&quot;聚类任务&quot;&gt;聚类任务&lt;/h3&gt;

&lt;h2 id=&quot;比较检验&quot;&gt;比较检验&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;统计假设检验&lt;/strong&gt; (hypothesis test) 为我们的学习器性能提供了重要依据。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在下述部分以错误率为性能度量，用 $\epsilon$ 表示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;假设检验&quot;&gt;假设检验&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设检验中的“假设”是对学习器泛化错误率分布的某种判断或猜想。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可根据测试错误率估推出泛化错误率的分布。&lt;/p&gt;

&lt;p&gt;泛化错误率为 $\epsilon$ 的学习器在一个样本上犯错的概率是 $\epsilon$；测试错误率 $\hat{\epsilon}$ 意味着在 $m$ 个测试样本中恰有  $\hat{\epsilon}\times m$ 个被误分类。假定测试样本是从样本总体分布中独立采样而得，那么泛化错误率为 $\epsilon$ 的学习器将其中 $m’$ 的样本误分类、其余样本全部分类正确的概率为 $\left(\begin{array}{l}m\m’\end{array}\right)\epsilon^{m’}(1-\epsilon)^{m- m’}$ ；由此可估算出其恰好将 $\hat{\epsilon}\times m$ 个样本误分类的概率如下式所示，这也表达了在 $m$ 个样本集的测试集上，泛化错误率为 $\epsilon$ 的学习器被测得测试错误率为 $\hat{\epsilon}$ 的概率：&lt;/p&gt;

\[P(\hat{\epsilon};\epsilon) = 
\left(
  \begin{array}{l}
  m\\
  \hat{\epsilon}\times m  \end{array}
\right)
\epsilon^{\hat{\epsilon}\times m}(1-\epsilon)^{m- \hat{\epsilon}\times m}\]

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;给定测试错误率，则解 $\partial P(\hat{\epsilon};\epsilon)/\partial\epsilon$ 可知，$P(\hat{\epsilon};\epsilon)$ 在 $\epsilon=\hat{\epsilon}$ 时最大，$&lt;/td&gt;
      &lt;td&gt;\epsilon-\hat{\epsilon}&lt;/td&gt;
      &lt;td&gt;$ 增大时 $P(\hat{\epsilon}, \epsilon)$ 减小。这符合&lt;strong&gt;二项分布 (binomial)&lt;/strong&gt; 分布。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;考虑假设 “$\epsilon\le\hat{\epsilon}$”，则在 $1-\alpha$ 的概率内所能观测到的最大错误率如下：&lt;/p&gt;

\[\overline{\epsilon} = \min\epsilon\qquad s.t.\qquad \sum_{i=\epsilon_0\times m+1}^{m}
\left(
\begin{array}{c}
  m\\
  i
\end{array}
\right)\epsilon^i(1-\epsilon)^{m-i}\alpha\]

&lt;p&gt;其中 $1-\alpha$ 反映了结论的“置信度” (confidence)。&lt;/p&gt;

&lt;p&gt;此时若测试错误率 $\hat{\epsilon}$ 小于临界值 $\overline{\epsilon}$，则根据二项检验可得出结论：在 $\alpha$ 的显著度下，假设 “$\epsilon\le\epsilon_0$” 不能被拒绝，即能以 $1-\alpha$ 的置信度认为，学习器的泛化错误率不大于 $\epsilon_0$；否则该假设可被拒绝，即在 $\alpha$ 的显著度下可认为学习器的泛化错误率大于 $\epsilon_0$。&lt;/p&gt;

&lt;p&gt;在很多时候我们并非仅做一次留出法估计，而是通过多次重复留出法或是交叉验证法等进行多次训练 / 测试，这样会得到多个测试错误率，此时可使用 “t-检验” (t-testr)。假定我们得到了 $k$ 个测试错误率，$\hat{\epsilon}_1$，$\hat{\epsilon}_2$，…，$\hat{\epsilon}_k$，则平均测试错误率 $\mu$ 和方差 $\sigma^2$ 为&lt;/p&gt;

\[\mu = \frac{1}{k}\sum_{i=1}^{k}\hat{\epsilon}_i\\
\sigma^2 = \frac{1}{k-1}\sum_{i=1}^{k}(\hat{\epsilon_i}-\mu)^2\]

&lt;p&gt;可以考虑到这 $k$ 个测试错误率可看作泛化错误率 $\epsilon_0$ 的独立采样，则变量&lt;/p&gt;

\[\tau_t = \frac{\sqrt{k}(\mu-\epsilon_0)}{\sigma}\]

&lt;p&gt;服从自由度为 $k-1$ 的 $t$ 分布。&lt;/p&gt;

&lt;h3 id=&quot;交叉验证-t-检验&quot;&gt;交叉验证 t 检验&lt;/h3&gt;

&lt;p&gt;对两个学习器 $A$ 和 $B$,若我们使用 $k$ 折交叉验证法得到的错误率分别为 $\epsilon_1^A,\epsilon_2^A,…,\epsilon_k^A$ 和 $\epsilon_1^B,\epsilon_2^B,…,\epsilon_k^B$。可用 $k$ 折交叉验证“成对 t 检验” (paired-tests) 来进行比较检验。这里的基本思想是若两个学习器的性能相同，则它们使用相同训练 / 测试集得到的测试错误率应相同，即 $\epsilon_i^A=\epsilon_i^B$。&lt;/p&gt;

&lt;p&gt;具体的来说，对 $k$ 折交叉验证所产生的 $k$ 对测试错误率：先对每对结果求差，$\delta_i=\epsilon_i^A-\epsilon_i^B$；若两个学习器性能相同，则差值均值应为 0.因此，可根据差值 $\delta_1,\delta_2,…,\delta_k$ 来对“学习器 $A$ 与 $B$ 性能相同”这个假设做 $t$ 检验，计算出差值的均值 $\mu$ 和方差 $\sigma^2$，在显著度 $\alpha$ 下，若变量&lt;/p&gt;

&lt;h3 id=&quot;mcnemar-检验&quot;&gt;McNemar 检验&lt;/h3&gt;

&lt;h3 id=&quot;friedman-检验与-nemenyi-后续检验&quot;&gt;Friedman 检验与 Nemenyi 后续检验&lt;/h3&gt;

&lt;h2 id=&quot;偏差与方差&quot;&gt;偏差与方差&lt;/h2&gt;

&lt;h1 id=&quot;线性模型&quot;&gt;线性模型&lt;/h1&gt;</content><author><name>ericaaaaaaaa</name></author><category term="MachineLearning" /><category term="book-report" /><category term="artificial-intelligence" /><category term="machine-learning" /><summary type="html">概念</summary></entry><entry><title type="html">Machine Learning</title><link href="http://localhost:4000/artificialintelligence/2022/01/28/MachineLearning.html" rel="alternate" type="text/html" title="Machine Learning" /><published>2022-01-28T00:00:00+08:00</published><updated>2022-01-28T00:00:00+08:00</updated><id>http://localhost:4000/artificialintelligence/2022/01/28/MachineLearning</id><content type="html" xml:base="http://localhost:4000/artificialintelligence/2022/01/28/MachineLearning.html">&lt;center&gt;&lt;h1&gt;Machine Learning&lt;/h1&gt;&lt;/center&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tutor: $\mathscr{Andrew Ng}$&lt;/p&gt;

  &lt;p&gt;Author of the notebook: $\mathscr{ericaaaaaaaa}$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div style=&quot;background-color: #D6EAF8;&quot;&gt;&lt;b&gt;&lt;h4&gt;Machine Learning&lt;/h4&gt;&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;A computer program is said to &lt;i&gt;learn&lt;/i&gt; from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.&lt;/div&gt;
&lt;div&gt;Category&lt;ul&gt;&lt;li&gt;Supervised Learning&lt;/li&gt;&lt;li&gt;Unsupervised Learning&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;

&lt;div style=&quot;background-color: #D6EAF8;&quot;&gt;&lt;b&gt;&lt;h4&gt;Supervised Learning&lt;/h4&gt;&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;&quot;right answers&quot; given&lt;/div&gt;

&lt;div style=&quot;background-color: #D6EAF8;&quot;&gt;&lt;b&gt;&lt;h4&gt;Regression Problem&lt;/h4&gt;&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;Predict &lt;b&gt;continuous&lt;/b&gt; valued output.&lt;/div&gt;

&lt;div style=&quot;background-color: #D6EAF8;&quot;&gt;&lt;b&gt;&lt;h4&gt;Classification Problem&lt;/h4&gt;&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;Predict &lt;b&gt;discrete&lt;/b&gt; valued output.&lt;/div&gt;

&lt;div style=&quot;background-color: #D6EAF8;&quot;&gt;&lt;b&gt;&lt;h4&gt;Unsupervised Learning&lt;/h4&gt;&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;no &quot;right answers&quot; given&lt;/div&gt;</content><author><name>ericaaaaaaaa</name></author><category term="ArtificialIntelligence" /><category term="note" /><category term="machine-learning" /><category term="artificial-intelligence" /><summary type="html">Machine Learning</summary></entry><entry><title type="html">Algorithm</title><link href="http://localhost:4000/algorithms/2022/01/11/Algorithm.html" rel="alternate" type="text/html" title="Algorithm" /><published>2022-01-11T00:00:00+08:00</published><updated>2022-01-11T00:00:00+08:00</updated><id>http://localhost:4000/algorithms/2022/01/11/Algorithm</id><content type="html" xml:base="http://localhost:4000/algorithms/2022/01/11/Algorithm.html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;h2 id=&quot;definition&quot;&gt;Definition&lt;/h2&gt;

&lt;h3 id=&quot;problem-instance&quot;&gt;Problem Instance&lt;/h3&gt;

&lt;p&gt;A problem instance is any valid input to the problem.&lt;/p&gt;

&lt;h3 id=&quot;algorithm&quot;&gt;Algorithm&lt;/h3&gt;

&lt;p&gt;An &lt;strong&gt;algorithm&lt;/strong&gt; is a well defined &lt;strong&gt;computational procedure&lt;/strong&gt; that transforms inputs into outputs, achieving the desired input-output relationship.&lt;/p&gt;

&lt;h3 id=&quot;correct-algorithm&quot;&gt;Correct Algorithm&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;correct algorithm&lt;/strong&gt; &lt;strong&gt;halts&lt;/strong&gt; with the correct output for every input instance. We can then say that the algorithm &lt;strong&gt;solves&lt;/strong&gt; the problem.&lt;/p&gt;

&lt;h2 id=&quot;analyzing-algorithms&quot;&gt;Analyzing Algorithms&lt;/h2&gt;

&lt;h4 id=&quot;predict-resource-utilization&quot;&gt;Predict Resource Utilization&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Memory&lt;/strong&gt; (space complexity)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Running time&lt;/strong&gt; (time complexity)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;depends on the speed of the computer&lt;/li&gt;
      &lt;li&gt;depends on the implementation details&lt;/li&gt;
      &lt;li&gt;depends on the input, especially on the size of the input&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Measure the running time as the number of &lt;strong&gt;primitive operations&lt;/strong&gt; used by the algorithm. (mathematically elegant and machine-independent)&lt;/p&gt;

    &lt;p&gt;Measure the running time as &lt;strong&gt;a function of the input size&lt;/strong&gt;. Let &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; denote the input size and let &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T(n)&lt;/code&gt; denote the running time for input of size n.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;three-kinds-of-analysis&quot;&gt;Three Kinds of Analysis&lt;/h3&gt;

&lt;h4 id=&quot;worst-case&quot;&gt;Worst Case&lt;/h4&gt;

&lt;p&gt;Commonly used&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Running time guarantee&lt;/li&gt;
  &lt;li&gt;Fair comparison&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;average-case&quot;&gt;Average Case&lt;/h4&gt;

&lt;p&gt;Used sometimes&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Need to assume distribution&lt;/li&gt;
  &lt;li&gt;Analysis is complicated&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;best-case&quot;&gt;Best Case&lt;/h4&gt;

&lt;p&gt;useless&lt;/p&gt;

&lt;h3 id=&quot;comparing-time-complexity&quot;&gt;Comparing Time Complexity&lt;/h3&gt;

&lt;h4 id=&quot;o-notation-upper-bounds&quot;&gt;$O$-notation (Upper bounds)&lt;/h4&gt;

&lt;p&gt;$f(n)=O(g(n))$: There exists constant $c&amp;gt;0$ and $n_0$ such that $f(n)\le c\cdot g(n)$ for $n\ge n_0$&lt;/p&gt;

&lt;h4 id=&quot;omega-notation-lower-bounds&quot;&gt;$\Omega$-notation (Lower bounds)&lt;/h4&gt;

&lt;p&gt;$f(n)=\Omega(g(n))$: There exists constant $c&amp;gt;0$ and $n_0$ such that $f(n)\ge c\cdot g(n)$ for $n\ge n_0$&lt;/p&gt;

&lt;h4 id=&quot;theta-notation-tight-bounds&quot;&gt;$\Theta$-notation (Tight bounds)&lt;/h4&gt;

&lt;p&gt;$f(n)=\Theta(g(n))$: $f(n)=O(g(n))$ and $f(n)=\Omega(g(n))$&lt;/p&gt;

&lt;h4 id=&quot;examples&quot;&gt;Examples&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;$\sum_{i=1}^{n}i = \frac{n(n+1)}{2}$&lt;/li&gt;
  &lt;li&gt;$\sum_{i=1}^{n}i^2 = \frac{n(n+1)(2n+1)}{6}$&lt;/li&gt;
  &lt;li&gt;$\sum_{i=1}^{n}\frac{1}{n}=O(\log n)$ (Harmonic Series，调和级数)&lt;/li&gt;
  &lt;li&gt;$\log(n!)=\log(n) + \log(n-1) + …+\log(1)=O(n\log n)$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;递归分析主定理法&quot;&gt;递归分析：主定理法&lt;/h3&gt;

\[T(n) = 
\left\{
\begin{array}{l}
\Theta(f(n)) &amp;amp; if\ f(n)=\Omega(n^{\log_ba+\varepsilon})\\
\Theta(n^{\log_ba}\log n) &amp;amp; if\ f(n)=\Theta(n^{\log_b a}) \\
\Theta(n^{\log_ba}) &amp;amp; if\ f(n)=O(n^{\log_ba-\varepsilon})
\end{array}
\right.\]

&lt;h1 id=&quot;divide-and-conquer-algorithms&quot;&gt;Divide and Conquer Algorithms&lt;/h1&gt;

&lt;h2 id=&quot;step&quot;&gt;Step&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;分而治之&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;分解&lt;/strong&gt;原问题&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;解决&lt;/strong&gt;子问题&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;合并&lt;/strong&gt;问题解&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;merge-sort-归并排序&quot;&gt;Merge Sort 归并排序&lt;/h2&gt;

&lt;p&gt;归并排序：分解数组，递归求解，合并排序&lt;/p&gt;

&lt;h3 id=&quot;算法流程&quot;&gt;算法流程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;将数组 A[1, n] 排序问题&lt;strong&gt;分解&lt;/strong&gt;为 A[1, [n/2]] 和 A[[n/2]+1, n] 排序问题&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;递归解决&lt;/strong&gt;子问题得到两个有序的子数组&lt;/li&gt;
  &lt;li&gt;将两个有序子数组&lt;strong&gt;合并&lt;/strong&gt;为一个有序数组&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;伪代码&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/merge_sort.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/merge.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;复杂度分析&quot;&gt;复杂度分析&lt;/h3&gt;

&lt;p&gt;$T(n) = O(n\log n)$&lt;/p&gt;

&lt;h2 id=&quot;maximum-contiguous-subarray-problem-最大子数组&quot;&gt;Maximum Contiguous Subarray Problem 最大子数组&lt;/h2&gt;

&lt;h3 id=&quot;伪代码-1&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/MCS.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/find_max.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;复杂度&quot;&gt;复杂度&lt;/h3&gt;

&lt;p&gt;$f(n)=O(n\log n)$&lt;/p&gt;

&lt;h2 id=&quot;counting-inversions-逆序计数&quot;&gt;Counting Inversions 逆序计数&lt;/h2&gt;

&lt;h3 id=&quot;问题介绍&quot;&gt;问题介绍&lt;/h3&gt;

&lt;p&gt;The total number of inversions in $\sum_{1\le i\le j\le n}$, namely
\(X_{i, j} = 
\left\{
\begin{array}{rcl}
1 &amp;amp; A[i]&amp;gt;A[j]\\
0 &amp;amp; A[i]\le A[j]
\end{array}
\right.\)&lt;/p&gt;

&lt;h3 id=&quot;伪代码-2&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/merge_count.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/sort_count.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;复杂度-1&quot;&gt;复杂度&lt;/h3&gt;

&lt;p&gt;$T(n)=n\log n$&lt;/p&gt;

&lt;h2 id=&quot;polynomial-multiplication-多项式乘法&quot;&gt;Polynomial Multiplication 多项式乘法&lt;/h2&gt;

&lt;h3 id=&quot;description&quot;&gt;Description&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/def.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Input&lt;/strong&gt;: Assume that the coefficients a$_i$ and b$_i$ are stored in arrays A[0…n] and B[0…m]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;伪代码-3&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/poly_mult1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/poly_mult2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;quicksort-and-partition-快速排序与划分&quot;&gt;QuickSort and Partition 快速排序与划分&lt;/h2&gt;

&lt;h3 id=&quot;算法思路&quot;&gt;算法思路&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;选取固定位置主元 x （如尾元素）&lt;/li&gt;
  &lt;li&gt;维护两个部分的右端点变量 i, j&lt;/li&gt;
  &lt;li&gt;考察数组 A[j]，只和主元比较
    &lt;ul&gt;
      &lt;li&gt;若 A[j] ≤ x，则交换 A[j] 和 A[i+1]，i, j 右移&lt;/li&gt;
      &lt;li&gt;若 A[j] &amp;gt; x，则 j 右移&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;把主元放在中间作分界线&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/t.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/p.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;伪代码-4&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/partition.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/quick_sort.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;复杂度-2&quot;&gt;复杂度&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;最好情况：$O(n\log n)$&lt;/li&gt;
  &lt;li&gt;最坏情况：$O(n^2)$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;优化随机选择主元&quot;&gt;优化——随机选择主元&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/random_partition.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;期望时间复杂度&quot;&gt;期望时间复杂度&lt;/h4&gt;

&lt;p&gt;$O(n\log n)$&lt;/p&gt;

&lt;h2 id=&quot;randomized-selection-随机化选择&quot;&gt;Randomized Selection 随机化选择&lt;/h2&gt;

&lt;h3 id=&quot;次序选择问题&quot;&gt;次序选择问题&lt;/h3&gt;

&lt;h4 id=&quot;形式化定义&quot;&gt;形式化定义&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/k_min.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;算法思想&quot;&gt;算法思想&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;选取固定位置主元，小于主元的元素个数 q-p
    &lt;ul&gt;
      &lt;li&gt;情况 1：k = q - p + 1，A[q] 为数组第 k 小元素&lt;/li&gt;
      &lt;li&gt;情况 2：k &amp;lt; q - p + 1，在 A[p .. q - 1] 中寻找第 k 小元素&lt;/li&gt;
      &lt;li&gt;情况 3：k &amp;gt; q - p + 1，在 A[q + 1 .. r] 中寻找第 k - (q - p + 1) 小元素&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;伪代码-5&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/partition.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/selection.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;复杂度-3&quot;&gt;复杂度&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;最好情况：$T(n) = O(n)$&lt;/li&gt;
  &lt;li&gt;最差情况：$T(n) = O(n^2)$&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;优化算法随机选择主元&quot;&gt;优化算法——随机选择主元&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/rp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/rs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;期望时间复杂度：$O(n)$&lt;/p&gt;

&lt;h2 id=&quot;supplement-topic-of-sorting-排序问题补充主题&quot;&gt;Supplement Topic of Sorting 排序问题补充主题&lt;/h2&gt;

&lt;h3 id=&quot;heapsort-堆排序&quot;&gt;Heapsort 堆排序&lt;/h3&gt;

&lt;h4 id=&quot;heap&quot;&gt;Heap&lt;/h4&gt;

&lt;h5 id=&quot;definition-1&quot;&gt;Definition&lt;/h5&gt;

&lt;p&gt;Heaps are “almost complete binary trees”&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;All levels are full except possibly the lowest level&lt;/li&gt;
  &lt;li&gt;If the lowest level is not full, then nodes must packed to the left&lt;/li&gt;
  &lt;li&gt;The values of the node is at least the value of its parent. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A[Parent(i)] &amp;lt;= A[i]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;operation&quot;&gt;Operation&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Insert&lt;/strong&gt; in $O(\log n)$ time&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Extract-Min&lt;/strong&gt; in $O(\log n)$ time&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;properties&quot;&gt;Properties&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;A heap of height h has between $2^h$ to $2^{h+1}-1$ nodes. Thus, an n-element heap has height $\Theta(\log n)$&lt;/li&gt;
  &lt;li&gt;The structure is so regular, it can be represented in an array and no links are necessary&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;array-implementation-of-heap&quot;&gt;Array Implementation of Heap&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;The root is in array position 1&lt;/li&gt;
  &lt;li&gt;For any element in array position i
    &lt;ul&gt;
      &lt;li&gt;The left child is in position 2i&lt;/li&gt;
      &lt;li&gt;The right child is in position 2i+1&lt;/li&gt;
      &lt;li&gt;The parent is in position [i/2]&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;heapsort&quot;&gt;Heapsort&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Build a binary heap of n elements
    &lt;ul&gt;
      &lt;li&gt;the minimum element is at the top of the heap&lt;/li&gt;
      &lt;li&gt;insert n elements one by one&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Perform n Extract-Min operations
    &lt;ul&gt;
      &lt;li&gt;the elements are extracted in sorted order&lt;/li&gt;
      &lt;li&gt;each Extract-Min operation takes $O(\log n)$ time&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Total time complexity: $O(n\log n)$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lower-bound-for-sorting-基于比较的排序下界&quot;&gt;Lower Bound for Sorting 基于比较的排序下界&lt;/h3&gt;

&lt;p&gt;Any comparison-based sorting algorithm requires $\Omega(n\log n)$ comparisons.&lt;/p&gt;

&lt;h4 id=&quot;counting-sort&quot;&gt;Counting-Sort&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/counting_sort.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;sorting-in-linear-time-线性时间排序&quot;&gt;Sorting in Linear Time 线性时间排序&lt;/h3&gt;

&lt;h1 id=&quot;dynamic-programming-algorithms&quot;&gt;Dynamic Programming Algorithms&lt;/h1&gt;

&lt;h3 id=&quot;动态规划算法&quot;&gt;动态规划算法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;问题结构分析&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;给出问题表示，明确原始问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;递推关系建立&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;分析最优结构，构造递推公式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;自底向上计算&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;确定计算顺序，依次求解问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;最优方案追踪&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;记录决策过程，输出最优方案&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0-1-knapsack-0-1-背包问题&quot;&gt;0-1 Knapsack 0-1 背包问题&lt;/h3&gt;

&lt;h4 id=&quot;输入&quot;&gt;输入&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;n 个商品组成集合 0，每个商品有两个属性 $v_i$ 和 $p_i$，分别表示体积和价格&lt;/li&gt;
  &lt;li&gt;背包容量为 $C$&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;输出&quot;&gt;输出&lt;/h4&gt;

&lt;p&gt;求解一个商品子集 $S\subseteq 0$，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;优化目标&lt;/strong&gt;：令 $\max \sum_{i\in S}p_i$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;约束条件&lt;/strong&gt;：$\sum_{i\in S}v_i\le C$&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;递归函数&quot;&gt;递归函数&lt;/h4&gt;

\[KnapsackSR(h, i, c)=\\ \max\{KnapsackSR(h, i-1, c-v_i)+p_i, KnapsackSR(h, i-1, c)\}\]

&lt;h4 id=&quot;算法复杂度&quot;&gt;算法复杂度&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/0-1knap.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;计算顺序&quot;&gt;计算顺序&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/seq.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/rec.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;伪代码-6&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/knap.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/knapdp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/knapdp1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;p&gt;$O(n\cdot C)$&lt;/p&gt;

&lt;h3 id=&quot;maximum-contiguous-subarray-ii-最大连续数组-ii&quot;&gt;Maximum Contiguous Subarray II 最大连续数组 II&lt;/h3&gt;

&lt;h4 id=&quot;问题定义&quot;&gt;问题定义&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/qq1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;问题结构分析&quot;&gt;问题结构分析&lt;/h4&gt;

&lt;p&gt;$D[i]$：以 $X[i]$ 开头的最大子数组和&lt;/p&gt;

&lt;p&gt;原始问题：$S_{max}=\max_{1\le i\le n}{D[i]}$&lt;/p&gt;

&lt;h4 id=&quot;递推关系建立&quot;&gt;递推关系建立&lt;/h4&gt;

\[D[i] = 
\left\{
\begin{array}{l}
X[i] + D[i+1] &amp;amp; if\ D[i+1] &amp;gt; 0\\
X[i] &amp;amp; if\ D[i+1] \le 0
\end{array}
\right.\]

&lt;p&gt;构造追踪数组 $Rec[1..n]$&lt;/p&gt;

&lt;h4 id=&quot;伪代码-7&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mcsdp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mcsdp1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-1&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;p&gt;$T(n) = O(n)$&lt;/p&gt;

&lt;h3 id=&quot;longest-common-subsequences-最长公共子序列&quot;&gt;Longest Common Subsequences 最长公共子序列&lt;/h3&gt;

&lt;h4 id=&quot;问题描述&quot;&gt;问题描述&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/lcs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;问题表示&quot;&gt;问题表示&lt;/h4&gt;

&lt;p&gt;$C[i, j]$：$X[1..i]$ 和 $Y[1..j]$ 的最长公共子序列长度&lt;/p&gt;

&lt;h4 id=&quot;递推关系建立-1&quot;&gt;递推关系建立&lt;/h4&gt;

\[C[i,j]=
\left\{
\begin{array}{l}
\max\{C[i-1,j], C[i,j-1]\} &amp;amp; x_i\not= y_j\\
C[i-1,j-1]+1 &amp;amp; x_i=y_j
\end{array}
\right.\]

&lt;p&gt;&lt;img src=&quot;/assets/images/post/cls2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/rec1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;伪代码-8&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/lcs1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/lcs2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/plcs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-2&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;p&gt;$O(n\cdot m)$&lt;/p&gt;

&lt;h3 id=&quot;longest-common-substrings-最长公共子串&quot;&gt;Longest Common Substrings 最长公共子串&lt;/h3&gt;

&lt;h4 id=&quot;问题描述-1&quot;&gt;问题描述&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/lss.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;问题表示-1&quot;&gt;问题表示&lt;/h4&gt;

&lt;p&gt;$C[i,j]$：在 $X[1..i]$ 和 $Y[1..j]$ 中，以 $x_i$ 和 $y_j$ 结尾的最长公共子串 $Z[1..l]$ 的长度&lt;/p&gt;

&lt;h4 id=&quot;递推关系建立-2&quot;&gt;递推关系建立&lt;/h4&gt;

\[C[i,j]=
\left\{
\begin{array}{l}
0 &amp;amp; x_i\not=y_j\\
C[i-1,j-1]+1&amp;amp;x_i=y_j
\end{array}
\right.\]

&lt;p&gt;&lt;img src=&quot;/assets/images/post/sll1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;伪代码-9&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/sll2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/sll3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/sll4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-3&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;p&gt;$O(n\cdot m)$&lt;/p&gt;

&lt;h3 id=&quot;minimum-edit-distance-最小编辑距离&quot;&gt;Minimum Edit Distance 最小编辑距离&lt;/h3&gt;

&lt;h4 id=&quot;问题描述-2&quot;&gt;问题描述&lt;/h4&gt;

&lt;p&gt;编辑操作&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;删除&lt;/li&gt;
  &lt;li&gt;插入&lt;/li&gt;
  &lt;li&gt;替换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/med1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;问题表示-2&quot;&gt;问题表示&lt;/h4&gt;

&lt;p&gt;$D[i,j]$：字符串 $s[1..i]$ 变成 $t[1..j]$ 的最小编辑距离
\(D[i,j]=\min
\left\{
\begin{array}{l}
D[i-1,j]+1 &amp;amp; 删除\\
D[i,j-1]+1 &amp;amp; 插入\\
D[i-1,j-1]+
\left\{
\begin{array}{l}
0 &amp;amp; if\ s[i] = t[j]\\
1 &amp;amp; if\ s[i]\not= t[j]
\end{array}
\right.
\end{array}
\right.\)&lt;/p&gt;

&lt;h4 id=&quot;递推关系建立-3&quot;&gt;递推关系建立&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/med2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;伪代码-10&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/med3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/med4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/med5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-4&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;p&gt;$O(mn)$&lt;/p&gt;

&lt;h3 id=&quot;rod-cutting-钢条切割&quot;&gt;Rod-Cutting 钢条切割&lt;/h3&gt;

&lt;h4 id=&quot;问题描述-3&quot;&gt;问题描述&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/rc1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;问题表示-3&quot;&gt;问题表示&lt;/h4&gt;

&lt;p&gt;$C[j]$：切割长度为 $j$ 的钢条可获得的最大收益&lt;/p&gt;

&lt;p&gt;$rec[j]$：记录长度为 $j$ 钢条的最优切割方案&lt;/p&gt;

&lt;h4 id=&quot;递归结构建立&quot;&gt;递归结构建立&lt;/h4&gt;

\[C[j] = \max_{1\le i\le j-1}\{p[i] + C[j-i],p[j]\}\]

&lt;h4 id=&quot;伪代码-11&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/rc2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/rc3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;算法复杂度-1&quot;&gt;算法复杂度&lt;/h4&gt;

&lt;p&gt;$O(n^2)$&lt;/p&gt;

&lt;h3 id=&quot;chain-matrix-multiplication-矩阵链乘法&quot;&gt;Chain Matrix Multiplication 矩阵链乘法&lt;/h3&gt;

&lt;h4 id=&quot;问题定义-1&quot;&gt;问题定义&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mm1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;问题描述-4&quot;&gt;问题描述&lt;/h4&gt;

&lt;p&gt;$D[i,j]$：计算矩阵链 $U_{i..j}$ 所需标量乘法的&lt;strong&gt;最小次数&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;递归表达式建立&quot;&gt;递归表达式建立&lt;/h4&gt;

\[D[i,j]=\min_{1\le k&amp;lt;j}(D[i,k]+D[k+1,j+p_{i-1}p_kp_j])\]

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mm2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mm3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/m4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;伪代码-12&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mm4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mm5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mm6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-5&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;p&gt;$O(n^3)$&lt;/p&gt;

&lt;h1 id=&quot;greedy-algorithms&quot;&gt;Greedy Algorithms&lt;/h1&gt;

&lt;h2 id=&quot;算法描述&quot;&gt;算法描述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;提出贪心策略&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;观察问题特征，构造贪心选择&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;证明策略正确&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;假设最优方案，通过替换证明&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fractional-knapsack-部分背包问题&quot;&gt;Fractional Knapsack 部分背包问题&lt;/h2&gt;

&lt;h3 id=&quot;问题定义-2&quot;&gt;问题定义&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/fkp1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;问题描述-5&quot;&gt;问题描述&lt;/h3&gt;

&lt;h3 id=&quot;伪代码-13&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/fkp2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;算法复杂度-2&quot;&gt;算法复杂度&lt;/h3&gt;

&lt;p&gt;$O(n\log n)$&lt;/p&gt;

&lt;h2 id=&quot;huffman-coding-problem-赫夫曼编码&quot;&gt;Huffman Coding Problem 赫夫曼编码&lt;/h2&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;编码树&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;顶点到左结点的边标记为 0，到右节点的边标记 1，通过编码方案构造编码树&lt;/li&gt;
      &lt;li&gt;每条根到叶子的路径对应的每个字符的二进制串&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;问题定义-3&quot;&gt;问题定义&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/hc1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;伪代码-14&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/hc2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;算法复杂度-3&quot;&gt;算法复杂度&lt;/h3&gt;

&lt;p&gt;$O(n\log n)$&lt;/p&gt;

&lt;h2 id=&quot;activity-selection-problem-活动选择问题&quot;&gt;Activity Selection Problem 活动选择问题&lt;/h2&gt;

&lt;h3 id=&quot;无权重&quot;&gt;无权重&lt;/h3&gt;

&lt;h4 id=&quot;问题定义-4&quot;&gt;问题定义&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/asp1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;算法思路-1&quot;&gt;算法思路&lt;/h4&gt;

&lt;p&gt;选择最早结束的活动，可以给后面的活动留更大的空间。&lt;/p&gt;

&lt;h4 id=&quot;伪代码-15&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/asp2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;算法复杂度-4&quot;&gt;算法复杂度&lt;/h4&gt;

&lt;p&gt;$O(n\log n)$&lt;/p&gt;

&lt;h3 id=&quot;有权重&quot;&gt;有权重&lt;/h3&gt;

&lt;h4 id=&quot;问题定义-5&quot;&gt;问题定义&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/asp3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;问题分析&quot;&gt;问题分析&lt;/h4&gt;

&lt;p&gt;$D[i]$：集合 ${a_1,a_2,a_3,…,a_i}$ 中不冲突活动的最大权限和&lt;/p&gt;

&lt;h4 id=&quot;递推关系建立-4&quot;&gt;递推关系建立&lt;/h4&gt;

\[D[i] = \max\{D[p[i]]+w_i,D[i-1] \}\\
Rec[i] = 
\left\{
\begin{array}{l}
1 &amp;amp; 选择活动 a_i\\
0 &amp;amp; 不选活动 a_i
\end{array}
\right.\]

&lt;p&gt;&lt;img src=&quot;/assets/images/post/asp4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;伪代码-16&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/asp5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/asp6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/asp7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;算法复杂度-5&quot;&gt;算法复杂度&lt;/h4&gt;

&lt;p&gt;$O(n\log n)$&lt;/p&gt;

&lt;h1 id=&quot;graph-algorithms&quot;&gt;Graph Algorithms&lt;/h1&gt;

&lt;h2 id=&quot;basic-concepts-in-graphs&quot;&gt;Basic Concepts in Graphs&lt;/h2&gt;

&lt;h3 id=&quot;图的概念&quot;&gt;图的概念&lt;/h3&gt;

&lt;h4 id=&quot;图的定义&quot;&gt;图的定义&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;图&lt;/strong&gt;可以表示为一个二元组 $G=&amp;lt;V, E&amp;gt;$，其中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$V$ 表示非空顶点集，其元素称为顶点 (Vertex)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$E$ 表示边集，其元素称为边 (Edge)&lt;/p&gt;

    &lt;p&gt;$e=(u,v)$ 表示一条边，其中 $u\in V,v\in V,e\in E$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;相邻和关联&quot;&gt;相邻和关联&lt;/h4&gt;

&lt;h5 id=&quot;相邻-adjacent&quot;&gt;相邻 (Adjacent)&lt;/h5&gt;

&lt;p&gt;边 $(u,v)$ 连接的顶点 $u$ 和 $v$ &lt;strong&gt;相邻&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;关联-incident&quot;&gt;关联 (Incident)&lt;/h5&gt;

&lt;p&gt;边 $(u,v)$ 和其连接的顶点 $u$ (或 $v$) 相互关联&lt;/p&gt;

&lt;h4 id=&quot;度&quot;&gt;度&lt;/h4&gt;

&lt;h5 id=&quot;顶点的度-degree-of-a-vertex&quot;&gt;顶点的度 (Degree of a Vertex)&lt;/h5&gt;

&lt;p&gt;顶点 $v$ 的度 $deg(v)$ 是 $v$ 关联的边数&lt;/p&gt;

&lt;h5 id=&quot;图的度-degree-of-a-graph&quot;&gt;图的度 (Degree of a Graph)&lt;/h5&gt;

&lt;p&gt;图 $G=&amp;lt;V,E&amp;gt;$ 的度，是图各顶点的度之和，$deg(G)=\sum_{v\in V}deg(v)$&lt;/p&gt;

&lt;h4 id=&quot;握手定理-handshaking-lemma&quot;&gt;握手定理 (Handshaking Lemma)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;无向图的度是边数的两倍&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;路径-path&quot;&gt;路径 (Path)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;图中一个顶点序列 $&amp;lt;v_0,v_1,…,v_k&amp;gt;$ 称为 $v_0$ 到 $v_k$ 的&lt;strong&gt;路径&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;路径包含顶点 $v_0,v_1,…,v_k$ 和边 $(v_0,v_1),(v_1,v_2),…,(v_{k-1}, v_k)$&lt;/li&gt;
  &lt;li&gt;存在路径 $&amp;lt;v_0,v_1,…,v_k&amp;gt;$，则 $v_0$ &lt;strong&gt;可达&lt;/strong&gt; $v_k$&lt;/li&gt;
  &lt;li&gt;如果 $v_0,v_1,…,v_k$ 互不相同，则该路径的&lt;strong&gt;简单&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;环路-cycle&quot;&gt;环路 (Cycle)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;如果路径 $&amp;lt;v_0,v_1,…,v_k&amp;gt;$ 中 $v_0=v_k$ 且至少包含一条边，则该路径构成&lt;strong&gt;环路&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;如果 $v_0,v_1,…,v_k$ 互不相同，则该环路的&lt;strong&gt;简单&lt;/strong&gt;的&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;无环图&lt;/strong&gt; (Acyclic Graph)：图中不存在环路&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;连通-connectivity&quot;&gt;连通 (Connectivity)&lt;/h4&gt;

&lt;h5 id=&quot;连通&quot;&gt;连通&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;如果图的&lt;strong&gt;任意对顶点互相可达&lt;/strong&gt;，则称该图是&lt;strong&gt;连通&lt;/strong&gt;的，反之称为&lt;strong&gt;非连通&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;连通分量-connected-components&quot;&gt;连通分量 (Connected Components)&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;根据是否连通将顶点进行分组，相互可达的顶点集称为&lt;strong&gt;连通分量&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;子图-subgraph&quot;&gt;子图 (Subgraph)&lt;/h4&gt;

&lt;h5 id=&quot;子图-subgraph-1&quot;&gt;子图 (Subgraph)&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;如果 $V’\subseteq V,E’\subseteq E$，则称图 $G’=&amp;lt;V’,E’&amp;gt;$ 是图 $G$ 的一个&lt;strong&gt;子图&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;生成子图-spanning-subgraph&quot;&gt;生成子图 (Spanning Subgraph)&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;如果 $V’=V, E\subseteq E$，则称图 $G’=&amp;lt;V’, E’&amp;gt;$ 是图 $G$ 的一个&lt;strong&gt;生成子图&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;树-tree&quot;&gt;树 Tree&lt;/h4&gt;

&lt;h5 id=&quot;树-tree-1&quot;&gt;树 (Tree)&lt;/h5&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;连通、无环图 $T=&amp;lt;V_T,E_T&amp;gt;$，树有 $&lt;/td&gt;
      &lt;td&gt;V_T&lt;/td&gt;
      &lt;td&gt;-1$ 条边&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;森林-forest&quot;&gt;森林 (Forest)&lt;/h5&gt;

&lt;p&gt;一至多棵树组成的无环图&lt;/p&gt;

&lt;h3 id=&quot;图的表示&quot;&gt;图的表示&lt;/h3&gt;

&lt;h4 id=&quot;邻接链表&quot;&gt;邻接链表&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;图 $G=&amp;lt;V,E&amp;gt;$，其邻接链表由 $&lt;/td&gt;
          &lt;td&gt;V&lt;/td&gt;
          &lt;td&gt;$ 条链表的数组构成&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;每个顶点有一条链表，包含所有与其相邻的顶点&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;空间大小 $O(&lt;/td&gt;
          &lt;td&gt;V&lt;/td&gt;
          &lt;td&gt;+&lt;/td&gt;
          &lt;td&gt;E&lt;/td&gt;
          &lt;td&gt;)$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;邻接矩阵&quot;&gt;邻接矩阵&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;图 $G=&amp;lt;V,E&amp;gt;$ 的邻接矩阵由 $|V|\times |V|$ 的二维数组 $A$ 构成，满足
\(A_{ij}=
\left\{
\begin{array}{l}
1 &amp;amp; (i,j)\in E\\
0 &amp;amp; (i,j)\not\in E
\end{array}
\right.\)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;空间大小 $O(&lt;/td&gt;
          &lt;td&gt;V&lt;/td&gt;
          &lt;td&gt;^2)$，$O(1)$ 判断是否有边&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;breadth-first-search-bfs广度优先搜索&quot;&gt;Breadth-First Search (BFS，广度优先搜索)&lt;/h2&gt;

&lt;h3 id=&quot;辅助数组&quot;&gt;辅助数组&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/bfs1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;伪代码-17&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/bfs2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/bfs3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;时间复杂度-6&quot;&gt;时间复杂度&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;depth-first-search-dfs深度优先搜索&quot;&gt;Depth-First Search (DFS，深度优先搜索)&lt;/h2&gt;

&lt;h3 id=&quot;问题分析-1&quot;&gt;问题分析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/dfs1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;伪代码-18&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/dfs2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/dfs3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;时间复杂度分析&quot;&gt;时间复杂度分析&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;深度优先树&quot;&gt;深度优先树&lt;/h3&gt;

&lt;h4 id=&quot;深度优先树-1&quot;&gt;深度优先树&lt;/h4&gt;

&lt;p&gt;顶点以前驱为祖先形成的树&lt;/p&gt;

&lt;h4 id=&quot;树边&quot;&gt;树边&lt;/h4&gt;

&lt;p&gt;深度优先搜索树中的边&lt;/p&gt;

&lt;h4 id=&quot;后向边&quot;&gt;后向边&lt;/h4&gt;

&lt;p&gt;不是树边，但两顶点在深度优先树中是祖先后代关系&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于无向图，非树边一定是后向边。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;括号化定理&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;点 $v$ 发现时刻和结束时刻构成区间 $[d[v], f[v]]$&lt;/li&gt;
  &lt;li&gt;任意两点 $v,w$ 必须满足以下情况之一：
    &lt;ul&gt;
      &lt;li&gt;$[d[v],f[v]]$ 包含 $[d[w], f[w]]$，$w$ 是 $v$ 的后代&lt;/li&gt;
      &lt;li&gt;$[d[w],f[w]]$ 包含 $[d[v],f[v]]$，$v$ 是 $w$ 的后代&lt;/li&gt;
      &lt;li&gt;$[d[v],f[v]]$ 和 $[d[w],f[w]]$ 完全不重合 $v$ 和 $w$ 均不是对方的后代&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;白色路径定理&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在深度优先树中，顶点 $v$ 是 $w$ 的祖先 $\Leftrightarrow$ 在 $v$ 被发现前，从 $v$ 到 $w$ 存在全为白色顶点构成的路径&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;前向边&quot;&gt;前向边&lt;/h4&gt;

&lt;p&gt;不再深度优先树种，从祖先指向后代的边&lt;/p&gt;

&lt;h4 id=&quot;横向边&quot;&gt;横向边&lt;/h4&gt;

&lt;p&gt;顶点不具有祖先后代关系的边&lt;/p&gt;

&lt;h2 id=&quot;cycle-detection-环路检测&quot;&gt;Cycle Detection (环路检测)&lt;/h2&gt;

&lt;h3 id=&quot;问题定义-6&quot;&gt;问题定义&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/cd1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;伪代码-19&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/cd2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/cd3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;时间复杂度-7&quot;&gt;时间复杂度&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;topological-sort-拓扑排序&quot;&gt;Topological Sort (拓扑排序)&lt;/h2&gt;

&lt;h3 id=&quot;问题定义-7&quot;&gt;问题定义&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/tp1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;广度优先策略&quot;&gt;广度优先策略&lt;/h3&gt;

&lt;h4 id=&quot;算法思想-1&quot;&gt;算法思想&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;完成入度为 0 点对应的事件&lt;/li&gt;
  &lt;li&gt;删除完成事件，产生新的入度为 0 的点，继续完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;伪代码-20&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/tp2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;事件复杂度&quot;&gt;事件复杂度&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;深度优先策略&quot;&gt;深度优先策略&lt;/h3&gt;

&lt;h4 id=&quot;算法思想-2&quot;&gt;算法思想&lt;/h4&gt;

&lt;p&gt;DFS 搜索的完成时刻逆序即为拓扑排序顺序&lt;/p&gt;

&lt;h4 id=&quot;算法伪代码&quot;&gt;算法伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/tp3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/tp4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;算法时间复杂度&quot;&gt;算法时间复杂度&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;strongly-connected-components-强连通分量&quot;&gt;Strongly Connected Components (强连通分量)&lt;/h2&gt;

&lt;h3 id=&quot;问题定义-8&quot;&gt;问题定义&lt;/h3&gt;

&lt;h4 id=&quot;强连通分量&quot;&gt;强连通分量&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;一个强连通分量是顶点的子集&lt;/li&gt;
  &lt;li&gt;强连通分量种&lt;strong&gt;任意两点相互可达&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;满足&lt;strong&gt;最大性&lt;/strong&gt;：加入新顶点，不保证相互可达&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/scc1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;gscc&quot;&gt;$G^{SCC}$&lt;/h4&gt;

&lt;p&gt;把强连通分量看作一个点得到的有向图&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;$G^{SCC}$一定是有向无环图&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;scc_sink&quot;&gt;$SCC_{Sink}$&lt;/h4&gt;

&lt;p&gt;$G^{SCC}$ 中出度为 0 的点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$G^{SCC}$ 中存在至少一个 $SCC_{Sink}$&lt;/li&gt;
  &lt;li&gt;删除 $SCC_{Sink}$，会产生新的 $SCC_{Sink}$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;算法步骤&quot;&gt;算法步骤&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;把边反向，得到反向图 $G^R$&lt;/li&gt;
  &lt;li&gt;在 $G^R$ 上执行 DFS，得到顶点完成时刻顺序 $L$&lt;/li&gt;
  &lt;li&gt;在 $G$ 上按 $L$ 逆序执行 DFS，得到强连通分量&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;伪代码-21&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/scc2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/scc3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;时间复杂度-8&quot;&gt;时间复杂度&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;minimum-spanning-trees-最小生成树&quot;&gt;Minimum Spanning Trees (最小生成树)&lt;/h2&gt;

&lt;h3 id=&quot;问题背景&quot;&gt;问题背景&lt;/h3&gt;

&lt;h4 id=&quot;子图-subgraph-2&quot;&gt;子图 Subgraph&lt;/h4&gt;

&lt;p&gt;如果 $V’\subseteq V$，$E’\subseteq E$，则称图 $G’=&amp;lt;V’,E’&amp;gt;$ 是图 $G$ 的一个子图&lt;/p&gt;

&lt;h4 id=&quot;生成子图-spanning-subgraph-1&quot;&gt;生成子图 Spanning Subgraph&lt;/h4&gt;

&lt;p&gt;如果 &lt;strong&gt;$\bold{V’= V}$&lt;/strong&gt;，$E’\subseteq E$，则称图 $G’=&amp;lt;V’,E’&amp;gt;$ 是图 $G$ 的一个生成子图&lt;/p&gt;

&lt;h4 id=&quot;生成树-spanning-tree&quot;&gt;生成树 Spanning Tree&lt;/h4&gt;

&lt;p&gt;连通且无环的生成子图&lt;/p&gt;

&lt;h4 id=&quot;最小生成树&quot;&gt;最小生成树&lt;/h4&gt;

&lt;p&gt;权重最小的生成树&lt;/p&gt;

&lt;h4 id=&quot;安全边-safe-edge&quot;&gt;安全边 Safe Edge&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;$A$ 是某棵最小生成树 $T$ 边的子集，即 $A\subseteq T$&lt;/li&gt;
  &lt;li&gt;$A\cup{(u,v)}$ 仍是 $T$ 边的一个子集，则称 $(u,v)$ 是 $A$ 的&lt;strong&gt;安全边&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;若每次向边集中新增安全边，可保证边集 $A$ 是最小生成树的子集&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;割-cut&quot;&gt;割 Cut&lt;/h4&gt;

&lt;p&gt;图 $G=&amp;lt;V, E&amp;gt;$ 是一个连通无向图，割 $(S, V-S)$ 将图 $G$ 的顶点集 $V$ 划分为两个部分&lt;/p&gt;

&lt;h4 id=&quot;横跨-cross&quot;&gt;横跨 Cross&lt;/h4&gt;

&lt;p&gt;给定割 $(S,V-S)$ 和边 $(u,v)$，$u\in S,v\in V-S$，称边 $(u,v)$ 横跨割 $(S,V-S)$&lt;/p&gt;

&lt;h4 id=&quot;轻边-light-edge&quot;&gt;轻边 Light Edge&lt;/h4&gt;

&lt;p&gt;横跨割的所有边中，权重最小的边称为横跨这个割的轻边&lt;/p&gt;

&lt;h4 id=&quot;不妨害-respect&quot;&gt;不妨害 Respect&lt;/h4&gt;

&lt;p&gt;如果一个边集 $A$ 中没有边横跨某割，则称该割不妨害边集 $A$&lt;/p&gt;

&lt;h4 id=&quot;安全边辨识定理&quot;&gt;安全边辨识定理&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/safe.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;问题定义-9&quot;&gt;问题定义&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/st1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/com.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;prim&quot;&gt;Prim&lt;/h3&gt;

&lt;h4 id=&quot;算法思想-3&quot;&gt;算法思想&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/prim.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;辅助数组-1&quot;&gt;辅助数组&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/prim2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;伪代码-22&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/prim3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/prim4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-9&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;^2)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;优化-prim采用优先队列&quot;&gt;优化 Prim–采用优先队列&lt;/h3&gt;

&lt;h4 id=&quot;伪代码-23&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/prim5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/prim6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-10&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;\cdot \log{&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;})$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;kruskal&quot;&gt;Kruskal&lt;/h3&gt;

&lt;h4 id=&quot;算法思想-4&quot;&gt;算法思想&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/k1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;伪代码-24&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/k3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;高效判定和维护所选边的顶点是否在一棵子树&lt;/strong&gt;——&lt;strong&gt;不相交集合&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/s1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/s2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/s3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-11&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;\log{&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;})$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;single-source-shortest-path-单源最短路径&quot;&gt;Single Source Shortest Path (单源最短路径)&lt;/h2&gt;

&lt;h3 id=&quot;问题定义-10&quot;&gt;问题定义&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/ss1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dijkstra&quot;&gt;Dijkstra&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;算法使用范围：边权为正的图&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;辅助数组-2&quot;&gt;辅助数组&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/ss2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;算法思想-5&quot;&gt;算法思想&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/ss3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/ss4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/ss5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;伪代码-25&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/d1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/d2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-12&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;^2)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;用优先队列优化-dijkstra-算法&quot;&gt;用优先队列优化 Dijkstra 算法&lt;/h3&gt;

&lt;h4 id=&quot;伪代码-26&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/d3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/d4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-13&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;\cdot \log{&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;})$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;bellman-ford&quot;&gt;Bellman-Ford&lt;/h3&gt;

&lt;h4 id=&quot;问题背景-1&quot;&gt;问题背景&lt;/h4&gt;

&lt;p&gt;当图中存在&lt;strong&gt;负权边&lt;/strong&gt;时，Dijkstra 算法不适用&lt;/p&gt;

&lt;h4 id=&quot;问题定义-11&quot;&gt;问题定义&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/bf1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;算法思想-6&quot;&gt;算法思想&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/bf2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;伪代码-27&quot;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/bf3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/bf4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;时间复杂度-14&quot;&gt;时间复杂度&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;\cdot&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;all-pairs-shortest-path-所有点对最短路径&quot;&gt;All-Pairs Shortest Path (所有点对最短路径)&lt;/h2&gt;

&lt;h3 id=&quot;问题定义-12&quot;&gt;问题定义&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/ap1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;问题分析-2&quot;&gt;问题分析&lt;/h3&gt;

&lt;p&gt;$D[k,i,j]$：可以从前 $k$ 个点选点经过时，$i$ 到 $j$ 的最短距离&lt;/p&gt;

&lt;h3 id=&quot;递推关系建立-5&quot;&gt;递推关系建立&lt;/h3&gt;

\[D[k,i,j]=\min
\left\{
\begin{array}{l}
D[k-1,i,j]\\
D[k-1,i,k]+D[k-1,k,j]
\end{array}
\right.\]

&lt;h3 id=&quot;伪代码-28&quot;&gt;伪代码&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/sp2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/ap3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;时间复杂度-15&quot;&gt;时间复杂度&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$O(&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;^3)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/short.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;dealing-with-hard-problems&quot;&gt;Dealing with Hard Problems&lt;/h1&gt;

&lt;h2 id=&quot;definition-2&quot;&gt;Definition&lt;/h2&gt;

&lt;h3 id=&quot;input-size&quot;&gt;Input Size&lt;/h3&gt;

&lt;p&gt;The &lt;strong&gt;input size&lt;/strong&gt; of a problem is the &lt;strong&gt;minimum number&lt;/strong&gt; of bits ({0, 1}) needed to encode the input of the problem.&lt;/p&gt;

&lt;h3 id=&quot;decision-problem&quot;&gt;Decision Problem&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;decision problem&lt;/strong&gt; is a question that has two possible answers: &lt;strong&gt;yes&lt;/strong&gt; and &lt;strong&gt;no&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If $L$ is the problem and $x$ is the input, we often write $x\in L$ to denote a &lt;strong&gt;yes&lt;/strong&gt; and $x\not\in L$ to denote a &lt;strong&gt;no&lt;/strong&gt; answer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;optimization-problem&quot;&gt;Optimization Problem&lt;/h3&gt;

&lt;p&gt;An &lt;strong&gt;optimization problem&lt;/strong&gt; requires an answer that is an optimal configuration.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An optimization problem usually has a corresponding decision problem.&lt;/p&gt;

  &lt;p&gt;For almost all optimization problems there exists a corresponding simpler decision problem.&lt;/p&gt;

  &lt;p&gt;Thus if we prove that a given problem is hard to solve efficiently, then it is obvious that the optimization problem must be (at least as) hard.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;yes--no-input&quot;&gt;Yes / No Input&lt;/h3&gt;

&lt;p&gt;An instance of a decision problem is called a &lt;strong&gt;yes-input&lt;/strong&gt; (respectively no-input) if the answer to the instance is &lt;strong&gt;yes&lt;/strong&gt; (respectively no).&lt;/p&gt;

&lt;h3 id=&quot;polynomial-time&quot;&gt;Polynomial-time&lt;/h3&gt;

&lt;p&gt;An algorithm is &lt;strong&gt;polynomial-time&lt;/strong&gt; if its running time is $O(n^k)$, where $k$ is a constant independent of n, and n is the &lt;strong&gt;input-size&lt;/strong&gt; of the problem that the algorithm solves.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Whether you use $n$ or $n^\alpha$ (for fixed a &amp;gt; 0) as the input size, it will not affect the conclusion of whether an algorithm is polynomial time.&lt;/p&gt;

  &lt;p&gt;Polynomial-time algorithm is “practical” and exponential-time algorithm is not.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;p&quot;&gt;P&lt;/h3&gt;

&lt;p&gt;The class &lt;strong&gt;P&lt;/strong&gt; consists of all &lt;strong&gt;decision problems&lt;/strong&gt; that are solvable in &lt;strong&gt;polynomial time&lt;/strong&gt;. That is, there exists an algorithm that will &lt;strong&gt;decide&lt;/strong&gt; in polynomial time if any given input is a yes-input or a no-input.&lt;/p&gt;

&lt;h3 id=&quot;certificate&quot;&gt;Certificate&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;certificate&lt;/strong&gt; is a specific object corresponding to a &lt;strong&gt;yes-input&lt;/strong&gt;, such that it can be used to show that the input is &lt;strong&gt;indeed&lt;/strong&gt; a yes-input.&lt;/p&gt;

&lt;h3 id=&quot;np&quot;&gt;NP&lt;/h3&gt;

&lt;p&gt;The class &lt;strong&gt;NP&lt;/strong&gt; consists of all &lt;strong&gt;decision problems&lt;/strong&gt; such that, for each yes-input, there exists a &lt;strong&gt;certificate&lt;/strong&gt; which allows one to verify in &lt;strong&gt;polynomial time&lt;/strong&gt; that the input is indeed a yes input.&lt;/p&gt;

&lt;h3 id=&quot;polynomial-time-reducible&quot;&gt;Polynomial-time reducible&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Let $L_1$ and $L_2$ be two decision problems.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;strong&gt;polynomial-time reduction&lt;/strong&gt; from $L_1$ to $L_2$ is a transformation $f$ with the following two properties:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;$f$ transforms an input x for $L_1$ into an input $f(x)$ for $L_2$ such that: a yes-input of $L_1$ maps to a yes-input of $L_2$, and a no-input of $L_1$ maps to a no-input of $L_2$.&lt;/li&gt;
      &lt;li&gt;$f(x)$ is computable in &lt;strong&gt;polynomial time&lt;/strong&gt; (in size (x))&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;If such $f$ exists, we say that $L_1$ is &lt;strong&gt;polynomial-time reducible&lt;/strong&gt; to $L_2$, and write $L_1\le pL_2$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;If $L_2$ is polynomial-time algorithm, so is $L_1$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;np-complete-npc&quot;&gt;NP-Complete (NPC)&lt;/h3&gt;

&lt;p&gt;The class &lt;strong&gt;NPC&lt;/strong&gt; of &lt;strong&gt;NP-Complete&lt;/strong&gt; problems consists of all decision problems $L$ such that&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$L\in NP$&lt;/li&gt;
  &lt;li&gt;for every $L’\in NP$, $L’\le pL$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Intuitively, NPC consists of all the hardest problems in NP.&lt;/p&gt;

&lt;h3 id=&quot;np-hard&quot;&gt;NP-Hard&lt;/h3&gt;

&lt;p&gt;A problem $L$ is &lt;strong&gt;NP-Hard&lt;/strong&gt; if problem in NPC can be &lt;strong&gt;polynomially reduced&lt;/strong&gt; to it. (but $L$ does &lt;strong&gt;not&lt;/strong&gt; need to be in NP)&lt;/p&gt;

&lt;h2 id=&quot;theorem&quot;&gt;Theorem&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;If $L_1\le p L_2$ and $L_2\in P$, then $L_1\in P$&lt;/li&gt;
  &lt;li&gt;If $L_1\le p L_2$ and $L_2\le p L_3$, then $L_1\le p L_3$&lt;/li&gt;
  &lt;li&gt;If &lt;strong&gt;there is&lt;/strong&gt; a polynomial-time algorithm for $L\in NPC$, then there is a polynomial-time algorithm for &lt;strong&gt;every&lt;/strong&gt; $L’\in NP$&lt;/li&gt;
  &lt;li&gt;If &lt;strong&gt;there is no&lt;/strong&gt; polynomial-time algorithm for $L\in NPC$, then there is  no polynomial-time algorithm for &lt;strong&gt;every&lt;/strong&gt; $L’\in NPC$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;h3 id=&quot;p-1&quot;&gt;P&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;判断给定图是否为树&lt;/li&gt;
  &lt;li&gt;DFS, BFS&lt;/li&gt;
  &lt;li&gt;DMST，最小生成树决策类&lt;/li&gt;
  &lt;li&gt;2-SAT&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;np-1&quot;&gt;NP&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;D-SubsetSum&lt;/li&gt;
  &lt;li&gt;DVC (Decision Vertex Cover)&lt;/li&gt;
  &lt;li&gt;SAT (Satisfiability)&lt;/li&gt;
  &lt;li&gt;3-SAT&lt;/li&gt;
  &lt;li&gt;DMST&lt;/li&gt;
  &lt;li&gt;DKnapsack&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;np-complete&quot;&gt;NP-Complete&lt;/h3&gt;

&lt;p&gt;Knapsack&lt;/p&gt;

&lt;p&gt;NPC&lt;/p&gt;

&lt;p&gt;DCLIQUE&lt;/p&gt;

&lt;p&gt;Decision Vertex Cover&lt;/p&gt;

&lt;p&gt;Decision Independent Set&lt;/p&gt;

&lt;h2 id=&quot;question&quot;&gt;Question&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Question&lt;/th&gt;
      &lt;th&gt;Answer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P\subseteq NP $&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$NP\subseteq P$&lt;/td&gt;
      &lt;td&gt;unknown&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$NPC\subseteq NP $&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$P=NP $&lt;/td&gt;
      &lt;td&gt;unknown&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>ericaaaaaaaa</name></author><category term="Algorithms" /><category term="note" /><category term="algorithm" /><summary type="html">Introduction</summary></entry><entry><title type="html">Database</title><link href="http://localhost:4000/data/2022/01/07/Database.html" rel="alternate" type="text/html" title="Database" /><published>2022-01-07T00:00:00+08:00</published><updated>2022-01-07T00:00:00+08:00</updated><id>http://localhost:4000/data/2022/01/07/Database</id><content type="html" xml:base="http://localhost:4000/data/2022/01/07/Database.html">&lt;center&gt;&lt;b&gt;&lt;font size=&quot;6&quot;&gt;数据库系统原理&lt;/font&gt;&lt;/b&gt;&lt;/center&gt;

&lt;h1 id=&quot;第一篇-基础篇&quot;&gt;第一篇 基础篇&lt;/h1&gt;

&lt;h2 id=&quot;第-1-章-绪论&quot;&gt;第 1 章 绪论&lt;/h2&gt;

&lt;h3 id=&quot;11-数据库系统概述&quot;&gt;1.1 数据库系统概述&lt;/h3&gt;

&lt;h4 id=&quot;111-数据库的四个基本概念&quot;&gt;1.1.1 数据库的四个基本概念&lt;/h4&gt;

&lt;h5 id=&quot;数据-data&quot;&gt;数据 (data)&lt;/h5&gt;

&lt;h6 id=&quot;数据&quot;&gt;数据&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;是描述现实世界各种事物的可以识别的符号。数据的含义称为数据的语义，数据与其语义是不可分的。&lt;/p&gt;

&lt;h6 id=&quot;信息&quot;&gt;信息&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;信息&lt;/strong&gt;是一种已经被加工为特定形式的数据，这些数据对现在与将来的决策有明显价值。&lt;/p&gt;

&lt;p&gt;信息是各种数据所包括的意义；数据是信息的载体，是信息的具体表现形式。&lt;/p&gt;

&lt;h6 id=&quot;数据处理&quot;&gt;数据处理&lt;/h6&gt;

&lt;p&gt;从大量原始数据中抽取和推导出有价值信息的加工过程称为&lt;strong&gt;数据处理&lt;/strong&gt;，包括：数据收集、组织、存储、加工、分类、检索、输出、传输等操作。&lt;/p&gt;

&lt;h6 id=&quot;数据管理&quot;&gt;数据管理&lt;/h6&gt;

&lt;p&gt;数据处理一般性的基本操作，如数据分类、组织、存储、检索、维护等成为数据管理，并研究专门的技术——&lt;strong&gt;数据管理技术&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;数据库-database-db&quot;&gt;数据库 (DataBase, DB)&lt;/h5&gt;

&lt;h6 id=&quot;数据库&quot;&gt;数据库&lt;/h6&gt;

&lt;p&gt;数据库是&lt;strong&gt;长期存储&lt;/strong&gt;在计算机内的，&lt;strong&gt;有组织&lt;/strong&gt;的，&lt;strong&gt;可共享&lt;/strong&gt;的大量数据的集合。&lt;/p&gt;

&lt;p&gt;数据库按照一定的数据模型组织，描述和储存，具有较小的&lt;strong&gt;冗余度&lt;/strong&gt;(redundancy)、较高的&lt;strong&gt;数据独立性&lt;/strong&gt;(data independency) 和&lt;strong&gt;易扩展性&lt;/strong&gt;(scalability)，并可为各种用户&lt;strong&gt;共享&lt;/strong&gt;。&lt;/p&gt;

&lt;h6 id=&quot;数据库技术&quot;&gt;数据库技术&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;是一种数据管理技术&lt;/li&gt;
  &lt;li&gt;按照某种数据结构对数据进行组织后，存储在计算机的二级存储中，并可以提供数据共享工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;数据库系统&quot;&gt;数据库系统&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;数据库系统&lt;/strong&gt;是基于数据库管理系统建立的具有特定数据处理功能的系统。&lt;/p&gt;

&lt;h5 id=&quot;数据库管理系统-database-management-system-dbms&quot;&gt;数据库管理系统 (DataBase Management System, DBMS)&lt;/h5&gt;

&lt;p&gt;数据库管理系统是位于用户和操作系统之间的一层数据库管理软件。&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据的最小存取单位是数据项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它的功能有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据定义功能
    &lt;ul&gt;
      &lt;li&gt;提供数据定义语言 (Data Definition Language, DDL)、&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据组织、存储和管理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;数据操纵功能
    &lt;ul&gt;
      &lt;li&gt;提供数据操纵语言 (Data Manipulation Language, DML)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库的事务管理和运行管理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库的建立和维护&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;统一的数据控制功能&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;数据的安全性控制&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;保护数据以防止不合法的使用所造成的数据的泄密和破坏&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;数据的完整性控制&lt;/p&gt;

        &lt;p&gt;指数据的正确性与相容性&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;数据的并发控制&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;对多用户的并发操作进行控制，协调，保护数据的完整性&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;数据库恢复&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;将数据库从错误状态恢复到某一已知的正确状态&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;数据库系统-database-system-dbs&quot;&gt;数据库系统 (DataBase System, DBS)&lt;/h5&gt;

&lt;p&gt;数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator, DBA）组成的存储、管理、处理和维护数据的系统。&lt;/p&gt;

&lt;h4 id=&quot;112-数据管理技术的产生和发展&quot;&gt;1.1.2 数据管理技术的产生和发展&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;阶段&lt;/th&gt;
      &lt;th&gt;数据管理者&lt;/th&gt;
      &lt;th&gt;数据保存&lt;/th&gt;
      &lt;th&gt;数据共享程度&lt;/th&gt;
      &lt;th&gt;数据独立性&lt;/th&gt;
      &lt;th&gt;数据结构化&lt;/th&gt;
      &lt;th&gt;数据控制能力&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;人工管理阶段&lt;/td&gt;
      &lt;td&gt;用户（程序员）&lt;/td&gt;
      &lt;td&gt;不保存&lt;/td&gt;
      &lt;td&gt;无共享，冗余度极大&lt;/td&gt;
      &lt;td&gt;不独立，完全依赖于程序&lt;/td&gt;
      &lt;td&gt;无结构&lt;/td&gt;
      &lt;td&gt;应用程序自己控制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;文件系统阶段&lt;/td&gt;
      &lt;td&gt;文件系统&lt;/td&gt;
      &lt;td&gt;可以长期保存&lt;/td&gt;
      &lt;td&gt;共享性差，冗余度大&lt;/td&gt;
      &lt;td&gt;独立性差&lt;/td&gt;
      &lt;td&gt;记录内有结构，整体无结构&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数据库系统阶段&lt;/td&gt;
      &lt;td&gt;数据库管理系统&lt;/td&gt;
      &lt;td&gt;可以长期大量保存&lt;/td&gt;
      &lt;td&gt;共享性高，冗余度小&lt;/td&gt;
      &lt;td&gt;具有高度的物理独立性和一定的逻辑独立性&lt;/td&gt;
      &lt;td&gt;整体结构化，由数据模型描述&lt;/td&gt;
      &lt;td&gt;由数据库管理系统提供数据安全性、完整性、并发控制和恢复能力&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;113-数据库系统的特点&quot;&gt;1.1.3 数据库系统的特点&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;数据结构化&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;数据库的结构化是数据库的&lt;em&gt;主要特征&lt;/em&gt;之一，也是&lt;em&gt;数据库和文件系统的&lt;/em&gt;&lt;strong&gt;&lt;em&gt;本质区别&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;数据内部结构化，整体结构化，&lt;strong&gt;数据之间有联系&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据共享性高，冗余度低且易扩充&lt;/p&gt;

    &lt;p&gt;数据共享可以大大减少数据冗余，节约存储空间，能避免数据之间的不相容性与不一致性，使得数据库系统弹性大，易扩充。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据独立性高&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;减少应用程序的维护和修改&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;物理独立性&lt;/strong&gt;是指用户的应用程序与数据库中数据的物理存储是相互独立的。（数据的存储结构（物理结构）改变时，数据的逻辑结构可以不变，从而应用程序也不必改变）&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;逻辑独立性&lt;/strong&gt;是指用户的应用程序与数据库的逻辑结构是相互独立的（数据的逻辑结构改版时，应用程序可以不变）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据由数据库管理系统统一管理和控制&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;数据的安全性 (security) 保护&lt;/p&gt;

        &lt;p&gt;数据的安全性是指保护数据以放置不合法使用造成的数据泄密和破坏&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;数据的完整性 (integrity) 检查&lt;/p&gt;

        &lt;p&gt;数据的完整性是指数据的&lt;strong&gt;正确性&lt;/strong&gt;（和客观世界相一致）、&lt;strong&gt;有效性&lt;/strong&gt;和&lt;strong&gt;相容性&lt;/strong&gt;（同一个数据在不同位置内容一致）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;并发 (concurrency) 控制&lt;/p&gt;

        &lt;p&gt;对多个用户的并发操作进行控制，协调，保护数据的完整性&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;数据库恢复 (recovery)&lt;/p&gt;

        &lt;p&gt;将数据库从错误状态恢复到某一已知的正确状态&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;数据的最小存取单位是数据项&lt;/p&gt;

        &lt;p&gt;既可以存取一个或一组记录，也可以存取数据库中某个或某一组数据项&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-数据模型&quot;&gt;1.2 数据模型&lt;/h3&gt;

&lt;p&gt;数据模型 (data model) 是对现实世界数据特征的抽象，是数据库的核心和基础。&lt;/p&gt;

&lt;p&gt;将&lt;em&gt;现实世界&lt;/em&gt;抽象为&lt;em&gt;信息世界&lt;/em&gt;（概念模型），再将信息世界转换为&lt;em&gt;机器世界&lt;/em&gt;（数据模型）。&lt;/p&gt;

&lt;h4 id=&quot;概念模型信息模型&quot;&gt;概念模型（信息模型）&lt;/h4&gt;

&lt;p&gt;用于信息世界建模，是现实世界到信息世界的抽象描述用户和数据库设计人员进行交流的语言。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;信息世界中的基本概念&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;实体&lt;/strong&gt; (entity)&lt;/p&gt;

        &lt;p&gt;客观存在并可相互区别的事物称为实体。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt; (attribute)&lt;/p&gt;

        &lt;p&gt;实体所具有的某一特性。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;码&lt;/strong&gt; (key)&lt;/p&gt;

        &lt;p&gt;唯一标识实体的属性集。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;实体型&lt;/strong&gt; (entity type)&lt;/p&gt;

        &lt;p&gt;用实体名及其属性名集合来抽象刻画同类实体，称为实体型&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;实体集&lt;/strong&gt; (entity set)&lt;/p&gt;

        &lt;p&gt;同一类型的实体的集合。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;联系&lt;/strong&gt; (relationship)&lt;/p&gt;

        &lt;p&gt;实体型之间的联系，是实体之间的相互关联&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;名称&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;类型&lt;/strong&gt;
            &lt;ul&gt;
              &lt;li&gt;一对一 (1 : 1)&lt;/li&gt;
              &lt;li&gt;一对多 (1 : n)&lt;/li&gt;
              &lt;li&gt;多对多 (m : n)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;（属性）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;概念模型是一种表示方法，实体–联系方法 (E-R 法)&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;E-R 法(Entity-Relation Approach)：用 E-R 图描述现实世界的信息，这种信息结构称为概念结构&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;用 E-R 图描述现实世界&lt;/li&gt;
        &lt;li&gt;将 E-R 图转换成相应的数据模型&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;E-R 图&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;组成
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;实体&lt;/strong&gt;：用&lt;strong&gt;长方形&lt;/strong&gt;表示实体型，再框内写上实体名&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;属性&lt;/strong&gt;：用&lt;strong&gt;椭圆形&lt;/strong&gt;表示实体的属性，并用无向边吧实体与其属性连接起来
            &lt;ul&gt;
              &lt;li&gt;在无向边上打 ‘=’ 表示属性为实体的码&lt;/li&gt;
              &lt;li&gt;在连接多条无向边的弧线上打 ‘=’ 表示这些属性共同组成实体的码&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;联系&lt;/strong&gt;：用&lt;strong&gt;菱形&lt;/strong&gt;表示实体间的联系，菱形框内写上联系名。用无向边把菱形分别与有关实体相连，在边上标明连接的类型&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;实体之间联系的语义补充
        &lt;ul&gt;
          &lt;li&gt;存在依赖&lt;/li&gt;
          &lt;li&gt;标识依赖&lt;/li&gt;
          &lt;li&gt;实体的子类&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;数据模型层次网状关系模型&quot;&gt;数据模型（层次、网状、关系模型）&lt;/h4&gt;

&lt;p&gt;用于机器世界，按计算机系统的观点对数据进行建模。&lt;/p&gt;

&lt;h5 id=&quot;数据模型的三要素&quot;&gt;数据模型的&lt;strong&gt;三要素&lt;/strong&gt;&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;描述数据库的组成对象以及对象之间的联系
        &lt;ul&gt;
          &lt;li&gt;描述&lt;strong&gt;对象&lt;/strong&gt;的类型、内容、性质的概念，如关系模型中的域，属性等&lt;/li&gt;
          &lt;li&gt;描述&lt;strong&gt;对象之间联系&lt;/strong&gt;的概念，如关系模型中的关系&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;是数据模型&lt;strong&gt;静态特性&lt;/strong&gt;的描述&lt;/li&gt;
      &lt;li&gt;是刻画&lt;em&gt;数据模型&lt;/em&gt;最重要的方面&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;数据操作&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。
     * 是数据模型&lt;strong&gt;动态特性&lt;/strong&gt;的描述&lt;/li&gt;
      &lt;li&gt;类型：检索、更新（插、删、改）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;数据的完整性约束条件&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;数据的完整性约束条件是一组完整性规则&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;完整性规则&lt;/strong&gt;：给定的数据模型中数据及其联系所有的制约和依存规则，用以保证数据的正确、相容。
完整性约束条件包括：&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;符合这种数据模型所必须遵守的基本的通用的完整性约束条件&lt;/li&gt;
        &lt;li&gt;针对具体数据的特定语义约束条件&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;数据模型的分类&quot;&gt;数据模型的&lt;strong&gt;分类&lt;/strong&gt;&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;层次模型&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;用&lt;strong&gt;树结构&lt;/strong&gt;表示数据之间的联系，节点代表实体型，连线表示两实体型间的一对多联系。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;优点
        &lt;ul&gt;
          &lt;li&gt;结构简单&lt;/li&gt;
          &lt;li&gt;易于实现&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缺点
        &lt;ul&gt;
          &lt;li&gt;支持联系种类少（只能直接表示二元一对多练习）&lt;/li&gt;
          &lt;li&gt;数据操纵不便，子结点存取只能通过父节点来进行&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;网状模型&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;用&lt;strong&gt;图结构&lt;/strong&gt;表示数据之间的联系，节点代表实体型，连线表示两实体型间的一对多联系。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;特点
        &lt;ul&gt;
          &lt;li&gt;表达联系种类丰富&lt;/li&gt;
          &lt;li&gt;结构复杂&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;关系模型&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;用&lt;strong&gt;二维表&lt;/strong&gt;表示数据之间的联系&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;特点
        &lt;ul&gt;
          &lt;li&gt;用关系描述实体及实体间的联系（这种描述一致性使数据结构大大简化，概念简单）&lt;/li&gt;
          &lt;li&gt;可直接表示多对多联系&lt;/li&gt;
          &lt;li&gt;关系必须是规范化关系，即每个分量是不可分的数据项。或不许再表中套表&lt;/li&gt;
          &lt;li&gt;建立在数学概念基础上，理论基础强&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;语义约束&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;实体完整性 （Entity Integrity）&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;要有属性或属性组合作为主码，主码值不可位空或部分为空。或定义为若属性 A 是关系 R 的主属性，则属性 A 不能取空值。&lt;/p&gt;

                &lt;blockquote&gt;
                  &lt;p&gt;空值的含义是：不知道或不存在的值&lt;/p&gt;
                &lt;/blockquote&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;参照完整性 （Referential Integrity）&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;外部码&lt;/li&gt;
              &lt;li&gt;参照完整性&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;用户定义完整性&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-数据库系统的结构&quot;&gt;1.3 数据库系统的结构&lt;/h3&gt;

&lt;p&gt;三级模式、两级映像&lt;/p&gt;

&lt;h4 id=&quot;数据库的两级映像&quot;&gt;数据库的两级映像&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;数据的存储结构与逻辑结构之间的映像——实现数据的&lt;strong&gt;物理独立性&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;数据的全局逻辑结构与某类应用所涉及的局部逻辑结构的映像——实现数据的&lt;strong&gt;逻辑独立性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数据库系统的三级模式结构&quot;&gt;数据库系统的三级模式结构&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mode.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;模式&lt;/strong&gt; (schema)&lt;/p&gt;

    &lt;p&gt;模式也称为逻辑模式，是数据库中&lt;em&gt;全体数据的逻辑结构和特性的描述&lt;/em&gt;。是所有用户的公共数据视图。&lt;/p&gt;

    &lt;p&gt;三级模式的核心。&lt;/p&gt;

    &lt;p&gt;模式描述语言（Data Description Language, DDL）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;外模式&lt;/strong&gt; (external schema)&lt;/p&gt;

    &lt;p&gt;也称为子模式或用户模式。是个别用户的数据视图，即&lt;em&gt;与某一应用有关的数据的逻辑表示&lt;/em&gt;。&lt;/p&gt;

    &lt;p&gt;外模式 DDL&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;内模式&lt;/strong&gt; (internal schema)&lt;/p&gt;

    &lt;p&gt;也称为存储模式，是数据在数据库系统内部的表示，即对&lt;em&gt;数据的物理结构和存储方式的描述&lt;/em&gt;。&lt;/p&gt;

    &lt;p&gt;内模式 DDL&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;优点
    &lt;ul&gt;
      &lt;li&gt;保证数据的独立性:
        &lt;ul&gt;
          &lt;li&gt;模式与内模式分开–数据物理独立性&lt;/li&gt;
          &lt;li&gt;模式与外模式分开–数据逻辑独立性&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;简化用户接口, 方便用户使用&lt;/li&gt;
      &lt;li&gt;有利于数据共享&lt;/li&gt;
      &lt;li&gt;有利于数据的安全保密&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;14-数据库系统的组成&quot;&gt;1.4 数据库系统的组成&lt;/h3&gt;

&lt;h4 id=&quot;dbms-的主要功能&quot;&gt;DBMS 的主要功能&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;数据库定义功能
    &lt;ul&gt;
      &lt;li&gt;利用 DDL 语言描述外模式, 模式, 内模式(源模式)&lt;/li&gt;
      &lt;li&gt;模式翻译程序把内模式翻译哼目标模式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据存取功能
    &lt;ul&gt;
      &lt;li&gt;提供 DML(Data Manipulation Language) 语言对数据库进行检索, 插入, 修改, 删除&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据库运行管理
    &lt;ul&gt;
      &lt;li&gt;并发控制, 存取控制, 完整性约束检查, 日志管理……&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据组织, 存储和管理&lt;/li&gt;
  &lt;li&gt;数据库的建立和维护&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;dbms-的组成&quot;&gt;DBMS 的组成&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;语言编译处理程序&lt;/li&gt;
  &lt;li&gt;系统运行控制程序&lt;/li&gt;
  &lt;li&gt;系统建立和维护程序&lt;/li&gt;
  &lt;li&gt;数据字典&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;dba&quot;&gt;DBA&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;建库&lt;/li&gt;
  &lt;li&gt;用库&lt;/li&gt;
  &lt;li&gt;改进&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第二章-关系数据库&quot;&gt;第二章 关系数据库&lt;/h2&gt;

&lt;h3 id=&quot;21-关系数据结构及形式化定义&quot;&gt;2.1 关系数据结构及形式化定义&lt;/h3&gt;

&lt;h4 id=&quot;211-关系&quot;&gt;2.1.1 关系&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;域&lt;/strong&gt;(domain)&lt;/p&gt;

    &lt;p&gt;域是一组具有相同数据类型的值的集合.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;笛卡尔积&lt;/strong&gt;(cartesian product)&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;$D_1\times D_2\times … \times D_n={(d_1, d_2, …, d_n)&lt;/td&gt;
          &lt;td&gt;d_i\in D_i, i = 1,2,..,n}$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;元组&lt;/strong&gt;(n-tuple)
$(d_1, d_2, …, d_n)$ n 元组&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;分量&lt;/strong&gt;(component)
元组的每一个值 $d_i$&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;基数&lt;/strong&gt;(cardinal number)
一个域允许的不同取值个数称为这个域的基数&lt;/p&gt;

        &lt;p&gt;笛卡尔积的基数 = $\prod_{i=1}^{n}m_i$&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;关系&lt;/strong&gt;(relation)&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;关系&lt;/strong&gt;
 $D_1\times D_2\times … \times D_n$ 的子集叫做在域 $D_1, D_2, …, D_n$ 上的关系, 用 $R(D_1, D_2,…, D_n)$ 表示, n 是关系的&lt;strong&gt;目(度, degree)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;单元关系(unary relation)&lt;/li&gt;
          &lt;li&gt;二元关系(binary relation)&lt;/li&gt;
          &lt;li&gt;属性(attribute): 关系二维表每个列附加的名称&lt;/li&gt;
          &lt;li&gt;候选码(candidate key): 能唯一标识一个元组的属性&lt;strong&gt;组&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;主码(primary key): 在候选码中选择一个为主码&lt;/li&gt;
          &lt;li&gt;主属性(prime attribute): 候选码的各个属性&lt;/li&gt;
          &lt;li&gt;非主属性(non-prime attribute)
    * &lt;strong&gt;基本关系的性质&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;列的同质(Homogeneous)的，即每一列中的分量来自同一域，是同一类型的数据。&lt;/li&gt;
      &lt;li&gt;不同列可出自同一域, 每列必须有不同的属性名&lt;/li&gt;
      &lt;li&gt;列的顺序无所谓, 即列的次序可以呼唤&lt;/li&gt;
      &lt;li&gt;任意两个元组不能完全相同&lt;/li&gt;
      &lt;li&gt;行的顺序无所谓, 即行的次序可以呼唤&lt;/li&gt;
      &lt;li&gt;每一分量必须是不可再分的数据, 满足这一条件的关系称作满足第一范式 (1NF, Normal Form) 的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;关系模式&quot;&gt;关系模式&lt;/h4&gt;

&lt;p&gt;关系的描述称为&lt;strong&gt;关系模式&lt;/strong&gt;(relation schema), 它可以形式化表示为: $R(U, D, DOM, F, I)$&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;R–关系名&lt;/li&gt;
  &lt;li&gt;U–组成该关系的属性名集合&lt;/li&gt;
  &lt;li&gt;D–U 中属性来自的域&lt;/li&gt;
  &lt;li&gt;DOM–属性向域的映像集合&lt;/li&gt;
  &lt;li&gt;F–属性间数据的依赖关系集合&lt;/li&gt;
  &lt;li&gt;I–完整性约束集合&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-关系操作&quot;&gt;2.2 关系操作&lt;/h3&gt;

&lt;h3 id=&quot;23-关系的完整性&quot;&gt;2.3 关系的完整性&lt;/h3&gt;

&lt;h4 id=&quot;231-实体完整性&quot;&gt;2.3.1 实体完整性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;要有属性或属性组合作为主码, 主码值不可为空或部分为空。或定义为若属性A是关系R的主属性，则属性 A 不能取空值。&lt;/li&gt;
  &lt;li&gt;空值的含义是：不知道或不存在的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;232-参照完整性&quot;&gt;2.3.2 参照完整性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;外部码
    &lt;ul&gt;
      &lt;li&gt;设 F 是基本关系 R 的一个或一组属性，但不是 R 的码。如果 F 与基本关系 S 的主码 Ks 相对应，则称 F 是关系 R 的外部码（Foreign Key），并称 R 为参照关系（Referencing Relation），S 为被参照关系（Referenced Relation）或目标关系（Target Relation）。R 和 S 不一定是不同的关系。&lt;/li&gt;
      &lt;li&gt;目标关系 S 的主码 Ks 和参照关系的外部码 F 必须定义在一个域上。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;参照完整性
    &lt;ul&gt;
      &lt;li&gt;如果关系R的外部码 Fk 与关系 S 的主码 Pk 相对应，则R中的每一个元组的 Fk 值或者等于 S 中某个元组的 Pk 值，或者为空值。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;233-用户定义完整性&quot;&gt;2.3.3 用户定义完整性&lt;/h4&gt;

&lt;p&gt;用户定义完整性反映了某一具体应用所涉及的数据必须满足的语义要求。&lt;/p&gt;

&lt;h2 id=&quot;24-关系代数&quot;&gt;2.4 关系代数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;从数学角度，&lt;strong&gt;基本&lt;/strong&gt;关系代数运算有 5 种：&lt;strong&gt;并、差、乘、选择、投影&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;从数据库角度，&lt;strong&gt;核心&lt;/strong&gt;的关系代数运算为：&lt;strong&gt;选择、投影、连接（或自然连接）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;关系模型的数据操作&quot;&gt;关系模型的数据操作&lt;/h3&gt;

&lt;p&gt;关系数据操作的基础是”关系运算“。关系运算的方式有两种：代数方式，逻辑方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/type.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;关系代数&quot;&gt;关系代数&lt;/h3&gt;

&lt;p&gt;关系代数是一种抽象的查询语言 ，它用对关系的运算来表达查询。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;运算对象&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;关系&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运算结果&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;关系&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运算符&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;集合运算符
        &lt;ul&gt;
          &lt;li&gt;$\cup$ 并&lt;/li&gt;
          &lt;li&gt;$\cap$ 交&lt;/li&gt;
          &lt;li&gt;-   差&lt;/li&gt;
          &lt;li&gt;$\times$ 笛卡尔积&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;专门关系运算符
        &lt;ul&gt;
          &lt;li&gt;$\sigma$ 选择&lt;/li&gt;
          &lt;li&gt;$\prod$ 投影&lt;/li&gt;
          &lt;li&gt;$\Join$ 连接&lt;/li&gt;
          &lt;li&gt;$\div$  除&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;h3 id=&quot;241-传统的集合运算&quot;&gt;2.4.1 传统的集合运算&lt;/h3&gt;

    &lt;p&gt;传统的集合运算是&lt;strong&gt;二目运算&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;并&lt;/strong&gt; (union)&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;$R\cup S={t&lt;/td&gt;
              &lt;td&gt;t\in R\vee t\in S}$&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;差&lt;/strong&gt; (except)&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;$R-S={t&lt;/td&gt;
              &lt;td&gt;t\in R\wedge t\not\in S}$&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;交&lt;/strong&gt; (intersection)&lt;/p&gt;

        &lt;p&gt;$R\cap S={t\in R\wedge t\in S}$&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;笛卡尔积&lt;/strong&gt; (cartesian product)&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;$R\times S={t_r t_s&lt;/td&gt;
              &lt;td&gt;t_r\in R\wedge t_s\in S}$&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;242-专门的关系运算&quot;&gt;2.4.2 专门的关系运算&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;引入记号&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;&lt;strong&gt;关系模式&lt;/strong&gt; $R(A_1, A_2, …,A_n)$，它的一个&lt;strong&gt;关系&lt;/strong&gt;为 $R$，$t\in R$ 表示 $t$ 是 $R$ 的一个&lt;strong&gt;元组&lt;/strong&gt;。$t[A_i]$ 则表示元组 $t$ 中相应于属性 $A_i$ 的一个分量。&lt;/li&gt;
    &lt;li&gt;若 $A={A_{i1},A_{i2},…,A_{ik}}$，其中 $A_{i1},A_{i2},…,A_{ik}$ 是 $A_1, A_2, …,A_n$  中的一部分，则称 $A$ 为&lt;strong&gt;属性列&lt;/strong&gt;或&lt;strong&gt;属性组&lt;/strong&gt;。$t[A]=(t[A_{i1}],t[A_{i2}],…,t[A_{ik}])$ 表示元组 $t$ 在属性列 $A$ 上诸分量的集合，$\overline{A}$ 则表示 ${A_{1},A_{2},…,A_{n}}$ 中去掉 ${A_{i1},A_{i2},…,A_{ik}}$ 后剩余的属性组。&lt;/li&gt;
    &lt;li&gt;$R$ 为 $n$ 目关系，$S$ 为 $m$ 目关系，$t_r\in R$，$t_s\in S$，$t_rt_s$ 称为元组的&lt;strong&gt;连接&lt;/strong&gt; (concatenation)  或元组的&lt;strong&gt;串接&lt;/strong&gt;。它是一个 $n+m$ 列数组。&lt;/li&gt;
    &lt;li&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;给定一个关系 $R(X,Z)$，$X$ 和 $Z$ 为属性组，当 $t[X=x]$ 时，$x$ 在 $R$ 中的象集 (images set) 定义为：$Z_x={t[Z]&lt;/td&gt;
            &lt;td&gt;t\in R,t[X]=x}$，它表示 $R$ 中属性组 $X$ 上值为 $x$ 的诸元组在 $Z$ 上分量的集合。&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;选择&lt;/strong&gt; (selection)&lt;/p&gt;

    &lt;p&gt;选择又称为&lt;strong&gt;限制&lt;/strong&gt; (restriction)。&lt;/p&gt;

    &lt;p&gt;$\sigma_F(R)={t\in R\wedge F(t)=’真’}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;投影&lt;/strong&gt; (projection)&lt;/p&gt;

    &lt;p&gt;关系 $R$ 上的投影是从 $R$ 中选择出若干属性列组成新的关系&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;$\prod_Z(R)={t[A]&lt;/td&gt;
          &lt;td&gt;t\in R}$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;连接&lt;/strong&gt; (join)&lt;/p&gt;

    &lt;p&gt;连接也称为 $\theta$ 连接。它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;$R\underset{A\theta B}{\Join}S={t_rt_s&lt;/td&gt;
          &lt;td&gt;t_r\in R\wedge t_s\in S\wedge t_r[A]\theta t_s[B]}$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;其中，$A$ 和 $B$ 分别为 $R$ 和 $S$ 上列数相等且可比的属性组，$\theta$ 是比较运算符。连接运算从 $R$ 和 $S$ 的笛卡尔积 $R\times S$ 中选取 $R$ 关系在 $A$ 属性组上与 $S$ 关系在 $B$ 属性组上的值满足比较关系 $\theta$ 的元组&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;等值连接&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;$\theta$ 为 “=” 的连接运算称为等值连接。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;自然连接&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;自然连接要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉&lt;/p&gt;

        &lt;p&gt;在自然连接中被舍弃的元组称为&lt;strong&gt;悬浮元组&lt;/strong&gt; (dangling tuple)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;外连接&lt;/strong&gt; (outer join)&lt;/p&gt;

        &lt;p&gt;把悬浮元组也保存在结果关系中，而在其它属性上填空值 (NULL)&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;左外连接&lt;/strong&gt; (left outer join)&lt;/p&gt;

            &lt;p&gt;只保留左边关系 $R$ 中的悬浮元组&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;右外连接&lt;/strong&gt; (right outer join)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;除运算&lt;/strong&gt; (division)&lt;/p&gt;

    &lt;p&gt;设关系 $R$ 除以关系 $S$ 的结果为关系 $T$，则 $T$ 包含&lt;em&gt;所有在 $R$ 但不在 $S$ 中的属性及其值&lt;/em&gt;，且 $T$ 中的元组与 $S$ 中的元组的所有组合都在 $R$ 中&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;$R\div S={t_r[X]&lt;/td&gt;
          &lt;td&gt;t_r\in R\wedge \prod_Y(S)\subseteq Y_x}$，其中 $Y_x$ 是 $x$ 在 $R$ 中的象集&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;关系运算的安全性约束&quot;&gt;关系运算的安全性约束&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;关系运算种把不产生无限关系和无穷验证的运算称为&lt;strong&gt;安全运算&lt;/strong&gt;；其运算表达式称为&lt;strong&gt;安全表达式&lt;/strong&gt;，对其所采用的限制称为&lt;strong&gt;安全约束&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;关系代数是安全运算，关系演算则不一定是，所以对关系演算要进行安全约束
    &lt;ul&gt;
      &lt;li&gt;在关系演算中，通常采用的安全约束方法是对 $\Phi$ 定义一个有限的符号集 DOM($\Phi$)，使 $\Phi$ 的运算结果及中间结果所产生的关系及其元组的各个分量都必须属于 DOM($\Phi$)&lt;/li&gt;
      &lt;li&gt;设 $\Phi$ 是一个元组关系演算公式，为 DOM($\Phi$) 是由如下两类符号构成的集合
        &lt;ul&gt;
          &lt;li&gt;$\Phi$ 中的所有常量&lt;/li&gt;
          &lt;li&gt;$\Phi$ 中出现的所有元组的所有分量值&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;25-关系演算&quot;&gt;2.5 关系演算&lt;/h2&gt;

&lt;h3 id=&quot;251-元组关系演算&quot;&gt;2.5.1 元组关系演算&lt;/h3&gt;

&lt;p&gt;元组关系演算的基本结构是元组演算表达式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;形式定义：${t&lt;/td&gt;
          &lt;td&gt;\Phi(t)}$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;ul&gt;
      &lt;li&gt;$t$ 为&lt;strong&gt;元组变量&lt;/strong&gt;，如果元组变量前有“全称” ($\forall$) 或“存在” ($\exists$) 量词，则称其为&lt;strong&gt;约束元组变量&lt;/strong&gt;，否则称为&lt;strong&gt;自由元组变量&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;$\Phi(t)$ 是&lt;strong&gt;元组关系演算公式&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;递归定义
    &lt;ul&gt;
      &lt;li&gt;原子命题函数是公式，称为原子公式。原子公式有三类：
        &lt;ul&gt;
          &lt;li&gt;$R(t)$。$t$ 是关系 $R$ 中的一个元组&lt;/li&gt;
          &lt;li&gt;$t[i]\theta u[j]$&lt;/li&gt;
          &lt;li&gt;$t[i]\theta c$ 或 $c\theta t[i]$，$c$ 为常量&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;如果 $\Phi_1$，$\Phi_2$ 是公式，则 $\Phi_1\vee\Phi_2,\ \Phi_1\wedge\Phi_2,\ \neg\Phi$ 也是公式&lt;/li&gt;
      &lt;li&gt;如果 $\Phi$ 是公式，则 $\exists t(\Phi)$ 和 $\forall t(\Phi)$ 也是公式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;优先级
    &lt;ul&gt;
      &lt;li&gt;括号 &amp;gt; 算术比较运算符 &amp;gt; 量词 ($\exists$ &amp;gt; $\forall$) &amp;gt; 逻辑运算符 ($\neg$ &amp;gt; $\wedge$ &amp;gt; $\vee$)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;252-域关系演算&quot;&gt;2.5.2 域关系演算&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;形式定义：${(x_1x_2…x_k)&lt;/td&gt;
          &lt;td&gt;\Phi(x_1,x_2,…,x_k)}$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;ul&gt;
      &lt;li&gt;$x_i$ 表示域变量，如果域变量前有“全称” ($\forall$) 或“存在” ($\exists$) 量词，则称其为&lt;strong&gt;约束域变量&lt;/strong&gt;，否则称为&lt;strong&gt;自由域变量&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;$\Phi$ 是&lt;strong&gt;域关系演算公式&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;递归定义
    &lt;ul&gt;
      &lt;li&gt;原子命题函数是公式，称为原子公式。原子公式有三类：
        &lt;ul&gt;
          &lt;li&gt;$R(x_1,x_2,…,x_k)$。$(x_1,x_2,…,x_k)$ 是关系 $R$ 中的一个元组，$x_i$ 是域变量或常量&lt;/li&gt;
          &lt;li&gt;$x_i\theta y_j$&lt;/li&gt;
          &lt;li&gt;$x_i\theta c$ 或 $c\theta x_i$，$c$ 为常量&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;第三章-关系数据库标准语言-sql&quot;&gt;第三章 关系数据库标准语言 SQL&lt;/h1&gt;

&lt;h2 id=&quot;sql-的特点&quot;&gt;SQL 的特点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;综合统一&lt;/li&gt;
  &lt;li&gt;高度非过程化&lt;/li&gt;
  &lt;li&gt;面向集合的操作方式&lt;/li&gt;
  &lt;li&gt;以同一种语法结构提供两种使用方式&lt;/li&gt;
  &lt;li&gt;语言简洁，易学易用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sql-语言的基本概念&quot;&gt;SQL 语言的基本概念&lt;/h2&gt;

&lt;h3 id=&quot;数据库数据语言&quot;&gt;数据库数据语言&lt;/h3&gt;

&lt;p&gt;分类：&lt;strong&gt;数据定义（描述）语言&lt;/strong&gt;(DDL, Data Definition or Description Language)、&lt;strong&gt;数据操纵语言&lt;/strong&gt;(Data Manipulation Language, DML)、&lt;strong&gt;数据控制语言&lt;/strong&gt;(Data Control Language, DCL)&lt;/p&gt;

&lt;h4 id=&quot;数据定义语言&quot;&gt;数据定义语言&lt;/h4&gt;

&lt;p&gt;包括模式 DDL，外模式 DDL，内模式 DDL&lt;/p&gt;

&lt;h4 id=&quot;数据操纵语言&quot;&gt;数据操纵语言&lt;/h4&gt;

&lt;p&gt;检索、插入、修改、删除&lt;/p&gt;

&lt;h4 id=&quot;数据控制语言&quot;&gt;数据控制语言&lt;/h4&gt;

&lt;p&gt;完成数据库的安全性控制、完整性控制、并发控制等&lt;/p&gt;

&lt;h3 id=&quot;关系数据语言的特点&quot;&gt;关系数据语言的特点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;一体化&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;将数据的定义、查询、更新、控制等功能融为一体，只给用户提供一种称之为”查询语言“的语言。便于用户学习与使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;非过程化&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;用户只需提出”干什么“，而”怎样干“由 DBMS 解决。所以语言操作简单、易学、易用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;面向集合的存取方式&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;操作对象是一个或多个关系，操作的结果也是一个新关系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;既可独立使用又可与诸语言嵌套使用&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;关系数据库语言优越性的根源&quot;&gt;关系数据库语言优越性的根源&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关系模型采用了最简单、最规范化的数据结构，这使 DML 大大简化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系数据语言是建立在关系运算的数学基础上，可实现关系的垂直方向和水平方向的任意分割和组装操作，使得关系语言可随机地构造出用户需要的各种各样的新关系。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系语言的核心是&lt;strong&gt;查询&lt;/strong&gt;，所以又称为&lt;strong&gt;查询语言&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;关系运算&lt;/strong&gt;是涉及关系数据语言的基础，关系运算的分类也决定了关系语言的分类。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/post/class.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本表与导出表&quot;&gt;基本表与导出表&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;基本表&lt;/strong&gt;：是实际存在的，每个表在存储中可用一个存储文件来表示。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;导出表&lt;/strong&gt;：是从基本表导出的表，有视图（View）和快照（Snapshot）
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;视图&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;是一个&lt;em&gt;虚表&lt;/em&gt;，即视图所对应的数据不实际存储在数据库中，只在数据库的数据字典中存储视图的定义&lt;/li&gt;
          &lt;li&gt;视图一经定义就可以和基本表一样进行查询等操作，也可以用来定义新的视图&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create View xxx As xxx&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-数据查询功能&quot;&gt;SQL 数据查询功能&lt;/h3&gt;

&lt;h3 id=&quot;查询的基本结构&quot;&gt;查询的基本结构&lt;/h3&gt;

&lt;p&gt;查询的基本结构是 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT-FROM-WHERE&lt;/code&gt;&lt;/strong&gt; 组成的查询块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;SELECT 目标列
FROM 基本块（或视图）
WHERE 检索条件
ORDER BY 列名 ASC 或 DESC
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询的结果仍是一个表&lt;/li&gt;
  &lt;li&gt;查询块执行的过程是在表的水平方向上按“检索条件”选取元组，又在垂直方向上按 SELECT 指定的列进行投影。&lt;/li&gt;
  &lt;li&gt;查询块可进行关系函数中投影、选取、连接等操作的组合&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;查询语句实现细节&quot;&gt;查询语句实现细节&lt;/h3&gt;

&lt;h4 id=&quot;select-目标列&quot;&gt;SELECT 目标列&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;若在目标列前添加 DISTINCT，则表示要删除 SELECT 结果中的重复行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;from-基本块或视图&quot;&gt;FROM 基本块（或视图）&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;连表检索
    &lt;ul&gt;
      &lt;li&gt;各个数据表之间用逗号相连&lt;/li&gt;
      &lt;li&gt;连表时后面的检索条件中需要有连表条件&lt;/li&gt;
      &lt;li&gt;如果连接的表中有属性名相同，要用表名作前缀加以区分（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S.A, R.A&lt;/code&gt;）。&lt;/li&gt;
      &lt;li&gt;若需要对表&lt;em&gt;自身&lt;/em&gt;进行连接，则可以通过定义别名，将一个表看作两个表进行连接(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FROM S X, S Y&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;外连接&lt;/strong&gt;：在连接谓词的某一边加（* 或 +），则逻辑上为 * 所在边的表增加了一个空行。它可以与另一个表中所有不满足连接条件的元组进行连接，使这些元组能够输出。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;where-检索条件&quot;&gt;WHERE 检索条件&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;检索条件可以包含如下运算符：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;比较运算符（=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, !=）&lt;/li&gt;
      &lt;li&gt;布尔运算符（AND, OR, NOT）&lt;/li&gt;
      &lt;li&gt;括号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;子查询（嵌套查询）&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;WHERE 子句中可以包含另一个查询块，该查询块称为&lt;strong&gt;子查询&lt;/strong&gt;或&lt;strong&gt;嵌套查询&lt;/strong&gt;，包含子查询的语句称为&lt;strong&gt;外部查询&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;分类
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;普通子查询&lt;/strong&gt;：与外部查询无关，可单独执行得一组值&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;相关子查询&lt;/strong&gt;：把外查询的列值作为检索条件的条件值&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;如果子查询返回单值，可以直接用比较运算符 =, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;= 等连接子查询&lt;/li&gt;
      &lt;li&gt;如果子查询返回一组值，则必须在比较运算符和子查询之间插入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ANY&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL&lt;/code&gt; 等操作符。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN&lt;/code&gt;&lt;/strong&gt; 可以代替 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=ANY&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT IN&lt;/code&gt; 可以代替 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!= ALL&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXIST&lt;/code&gt;&lt;/strong&gt; 表示存在量词 $\exist$&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT EXIST&lt;/code&gt; 表示不存在&lt;/li&gt;
      &lt;li&gt;将全程谓词表示为等价的存在谓词 $(\forall x)P=\neg(\exist x(\neg P))$&lt;/li&gt;
      &lt;li&gt;将蕴含关系表示为等价的存在谓词 $p\rightarrow q=\neg p\vee q$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并、差、交检索&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;并 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;差 &lt;strong&gt;MINUS&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;交 &lt;strong&gt;INTERSECT&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;并、差、交检索的操作对象必须是&lt;strong&gt;相容&lt;/strong&gt;的，是&lt;strong&gt;同类&lt;/strong&gt;关系。即必须拥有相同数量与域的属性列。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;order-by-列名-asc-或-desc&quot;&gt;ORDER BY 列名 ASC 或 DESC&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;该语句可省略&lt;/li&gt;
  &lt;li&gt;可以将结果按照指定列排序&lt;/li&gt;
  &lt;li&gt;ASC 为升序，DESC 为降序，缺省则默认为升序&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;库函数&quot;&gt;库函数&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COUNT()&lt;/code&gt;&lt;/strong&gt; 按列值计个数，&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COUNT(*)&lt;/code&gt;&lt;/strong&gt; 对行记数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM()&lt;/code&gt;&lt;/strong&gt; 对数值列求总和&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVG()&lt;/code&gt;&lt;/strong&gt; 求数值列的平均值&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAX()&lt;/code&gt;&lt;/strong&gt; 在列中找出最大值&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIN()&lt;/code&gt;&lt;/strong&gt; 在列中找出最小值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只能在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 子句以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HAVING&lt;/code&gt; 子句中出现。&lt;/p&gt;

&lt;h4 id=&quot;分组检索&quot;&gt;分组检索&lt;/h4&gt;

&lt;p&gt;按属性列（列组）将关系的元组分组，每组在这些分组属性列（列祖）上具有相同值，对每一组执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分组子句&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;GROUP BY 列名
[HAVING 条件表达式] # 分组条件
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;算数表达式值的检索&quot;&gt;算数表达式值的检索&lt;/h4&gt;

&lt;p&gt;SELECT 子句中，可包括由属性列、常数、库函数、算数运算符 + - * / 等组成的算数表达式&lt;/p&gt;

&lt;p&gt;检索结果数据项名可用表达式表示或用“别名”表示&lt;/p&gt;

&lt;h4 id=&quot;部分匹配查询&quot;&gt;部分匹配查询&lt;/h4&gt;

&lt;p&gt;使用谓词 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIKE&lt;/code&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT LIKE&lt;/code&gt;&lt;/strong&gt;，一般形式：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;列名&amp;gt; LIKE/NOT LIKE &amp;lt;字符串常量&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;列名&amp;gt;&lt;/code&gt; 必须为字符型或变长字符型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;字符串常量&amp;gt;&lt;/code&gt;可包含两个特殊符号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt;：代表任意序列的 0 个或多个字符&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt;：代表任意单个字符&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-数据定义功能&quot;&gt;SQL 数据定义功能&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作对象&lt;/th&gt;
      &lt;th&gt;创建&lt;/th&gt;
      &lt;th&gt;删除&lt;/th&gt;
      &lt;th&gt;修改&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;基本表&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create Table&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Drop Table&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alter Table&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;视图&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create View&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Drop View&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;索引&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create Index&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Drop Index&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;定义基本表&quot;&gt;定义基本表&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Create Table &amp;lt;表名&amp;gt;
(
    &amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt; [&amp;lt;列级完整性约束&amp;gt;]
    [{,&amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt; [&amp;lt;列级完整性约束&amp;gt;]}]
    [{, [&amp;lt;表级完整性约束&amp;gt;]}]
);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;完整性约束
    &lt;ul&gt;
      &lt;li&gt;NULL / NOT NULL&lt;/li&gt;
      &lt;li&gt;UNIQUE&lt;/li&gt;
      &lt;li&gt;PRIMARY KEY&lt;/li&gt;
      &lt;li&gt;FOREIGN KEY&lt;/li&gt;
      &lt;li&gt;CHECK&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;修改基本表&quot;&gt;修改基本表&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Alter Table &amp;lt;表名&amp;gt;
[Add &amp;lt;新列名&amp;gt; &amp;lt;数据类型&amp;gt; [&amp;lt;完整性约束&amp;gt;]]
[Drop &amp;lt;完整性约束名&amp;gt;]
[Modify &amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;删除基本表&quot;&gt;删除基本表&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Drop Table &amp;lt;表名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sql-数据类型&quot;&gt;SQL 数据类型&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;数据类型&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;char(n)&lt;/td&gt;
      &lt;td&gt;固定长度的字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;varchar(n)&lt;/td&gt;
      &lt;td&gt;可变长字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int&lt;/td&gt;
      &lt;td&gt;整数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;smallint&lt;/td&gt;
      &lt;td&gt;小整数类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;numeric(p, q)&lt;/td&gt;
      &lt;td&gt;定点数共 p 位，小数点右边 q 位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Real, double precision&lt;/td&gt;
      &lt;td&gt;浮点数域双精度浮点数，精度域机器有关&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Float&lt;/td&gt;
      &lt;td&gt;n 位的精度浮点数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;date&lt;/td&gt;
      &lt;td&gt;日期（年、月、日）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;time&lt;/td&gt;
      &lt;td&gt;时间（小时、分、秒）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;interval&lt;/td&gt;
      &lt;td&gt;两个 date 或 time 类型数据之间的差&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;索引操作&quot;&gt;索引操作&lt;/h3&gt;

&lt;h4 id=&quot;定义索引&quot;&gt;定义索引&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Create [Unique] [Cluster] Index &amp;lt;索引名&amp;gt;
On &amp;lt;表名&amp;gt; (&amp;lt;列名&amp;gt; [次序] [, &amp;lt;列名&amp;gt; [次序]]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;删除索引&quot;&gt;删除索引&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Drop Index &amp;lt;索引名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;视图操作&quot;&gt;视图操作&lt;/h3&gt;

&lt;h4 id=&quot;视图的作用&quot;&gt;视图的作用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;能够简化用户操作&lt;/li&gt;
  &lt;li&gt;使用户能够以多种角度看待同一数据&lt;/li&gt;
  &lt;li&gt;提供了一定程度的逻辑独立性&lt;/li&gt;
  &lt;li&gt;能够对数据图个安全保护&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;定义视图&quot;&gt;定义视图&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Create View &amp;lt;视图名&amp;gt;
[(&amp;lt;列名&amp;gt; [, &amp;lt;列名&amp;gt;] ...)]
As &amp;lt;子查询&amp;gt;
[With Check Option]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;删除视图&quot;&gt;删除视图&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Drop View &amp;lt;视图名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;查询视图&quot;&gt;查询视图&lt;/h4&gt;

&lt;h5 id=&quot;视图消解-view-resolution&quot;&gt;视图消解 (View Resolution)&lt;/h5&gt;

&lt;p&gt;DBMS 执行对视图的查询时，从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正的查询。这一转换的过程称为&lt;strong&gt;视图消解&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;sql-数据更新&quot;&gt;SQL 数据更新&lt;/h3&gt;

&lt;h4 id=&quot;插入数据insert-语句&quot;&gt;插入数据——Insert 语句&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;插入单个元组&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Insert Into &amp;lt;表明&amp;gt; [(&amp;lt;属性列&amp;gt; [{, &amp;lt;属性列&amp;gt;}])]
Values (&amp;lt;值&amp;gt; [{, &amp;lt;值&amp;gt;}])
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;插入子查询结果&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Insert Into &amp;lt;表名&amp;gt; [(&amp;lt;属性列&amp;gt; [{, &amp;lt;属性列&amp;gt;}])]
&amp;lt;子查询&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;修改数据update-语句&quot;&gt;修改数据——Update 语句&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Update &amp;lt;表名&amp;gt;
Set &amp;lt;列名&amp;gt; = &amp;lt;表达式&amp;gt; [{, &amp;lt;列名&amp;gt; = &amp;lt;表达式&amp;gt;}]
[Where &amp;lt;条件&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;删除数据delete-语句&quot;&gt;删除数据——Delete 语句&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Delete From &amp;lt;表名&amp;gt; [Where &amp;lt;条件&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;空值&quot;&gt;空值&lt;/h3&gt;

&lt;h4 id=&quot;空值的运算&quot;&gt;空值的运算&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;空值是“不知道”或“不存在”或“无意义”的值，用 NULL 表示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;属性定义有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNIQUE&lt;/code&gt; 约束以及主属性，都不可取空值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;空值与另一个值的算数运算结果为 NULL，与另一个值的比较运算结果为 UNKWOWN&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TRUE, FALSE, UNKNOWN 的三值逻辑&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;逻辑表达式&lt;/th&gt;
          &lt;th&gt;值&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T AND U&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;U AND U&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;U&lt;/code&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F AND U&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F OR U&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;U OR U&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;U&lt;/code&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T OR U&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT U&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;U&lt;/code&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;空值的判断&quot;&gt;空值的判断&lt;/h4&gt;

&lt;p&gt;判断属性是否为空值，用  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IS NULL&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IS NOT NULL&lt;/code&gt; 来表示&lt;/p&gt;

&lt;h3 id=&quot;sql-数据控制功能&quot;&gt;SQL 数据控制功能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;定义完整性约束条件&lt;/li&gt;
  &lt;li&gt;支持事务操作&lt;/li&gt;
  &lt;li&gt;提供安全控制功能
    &lt;ul&gt;
      &lt;li&gt;授权
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GRANT &amp;lt;权限&amp;gt; [ON &amp;lt;对象类型&amp;gt; &amp;lt;对象名&amp;gt;] TO &amp;lt;用户&amp;gt;&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;收回权限
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REVOKE &amp;lt;权限&amp;gt; [ON &amp;lt;对象类型&amp;gt; &amp;lt;对象名&amp;gt;] FROM &amp;lt;用户&amp;gt;&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;嵌入式-sql-的意义&quot;&gt;嵌入式 SQL 的意义&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;嵌入式 SQL 把 SQL 语句嵌入到高级语言中&lt;/li&gt;
  &lt;li&gt;嵌入式 SQL 把 SQL 的最佳特性与程序设计语言的最佳特性（如过程处理能力）结合起来，使 SQL 功能最强，灵活性更强。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;第六章-关系数据理论&quot;&gt;第六章 关系数据理论&lt;/h1&gt;

&lt;h2 id=&quot;61-问题的提出&quot;&gt;6.1 问题的提出&lt;/h2&gt;

&lt;p&gt;本章中把关系模式看作一个三元组 $R&amp;lt;U, F&amp;gt;$，其中 ：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$R$ 为关系名&lt;/li&gt;
  &lt;li&gt;$U$ 为一组属性&lt;/li&gt;
  &lt;li&gt;$F$ 为属性组 $U$ 上的一组数据依赖&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;

&lt;h4 id=&quot;第一范式&quot;&gt;第一范式&lt;/h4&gt;

&lt;p&gt;每个分量必须是不可分的数据项，满足这个条件的关系模式就属于第一范式 (1NF)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存在的问题&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据冗余&lt;/li&gt;
  &lt;li&gt;更新异常 (update anomalies)&lt;/li&gt;
  &lt;li&gt;插入异常 (insertion anomalies)&lt;/li&gt;
  &lt;li&gt;删除异常 (deletion anomalies)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个好的关系模式应当不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;数据依赖&quot;&gt;数据依赖&lt;/h4&gt;

&lt;p&gt;数据依赖是一个关系内部属性与属性之间的一种约束关系，这种约束关系是通过属性间值的相等与否体现出来的数据间的相关联系。&lt;/p&gt;

&lt;h4 id=&quot;函数依赖-functional-dependency-fd&quot;&gt;函数依赖 (Functional Dependency, FD)&lt;/h4&gt;

&lt;h4 id=&quot;多值依赖-multi-valued-dependency-mvd&quot;&gt;多值依赖 (Multi-Valued Dependency, MVD)&lt;/h4&gt;

&lt;h2 id=&quot;62-规范化&quot;&gt;6.2 规范化&lt;/h2&gt;

&lt;h3 id=&quot;621-函数依赖&quot;&gt;6.2.1 函数依赖&lt;/h3&gt;

&lt;h4 id=&quot;函数依赖&quot;&gt;函数依赖&lt;/h4&gt;

&lt;p&gt;设 $R(U)$ 是属性集 $U$ 上的关系模式，$X$，$Y$ 是 $U$ 的子集，若对于 $R(U)$ 的&lt;strong&gt;任意&lt;/strong&gt;一个可能的关系 $r$，$r$ 中&lt;strong&gt;不可能&lt;/strong&gt;存在两个元组在 $X$ 上的属性值相等，而在 $Y$ 上的属性值不等，则称 &lt;strong&gt;$X$ 函数确定 $Y$ 或 $Y$ 函数依赖于 $X$&lt;/strong&gt;，记作 $X\rightarrow Y$&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;函数依赖和别的数据依赖一样是一个语义范畴的概念，只能根据语义来确定一个函数依赖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;平凡--非平凡函数依赖&quot;&gt;平凡 &amp;amp; 非平凡函数依赖&lt;/h4&gt;

&lt;h5 id=&quot;非平凡函数依赖&quot;&gt;非平凡函数依赖&lt;/h5&gt;

&lt;p&gt;$X\rightarrow Y$，但 $Y\not\subseteq X$，则称 $X\rightarrow Y$ 是&lt;strong&gt;非平凡的函数依赖&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;平凡函数依赖&quot;&gt;平凡函数依赖&lt;/h5&gt;

&lt;p&gt;$X\rightarrow Y$，但 $Y\subseteq X$，则称 $X\rightarrow Y$ 是&lt;strong&gt;平凡的函数依赖&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;完全--部分函数依赖&quot;&gt;完全 &amp;amp; 部分函数依赖&lt;/h4&gt;

&lt;h5 id=&quot;完全函数依赖&quot;&gt;完全函数依赖&lt;/h5&gt;

&lt;p&gt;在 $R(U)$ 中，如果 $X\rightarrow Y$，并且对于 $X$ 的任何一个真子集 $X’$，都有 $X’\not\rightarrow Y$，则称 $Y$ 对 $X$ 是&lt;strong&gt;完全函数依赖&lt;/strong&gt;，记作 $X\overset{F}{\rightarrow}Y$&lt;/p&gt;

&lt;h5 id=&quot;部分函数依赖-partial-functional-dependency&quot;&gt;部分函数依赖 (partial functional dependency)&lt;/h5&gt;

&lt;p&gt;记作 $X\overset{P}{\rightarrow}Y$&lt;/p&gt;

&lt;h4 id=&quot;传递函数依赖-transitive-functional-dependency&quot;&gt;传递函数依赖 (transitive functional dependency)&lt;/h4&gt;

&lt;p&gt;在 $R(U)$ 中，如果 $X\rightarrow Y (Y\not\subseteq X),Y\not\rightarrow X, Y\rightarrow Z, Z\not\subseteq Y$ 则称 $Z$ 对 $X$ &lt;strong&gt;传递函数依赖&lt;/strong&gt;，记为 $X\overset{t}{\rightarrow}Y$ 或 $X\overset{传递}{\rightarrow}Y$&lt;/p&gt;

&lt;h3 id=&quot;622-码&quot;&gt;6.2.2 码&lt;/h3&gt;

&lt;h4 id=&quot;候选码-candidate-key&quot;&gt;候选码 (Candidate key)&lt;/h4&gt;

&lt;p&gt;关系中的某一属性组，若它的值为一标识了一个元组，并具有最小性，则称该属性组位候选码。&lt;/p&gt;

&lt;p&gt;设 $K$ 为 $R&amp;lt;U,F&amp;gt;$ 中的属性或属性组合，若 $K\overset{F}{\rightarrow} U$，则 $K$ 为 $R$ 的候选码 (candidate key)&lt;/p&gt;

&lt;h4 id=&quot;超码&quot;&gt;超码&lt;/h4&gt;

&lt;p&gt;如果 $U$ 函数依赖于 $K$，即 $K\rightarrow U$，则称 $K$ 为超码 (surpkey)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;候选码是一类特殊的超码，即候选码的超集（如果存在）一定是超码，候选码的任何真子集一定不是超码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;主码&quot;&gt;主码&lt;/h4&gt;

&lt;p&gt;若候选码多于一个，则选定其中的一个为主码 (primary key)&lt;/p&gt;

&lt;h4 id=&quot;主属性&quot;&gt;主属性&lt;/h4&gt;

&lt;p&gt;包含在&lt;strong&gt;任何&lt;/strong&gt;一个候选码中的属性称为主属性 (prime attribute)&lt;/p&gt;

&lt;h4 id=&quot;非主属性-非码属性&quot;&gt;非主属性 (非码属性)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;不包含&lt;/strong&gt;在&lt;strong&gt;任何&lt;/strong&gt;一个候选码中的属性称为主属性 (nonprime attribute) 或 (non-key attribute)&lt;/p&gt;

&lt;h4 id=&quot;全码&quot;&gt;全码&lt;/h4&gt;

&lt;p&gt;整个属性组是码&lt;/p&gt;

&lt;h4 id=&quot;外部码-外码&quot;&gt;外部码 (外码)&lt;/h4&gt;

&lt;p&gt;关系模式 $R$ 中属性或属性组 $X$ 并非 $R$ 的码，但 $X$ 是另一个关系模式的码，则称 $X$ 是 $R$ 的外部码 (foreign key)，简称外码。&lt;/p&gt;

&lt;h3 id=&quot;623-范式&quot;&gt;6.2.3 范式&lt;/h3&gt;

&lt;p&gt;关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。&lt;/p&gt;

&lt;p&gt;低一级范式的关系模式可以通过&lt;strong&gt;模式分解&lt;/strong&gt; (schema decomposition) 转化为若干个高一级范式的关系模式的集合，这种过程就叫&lt;strong&gt;规范化&lt;/strong&gt; (normalization)。&lt;/p&gt;

&lt;h3 id=&quot;624-2nf&quot;&gt;6.2.4 2NF&lt;/h3&gt;

&lt;p&gt;若 $R\in$ 1NF，并且&lt;strong&gt;每一个&lt;/strong&gt;非主属性&lt;strong&gt;完全函数依赖&lt;/strong&gt;于&lt;strong&gt;任何&lt;/strong&gt;一个候选码，则 $R\in$ 2NF&lt;/p&gt;

&lt;p&gt;不属于 2NF 的问题&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插入异常&lt;/li&gt;
  &lt;li&gt;删除异常&lt;/li&gt;
  &lt;li&gt;修改复杂&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;625-3nf&quot;&gt;6.2.5 3NF&lt;/h3&gt;

&lt;p&gt;设关系模式 $R&amp;lt;U,F&amp;gt;\in$ 1NF，若 $R$ 中不存在这样的码 $X$，属性组 $Y$ 及非主属性 $Z (Z\not\subseteq Y)$ 使得 $X\rightarrow Y$，$Y\rightarrow Z$ 成立，$Y\not\rightarrow X$，则称 $R&amp;lt;U, F&amp;gt;\in$ 3NF&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;若 $R\in$ 3NF，则每一个非主属性既不转递依赖于码（任意一个候选码），也不部分依赖于码，也不部分依赖于码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;626-bcnf&quot;&gt;6.2.6 BCNF&lt;/h3&gt;

&lt;p&gt;关系模式 $R&amp;lt;U, F&amp;gt;\in$ 1NF，若 $X\rightarrow Y$ 且 $Y\not\subseteq X$ 时 $X$ 必含有码，则 $R&amp;lt;U, F&amp;gt;\in$ BCNF&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关系模式 $R&amp;lt;U, F&amp;gt;$ 中，若每一个决定因素都包含码，则 $R&amp;lt;U,F&amp;gt;\in BCNF$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;627-多值依赖&quot;&gt;6.2.7 多值依赖&lt;/h3&gt;

&lt;h4 id=&quot;多值依赖的定义&quot;&gt;多值依赖的定义&lt;/h4&gt;

&lt;p&gt;设 $R(U)$ 是属性集 $U$ 上的一个关系模式。$X$，$Y$，$Z$ 是 $U$ 的子集，并且 $Z=U-X-Y$。关系模式 $R(U)$ 中多值依赖 $X\rightarrow\rightarrow Y$ 成立，当且仅当对 $R(U)$ 的任一关系 $r$，给定的一对 $(x,z)$ 值，有一组 $Y$ 值，这组值仅仅决定于 $x$ 值而与 $z$ 值无关。&lt;/p&gt;

&lt;h4 id=&quot;多值依赖的性质&quot;&gt;多值依赖的性质&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;多值依赖具有&lt;strong&gt;对称性&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;若 $X\rightarrow\rightarrow Y$，则 $X\rightarrow\rightarrow Z$，其中 $Z=U-X-Y$&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;多值依赖具有&lt;strong&gt;传递性&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;若 $X\rightarrow\rightarrow Y$， $Y\rightarrow\rightarrow Z$，则 $X\rightarrow\rightarrow Z-Y$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数依赖可以看作是多值依赖的特殊情况&lt;/p&gt;

    &lt;p&gt;若 $X\rightarrow Y$，则 $X\rightarrow\rightarrow Y$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若 $X\rightarrow\rightarrow Y$，$X\rightarrow\rightarrow Z$，则 $X\rightarrow\rightarrow YZ$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若 $X\rightarrow\rightarrow Y$，$X\rightarrow\rightarrow Z$，则 $X\rightarrow\rightarrow Y\cap Z$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若 $X\rightarrow\rightarrow Y$，$X\rightarrow\rightarrow Z$，则 $X\rightarrow\rightarrow Y-Z$，$X\rightarrow\rightarrow Z-Y$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;多值依赖与函数依赖的区别&quot;&gt;多值依赖与函数依赖的区别&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;多值依赖的有效性与属性集的范围有关&lt;/li&gt;
  &lt;li&gt;若函数依赖 $X\rightarrow Y$ 在 $R(U)$ 上成立，则对于任何 $Y’\subset Y$ 均有 $X\rightarrow Y’$ 成立。而多值依赖 $X\rightarrow\rightarrow Y$ 若在 $R(U)$ 上成立，却不能断言对于任何 $Y’\sub Y$ 有 $X\rightarrow\rightarrow Y’$ 成立。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;628-4nf&quot;&gt;6.2.8 4NF&lt;/h3&gt;

&lt;p&gt;关系模式 $R&amp;lt;U,F&amp;gt;\in 1NF$，如果对于 $R$ 的每个非平凡多值依赖 $X\rightarrow\rightarrow Y(Y\not\subseteq X)$，$X$ 都包含码，则称 $R&amp;lt;U,F&amp;gt;\in$ 4NF&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;4NF 就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;629-规范化小结&quot;&gt;6.2.9 规范化小结&lt;/h3&gt;

&lt;p&gt;规范化的基本思想就是逐步消除数据依赖中不合适的部分，即“一事一地”的模式设计原则。规范化实质上是概念的&lt;strong&gt;单一化&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/normalization.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关系模式的规范化过程是通过对关系模式的分解来实现的，即把低一级的关系模式分解为若干个高一级的关系模式。这种分解不是唯一的。&lt;/p&gt;

&lt;h2 id=&quot;63-数据依赖的公理系统&quot;&gt;6.3 数据依赖的公理系统&lt;/h2&gt;

&lt;h3 id=&quot;逻辑蕴含&quot;&gt;逻辑蕴含&lt;/h3&gt;

&lt;p&gt;对于满足一组函数依赖 F 的关系模式 $R&amp;lt;U,F&amp;gt;$，其任何一个关系 $r$，若函数依赖 $X\rightarrow Y$ 都成立（即 $r$ 中任意两元组 $t$、$s$，若 $t[X]=s[X]$，则 $t[Y]=s[Y]$），则称 F &lt;strong&gt;逻辑蕴含&lt;/strong&gt; $X\rightarrow Y$&lt;/p&gt;

&lt;h3 id=&quot;armstrong-公理系统-armstrongs-axiom&quot;&gt;Armstrong 公理系统 (Armstrong’s axiom)&lt;/h3&gt;

&lt;p&gt;设 $U$ 为属性集总体，$F$ 是 $U$ 上的一组函数依赖，于是又关系模式 $R&amp;lt;U,F&amp;gt;$，对 $R&amp;lt;U,F&amp;gt;$ 来说有以下的推理规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;自反律&lt;/strong&gt; (reflexivity rule)&lt;/p&gt;

    &lt;p&gt;若 $Y\subseteq X\subseteq U$，则 $X\rightarrow Y$ 为 $F$ 所蕴含。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;增广律&lt;/strong&gt; (augmentation rule)&lt;/p&gt;

    &lt;p&gt;若 $X\rightarrow Y$ 为 $F$ 所蕴含，且 $Z\subseteq U$，则 $XZ\rightarrow YZ$ 为 $F$ 所蕴含。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;传递律&lt;/strong&gt; (transitivity rule)&lt;/p&gt;

    &lt;p&gt;若 $X\rightarrow Y$ 及 $Y\rightarrow Z$ 为 $F$ 所蕴含，则 $X\rightarrow Z$ 为 $F$ 所蕴含。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Armstrong 公理系统是&lt;strong&gt;有效&lt;/strong&gt;的，&lt;strong&gt;完备&lt;/strong&gt;的。&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;有效性&lt;/p&gt;

      &lt;p&gt;由 $F$ 出发根据 Armstrong 公理推导出来的每一个函数依赖一定在 $F^+$ 中&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;完备性&lt;/p&gt;

      &lt;p&gt;$F^+$ 中的每一个函数依赖，必定可以由 $F$ 出发根据 Armstrong 公理推导出来&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;推理规则&quot;&gt;推理规则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;合并规则&lt;/strong&gt; (union rule)&lt;/p&gt;

    &lt;p&gt;由 $X\rightarrow Y$，$X\rightarrow Z$，有 $X\rightarrow YZ$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;伪传递规则&lt;/strong&gt; (pseudo transitivity rule)&lt;/p&gt;

    &lt;p&gt;由 $X\rightarrow Y$，$WY\rightarrow Z$，有 $XW\rightarrow Z$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;分解规则&lt;/strong&gt; (decomposition rule)&lt;/p&gt;

    &lt;p&gt;由 $X\rightarrow Y$ 及 $Z\subseteq Y$，有 $X\rightarrow Z$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;引理&quot;&gt;引理&lt;/h3&gt;

&lt;p&gt;$X\rightarrow A_1A_2…A_k$ 成立的充分必要条件是 $X\rightarrow A_i(i=1,2,…,k)$ 成立&lt;/p&gt;

&lt;h3 id=&quot;闭包-closure&quot;&gt;闭包 (closure)&lt;/h3&gt;

&lt;p&gt;在关系模式 $R&amp;lt;U,F&amp;gt;$ 中为 $F$ 所逻辑蕴含的函数依赖的全体叫做 $F$ 的闭包，记为 $F^+$&lt;/p&gt;

&lt;h3 id=&quot;属性集关于函数依赖的闭包&quot;&gt;属性集关于函数依赖的闭包&lt;/h3&gt;

&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;设 $F$ 为属性集 $U$ 上的一组函数依赖，$X$、$Y\subseteq U$，$X_F^+={A&lt;/td&gt;
      &lt;td&gt;X\rightarrow A 能由 F 根据 Armstrong 公理导出}$，$X_F^+$ 称为属性集 $X$ 关于函数依赖集 $F$ 的闭包。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;算法&quot;&gt;算法&lt;/h4&gt;

&lt;p&gt;求属性集 $X(X\subseteq U)$ 关于 $U$ 上的函数依赖集 $F$ 的闭包 $X_F^+$&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;输入：$X$、$F$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输出：$S_F^+$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;令 $X^{0} = X$, $i=0$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;求 $B$，这里  $B = {A&lt;/td&gt;
          &lt;td&gt;(\exists V)(\exists W)(V\rightarrow W\in F\wedge X\subseteq X^{(i)}\wedge A\in W)}$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$X^{(i+1)}=B\cup X^{(i)}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断 $X^{(i+1)} = X^{(i)}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若 $X^{(i+1)}$ 与 $X^{(i)}$ 相等或 $X^{(i)} = U$，则 $X^{(i)}$ 就是 $X_F^+$，算法终止&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;若否，则 $i=i+1$，返回第二步&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;引理-1&quot;&gt;引理&lt;/h3&gt;

&lt;p&gt;设 $F$ 为属性集 $U$ 上的一组函数依赖，$X$、$Y\subseteq U$，$X\rightarrow Y$ 能由 $F$ 根据 Armstrong 公理导出的充分必要条件是 $Y\subseteq X_F^+$。&lt;/p&gt;

&lt;h3 id=&quot;定理&quot;&gt;定理&lt;/h3&gt;

&lt;p&gt;Armstrong 公理系统的有效的、完备的&lt;/p&gt;

&lt;h3 id=&quot;等价--覆盖&quot;&gt;等价 / 覆盖&lt;/h3&gt;

&lt;h4 id=&quot;定义-1&quot;&gt;定义&lt;/h4&gt;

&lt;p&gt;如果 $G^+ = F^+$，就说函数依赖集 $F$ 覆盖 $G$ 或 $F$ 与 $G$ 等价。&lt;/p&gt;

&lt;h4 id=&quot;定理-1&quot;&gt;定理&lt;/h4&gt;

&lt;p&gt;$G^+=F^+$ 的充分必要条件是 $G^+\subseteqF^+$ 和 $G^+ \subseteq F^+$&lt;/p&gt;

&lt;h3 id=&quot;最小依赖集-minimal-cover&quot;&gt;最小依赖集 (minimal cover)&lt;/h3&gt;

&lt;h4 id=&quot;定义-2&quot;&gt;定义&lt;/h4&gt;

&lt;p&gt;如果函数依赖集 $F$ 满足下列条件，则称 $F$ 为一个极小函数依赖集，亦称为&lt;strong&gt;最小依赖集&lt;/strong&gt;或&lt;strong&gt;最小依赖&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$F$ 中任一函数依赖的右部仅含有一个属性。&lt;/li&gt;
  &lt;li&gt;$F$ 中不存在这样的函数依赖 $X\rightarrow A$，使得 $F$ 与 $F-{X\rightarrow A}$ 等价&lt;/li&gt;
  &lt;li&gt;$F$ 中不存在这样的函数依赖 $X\rightarrow A$，$X$ 有真子集 $Z$ 使得 $F-{X\rightarrow A}\cup{Z\rightarrow A}$ 与 $F$ 等价&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;算法-1&quot;&gt;算法&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;逐一检查 $F$ 中各函数依赖  $FD_i:X\rightarrow Y$，若 $Y=A_1A_2…A_k,k\ge 2$，则用 ${X\rightarrow A_j&lt;/td&gt;
          &lt;td&gt;j=1,2,…,k$ 来取代 $X\rightarrow Y$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;逐一检查 $F$ 中各函数依赖 $FD_i:X\rightarrow A$，令 $G=F-{X\rightarrow A}$，若 $A\inX_G^+$，则从 $F$ 中去掉此函数依赖（因为 $F$ 与 $G$ 等价的充要条件是 $A\in X_G^+$）&lt;/li&gt;
  &lt;li&gt;逐一去除 $F$ 中各函数依赖 $FD_i:X\rightarrow A$，设 $X=B_1B_2…B_m,m\ge 2$，逐一考查 $B_i(i=1,2,…,m)$，若 $A\in(X-B_i)_F^+$，则以 $X\rightarrow B_i$ 取代 $X$（因为 $F$ 与 $F-{X\rightarrow A}\cup {Z\rightarrow A}$ 等价的充要条件是 $A\in Z^+$，其中 $Z=X-B_i$）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;64-模式分解&quot;&gt;6.4 模式分解&lt;/h2&gt;

&lt;h1 id=&quot;第七章-数据库设计&quot;&gt;第七章 数据库设计&lt;/h1&gt;

&lt;h2 id=&quot;71-数据库设计概述&quot;&gt;7.1 数据库设计概述&lt;/h2&gt;

&lt;p&gt;数据库设计是指对于一个给定的应用环境，构造（设计）优化数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据库设计的方法
    &lt;ul&gt;
      &lt;li&gt;手工试凑法（直接设计法）：根据应用的数据要求于处理要求，直接涉及数据库的结构。&lt;/li&gt;
      &lt;li&gt;规范设计法：运用软件工程的思想和方法，把整个设计过程划分为若干阶段，把复杂的大问题分为若干相对简单的小问题，每个阶段只解决整个设计中的部分问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;711-数据库设计的特点&quot;&gt;7.1.1 数据库设计的特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;数据库建设的基本规律&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;的收集、整理、组织和不断更新是数据库建设中的重要环节。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结构（数据）设计和行为（处理）设计相结合&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;713-数据库设计的基本步骤&quot;&gt;7.1.3 数据库设计的基本步骤&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;需求分析&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;数据库设计的&lt;strong&gt;基础&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;对应用环境进行详细调查。收集支持系统目标的基础数据及其处理。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;概念结构设计&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;数据库设计的&lt;strong&gt;关键&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;通过对用户需求进行综合、归纳与抽象。形成独立于数据库逻辑结构于具体 DBMS 的概念模型，可以用 E-R 图等表示。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;逻辑结构设计&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;将概念结构转换为某个 DBMS 所支持的数据模型，并进行优化。再将得到的逻辑结构转换成特定的 DBMS 能处理的模式、子模式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;物理结构设计&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;为逻辑数据模型选取一个最适合应用环境的物理结构（包括存取结构和存取方法）&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;设计数据库在物理设备上的存储结构和存取方法。一般分为两步：一是确定数据库的内模式；二是对物理结构进行时间与空间效率的评价&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;数据库实施&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;运用数据库管理系统提供的数据库语言及其宿主语言，根据逻辑设计和物理设计的结果建立数据库，编写和调试应用程序，组织数据入库，并进行试运行。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;是建立数据库的过程。用 DBMS 的 DDL 描述三级模式，并调试产生目标模式。开发应用程序，组织数据入库并试运行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;数据库运行和维护&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;数再运行过程中需要不断对其进行评估、调整与修改。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在数据库正式运行后，由 DBA 执行对数据库经常性的维护工作，包括数据库转储与恢复、对数据库控制、数据库性能监控、数据库的重组与重构。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;714-数据库设计过程中的各级模式&quot;&gt;7.1.4 数据库设计过程中的各级模式&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/schema.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;72-需求分析&quot;&gt;7.2 需求分析&lt;/h2&gt;

&lt;h3 id=&quot;721-需求分析的任务&quot;&gt;7.2.1 需求分析的任务&lt;/h3&gt;

&lt;p&gt;调查的重点是“数据”和“处理”，通过调查、收集与分析，获得用户对数据库的如下要求：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;信息要求：指系统中所涉及的数据及数据之间的联系。具体收集数据的名称、类型、长度等，确定数据之间联系的类型。&lt;/li&gt;
  &lt;li&gt;处理要求： 指用户要完成什么处理功能，对处理的响应时间和处理方式的要求。&lt;/li&gt;
  &lt;li&gt;安全性与完整性要求&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;722-需求分析的方法&quot;&gt;7.2.2 需求分析的方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;首先调查用户的实际要求，与用户达成共识&lt;/li&gt;
  &lt;li&gt;分析与表达这些需求。
    &lt;ul&gt;
      &lt;li&gt;用数据流图表达数据和处理之间的关系&lt;/li&gt;
      &lt;li&gt;用数据字典描述系统中的各类数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;数据流图-data-flow-diagram-dfd-图&quot;&gt;数据流图 （Data Flow Diagram, DFD 图）&lt;/h4&gt;

&lt;p&gt;以图形方式来表达系统的功能、数据在系统内部的逻辑流向和逻辑变换过程。&lt;/p&gt;

&lt;h4 id=&quot;数据字典&quot;&gt;数据字典&lt;/h4&gt;

&lt;p&gt;是对数据的集中的系列说明。包含每一个数据元素的名字、含义等各方面的描述。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从数据流图中提取出所有原子数据项&lt;/li&gt;
  &lt;li&gt;把有联系的数据项组合起来形成数据组&lt;/li&gt;
  &lt;li&gt;以数据组为单位，写出数据项的如下定义：
    &lt;ul&gt;
      &lt;li&gt;语义定义：名字，实际含义等&lt;/li&gt;
      &lt;li&gt;类型定义：数据类型，数据宽度，小位数等&lt;/li&gt;
      &lt;li&gt;完整性约束定义：值约束、空值约束以及其他比较复杂的完整性约束。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;根据用户和实际领域的信息模型需要补充其他数据项及其定义。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;723-数据字典&quot;&gt;7.2.3 数据字典&lt;/h3&gt;

&lt;p&gt;数据字典是进行详细的数据收集和数据分析所获得的主要成果。它是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是再需求分析阶段建立，在数据库设计过程中不断修改、充实和完善的。它在数据库设计中占有很重要的地位。&lt;/p&gt;

&lt;p&gt;数据字典包括：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;数据项&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据流&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据存储&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;处理过程&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;73-概念结构设计&quot;&gt;7.3 概念结构设计&lt;/h2&gt;

&lt;h3 id=&quot;e-r-图&quot;&gt;E-R 图&lt;/h3&gt;

&lt;h5 id=&quot;e-r-图的组成&quot;&gt;E-R 图的组成&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;实体&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;用&lt;strong&gt;长方形&lt;/strong&gt;表示实体型，在框内写上实体名&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;联系&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;用&lt;strong&gt;菱形&lt;/strong&gt;表示实体间的联系，菱形框内写上联系名。用无向边把菱形分别与有关实体相连，在无向边旁标上联系的类型。若联系也具有属性，则属性和菱形也能用无向边连接上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;用&lt;strong&gt;椭圆形&lt;/strong&gt;表示实体的属性，并用无向边把实体于其属性连接起来。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;原则&quot;&gt;原则&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;属性必须是不可分的数据项，不能是另一些属性的聚集&lt;/li&gt;
  &lt;li&gt;属性不能与其它实体具有联系，即 E-R 图中所表示的联系是实体之间的联系&lt;/li&gt;
  &lt;li&gt;实体和描述它的属性之间保持 1:1 或 n:1 的联系。对于 1:n 或 n:m 的联系，要进行调整，一般可将该属性上升为实体。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;局部-e-r-图设计步骤&quot;&gt;局部 E-R 图设计步骤&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;选择局部应用&lt;/li&gt;
  &lt;li&gt;以需求分析中得到的数据元素表为基础，利用数据抽象机制，建立实体模型&lt;/li&gt;
  &lt;li&gt;确定实体之间的联系类型。用 E-R 图表示这些实体与实体之间的联系，形成分 E-R 图&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;综合分-e-r-图形成总-e-r-图&quot;&gt;综合分 E-R 图形成总 E-R 图&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;多个分 E-R 图一次集成&lt;/li&gt;
  &lt;li&gt;逐步集成，用累加的方式一次集成两个分 E-R 图&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;集成局部-e-r-图的步骤&quot;&gt;集成局部 E-R 图的步骤&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;合并&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;解决各分 E-R 图之间的冲突，将各分 E-R 图合并起来生成&lt;strong&gt;初步 E-R 图&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;冲突&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;属性冲突&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;属性的类型、取值范围或取值集合不同，或属性取值单位冲突&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;解决：讨论协商解决&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;命名冲突&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;包括属性名、实体名、联系名之间的同名异义，异名同义&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;解决：建立命名表，统一命名，异名同义的名字可标为别名&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;结构冲突&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;同一对象在不同应用中有不同抽象&lt;/p&gt;

            &lt;blockquote&gt;
              &lt;p&gt;解决：遵守实体与属性的划分原则，把属性变为实体或实体变为属性，使同一对象具有相同的抽象。&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;同一实体在不同分 E-R 图中属性个数、次序不同&lt;/p&gt;

            &lt;blockquote&gt;
              &lt;p&gt;解决：同一实体的属性通常取分 E-R 图中属性的并，再适当调整次序&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;实体之间的联系在不同分 E-R 图中呈现不同类型&lt;/p&gt;

            &lt;blockquote&gt;
              &lt;p&gt;解决：根据语义加以综合或调整&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;修改和重构&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;消除不必要的冗余，生成&lt;strong&gt;基本 E-R 图&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;消除冗余&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;分析法&lt;/li&gt;
      &lt;li&gt;规范化方法
        &lt;ol&gt;
          &lt;li&gt;把 E-R 图中实体用符号表示&lt;/li&gt;
          &lt;li&gt;把每一对 n:1、1:1 或 n:m 联系表示为实体码之间的函数依赖表达式 X $\rightarrow$ Y&lt;/li&gt;
          &lt;li&gt;利用函数依赖集的最小覆盖算法进行极小化处理。&lt;/li&gt;
          &lt;li&gt;考察 D 中每一个函数依赖表达式，确定是否为冗余联系&lt;/li&gt;
          &lt;li&gt;去掉冗余联系后形成基本 E-R 图。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;74-逻辑结构设计&quot;&gt;7.4 逻辑结构设计&lt;/h2&gt;

&lt;p&gt;逻辑结构设计的任务就是把概念结构转换为选用的 DBMS 所支持的数据模型的过程。&lt;/p&gt;

&lt;h3 id=&quot;过程&quot;&gt;过程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;形成初始关系数据库模式&lt;/li&gt;
  &lt;li&gt;关系模式规范化&lt;/li&gt;
  &lt;li&gt;关系模式优化&lt;/li&gt;
  &lt;li&gt;子模式定义&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;e-r-图向关系模型的转换规则&quot;&gt;E-R 图向关系模型的转换规则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;一个实体型转换为一个关系模式。实体的属性就是关系的属性，实体的码就是关系的码。&lt;/li&gt;
  &lt;li&gt;一个联系转换为一个关系模式。与该联系相连的各实体的码以及联系的属性转换为关系的属性：
    &lt;ul&gt;
      &lt;li&gt;若联系为 1:1，则每个关系的码均是该关系的候选码&lt;/li&gt;
      &lt;li&gt;若联系为 1:n，则该关系的码是 n 端实体的码&lt;/li&gt;
      &lt;li&gt;若联系为 n:m，则该关系的码是诸实体码的组合&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;三个或三个以上实体间的多元联系，转换为一个关系模式，与该多元联系相连的各实体的码以及联系的属性转换为关系的属性，而关系的码为各实体码的组合&lt;/li&gt;
  &lt;li&gt;具有相同码的关系可以合并&lt;/li&gt;
  &lt;li&gt;弱实体类型的转换
    &lt;ul&gt;
      &lt;li&gt;对于每个弱实体类型，创建一个新的关系，该关系中包含所有弱实体类型的属性。&lt;/li&gt;
      &lt;li&gt;把标识关系（被依赖关系）的主码添加到新关系中，并将其作为新关系的外码&lt;/li&gt;
      &lt;li&gt;新关系的主码是标识关系的主码和弱实体类型的部分标识（码）的组合&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;超类 / 子类联系的转换
    &lt;ul&gt;
      &lt;li&gt;为超类和每个子类创建单独的关系&lt;/li&gt;
      &lt;li&gt;在超类所创建的关系中，包含所有子类成员都共有的属性，包括主码&lt;/li&gt;
      &lt;li&gt;在超类中包含一个（或多个）属性作为子类判定符&lt;/li&gt;
      &lt;li&gt;在为每个子类所创建的关系中，包含超类的主码以及子类特有的属性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;关系模型的规范化与优化&quot;&gt;关系模型的规范化与优化&lt;/h3&gt;

&lt;h4 id=&quot;规范化&quot;&gt;规范化&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;按照数据依赖的理论，逐一分析转换所得关系模式，判断是否存在部分函数依赖、传递函数依赖、多值依赖等，确定它们的范式等级&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;优化&quot;&gt;优化&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;按应用系统的处理要求，确定是否进行关系模式合并或分解&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为了提高存取效率和存储空间的利用率，可以对关系模式进行必要的分解&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;水平分解&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;是把关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统效率&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;80/20 原则&lt;/p&gt;

            &lt;p&gt;可以把经常使用的那一部分数据分解出来作为一个关系，其他数据作为另一个关系&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;数据分片&lt;/p&gt;

            &lt;p&gt;如果关系 R 上具有 n 个事务，而且大多数事务存取的数据不相交，则 R 可以分解为少于或等于 n 个子关系。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;垂直分解&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;是把关系模式 R 的属性分解为若干子集合，形成若干子关系模式，&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;垂直分解的原则是，经常在一起使用的属性从 R 中分解出来形成一个子关系模式&lt;/li&gt;
          &lt;li&gt;垂直分解必须确保无损连接性和保持函数依赖。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;75-物理结构设计&quot;&gt;7.5 物理结构设计&lt;/h2&gt;

&lt;h3 id=&quot;确定数据库的存储结构&quot;&gt;确定数据库的存储结构&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;确定存放位置
    &lt;ul&gt;
      &lt;li&gt;经常存取部分和存取频率较低部分分开存放&lt;/li&gt;
      &lt;li&gt;数据和日志备份放于不同的磁盘上&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;确定系统配置
    &lt;ul&gt;
      &lt;li&gt;确定系统配置变量、存储分配参数，进行物理优化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;选择关系的存取方法&quot;&gt;选择关系的存取方法&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;存取方法是使事务能够快速存取数据库中数据的技术&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;索引方法&quot;&gt;索引方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;基本概念
    &lt;ul&gt;
      &lt;li&gt;为了加速所需数据的访问&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;索引记录 / 索引项&lt;/strong&gt;，是索引文件的记录，包括两个域：
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;索引域&lt;/strong&gt;：存储数据文件中一个或一组域的一个值&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;指针&lt;/strong&gt;：指向索引域值为 K 的记录所在磁盘块的地址&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常用 B+ 树索引&lt;/li&gt;
  &lt;li&gt;索引存取方法的选择
    &lt;ul&gt;
      &lt;li&gt;选择索引域原则
        &lt;ul&gt;
          &lt;li&gt;经常在查询条件中出现的属性&lt;/li&gt;
          &lt;li&gt;经常作为最大值和最小值库函数的参数&lt;/li&gt;
          &lt;li&gt;经常作为连接属性&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;索引并非越多越好&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;聚集方法&quot;&gt;聚集方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;基本概念
    &lt;ul&gt;
      &lt;li&gt;把关系中某个属性 / 组（聚集键）值相同的记录集中存放在连续的物理块，称为&lt;strong&gt;聚集&lt;/strong&gt;。能够提高该属性的查询速度。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一个关系只能参加一个聚集&lt;/li&gt;
  &lt;li&gt;一般原则
    &lt;ul&gt;
      &lt;li&gt;经常进行连接操作的关系可以建立聚集&lt;/li&gt;
      &lt;li&gt;单个关系的某组属性经常进行相等比较&lt;/li&gt;
      &lt;li&gt;关系的某个属性组值重复率高&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;注意问题
    &lt;ul&gt;
      &lt;li&gt;建立和维护聚集系统开销很大，对于更新操作远远多余连接操作的关系不应该使用聚集方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hash-方法&quot;&gt;HASH 方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;一种支持快速存取的文件存储方法&lt;/li&gt;
  &lt;li&gt;基本概念
    &lt;ul&gt;
      &lt;li&gt;通过 HASH 函数将记录关键字转换成地址&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果关系的属性主要出现在等连接条件中，或出现在相等比较条件中，而且满足以下条件之一，可以选择该方法：
    &lt;ul&gt;
      &lt;li&gt;关系的大小可预知，而且不变&lt;/li&gt;
      &lt;li&gt;如果关系大小动态改变，则徐 DBMS 提供动态 HASH 存取方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;第六章-存储管理和索引&quot;&gt;第六章 存储管理和索引&lt;/h1&gt;

&lt;h2 id=&quot;存储体系结构&quot;&gt;存储体系结构&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;数据只有被放入&lt;strong&gt;内存&lt;/strong&gt;才能被处理&lt;/li&gt;
    &lt;li&gt;DBMS 设定数据库的基本存储是在磁盘上，DBMS 的组件管理内存与外存数据的交换&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DBMS 存储管理的目标&lt;/p&gt;

    &lt;p&gt;最小化磁盘和主存间传输存储块的数量，即最小化磁盘存取次数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;磁盘&quot;&gt;磁盘&lt;/h3&gt;

&lt;h4 id=&quot;结构&quot;&gt;结构&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;磁盘块&lt;/strong&gt;由若干个扇区组成，是&lt;strong&gt;存储分配和检索的逻辑单元&lt;/strong&gt;，大小一般在 4k-16k 之间，数据以&lt;strong&gt;块&lt;/strong&gt;为单位在磁盘和主存之间传输。页面 (page) 通常指块。&lt;/p&gt;

&lt;h4 id=&quot;访问时间&quot;&gt;访问时间&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;寻道时间&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;磁盘臂定位时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;旋转时间&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;等待被访问的扇区出现在读写头下方的时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;传输时间&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;从磁盘读取数据或向磁盘存储数据的时间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;存储管理系统&quot;&gt;存储管理系统&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;数据库 - 文件 - 块 / 页&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;数据库&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;由若干文件组成，这些文件采用专有的格式。操作系统不能获取这些文件内容的任何信息&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;文件&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;由若干个定长的存储单元 / 存储块 / 页构成&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;块 / 页&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;存储分配和数据传输的单位&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据库的物理结构&quot;&gt;数据库的物理结构&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;数据库中的&lt;strong&gt;表&lt;/strong&gt;被映射为底层存储中的&lt;strong&gt;文件&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个&lt;strong&gt;文件&lt;/strong&gt;在逻辑上被组织为&lt;strong&gt;记录&lt;/strong&gt;的序列，记录被映射到&lt;strong&gt;磁盘块&lt;/strong&gt;上&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;文件&lt;/strong&gt;在存储中由若干&lt;strong&gt;磁盘块&lt;/strong&gt;构成，&lt;strong&gt;块是存储分配和数据传输的单位&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个&lt;strong&gt;块&lt;/strong&gt;可以包含几个&lt;strong&gt;记录&lt;/strong&gt;，每条&lt;strong&gt;记录&lt;/strong&gt;被完全包含在单个块中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表所占磁盘块的分配方法&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;连续分配&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;数据被分配到连续的磁盘块上&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;链接分配&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;数据块中包含指向下个数据块的指针&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;按簇分配&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;簇是连续的几个磁盘块，簇之间用指针连接&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;索引分配&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;索引块中存放指向数据块的指针&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数据库页--磁盘块&quot;&gt;数据库页 / 磁盘块&lt;/h4&gt;

&lt;p&gt;页是固定大小的数据块&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个页有唯一的标识符 (ID)，DBMS 将页 ID 映射为页的物理位置&lt;/li&gt;
  &lt;li&gt;每个页由头部 Header 和数据组成
    &lt;ul&gt;
      &lt;li&gt;Header 包含了页中的元数据，如页大小、Checksum、DBMS 版本等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;分槽-slot-页结构&quot;&gt;分槽 (slot) 页结构&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;Header 记录了已使用的槽数，以及最后一个被使用槽的起始位置偏移量，以及一个槽数组&lt;/li&gt;
  &lt;li&gt;槽数组保存了每个元组的起始位置偏移量&lt;/li&gt;
  &lt;li&gt;增加记录时，槽数组从开始到尾部的方向增长，而记录数据则从数据区的尾部到开始的方向增长。当槽数组与元组数据连接到一起时，认为页满&lt;/li&gt;
  &lt;li&gt;便于存储变长记录&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数据库记录&quot;&gt;数据库记录&lt;/h4&gt;

&lt;p&gt;记录是字节序列，DBMS 负责将该序列解释为属性类型和值&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;记录头部&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;包含元组的元数据，例如加锁信息等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;记录数据&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;属性的实际数据。属性一般按表定义中的顺序存储。多数 DBMS 不允许一个记录大小超过一个页&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;唯一标识符 ID&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;每个记录被分配了一个 ID&lt;/li&gt;
      &lt;li&gt;最常见的形式：页 ID+ (offset 或槽)&lt;/li&gt;
      &lt;li&gt;应用程序不能依赖该 ID 进行唯一性标识&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;文件中记录的组织方式&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;(Heap)：记录可以存放在文件空间中的任何位置&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;链表方式&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;在文件开始维护一个 header 页，该页存储了空白页链表头指针和数据页链表头指针，每个页记录了当前包含的空槽数&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;页目录方式&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;DBMS 维护特殊页保存文件中的数据页的位置，并记录每个页中空槽数&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;顺序&lt;/strong&gt;(Sequential)：基于每个记录的搜索码值顺序排列&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;文件中记录按搜索码排序。&lt;strong&gt;搜索码&lt;/strong&gt;可以是任意属性或属性集合&lt;/li&gt;
      &lt;li&gt;通过指针把记录链接起来，每个记录的指针指向按搜索码排列的下一条记录&lt;/li&gt;
      &lt;li&gt;可以高效的按某个搜索码处理记录&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;索引&lt;/strong&gt;(Indexing)：按某种顺序有序存储&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;散列&lt;/strong&gt; (Hashing)：在搜索码上的 hash 函数，计算出记录在文件中存放的块&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;聚集&lt;/strong&gt;(Clustering)：将有联系的记录存储在同一个块上，以最小化 I/O 次数&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;具有相同或相似属性值的记录存储于连续的磁盘块中&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;聚集码&lt;/strong&gt;是一种属性，它定义了哪些记录被存储在一起&lt;/li&gt;
      &lt;li&gt;多表聚集：将多个关系存储于一个文件中，在每个块中存储两个或更多关系的相关记录，可以加快特定的连接查询，但会使单个表的访问变慢&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;缓存管理系统&quot;&gt;缓存管理系统&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;块 / 页是存储分配和数据交换的单位&lt;/li&gt;
  &lt;li&gt;管理目标：最小化磁盘和主存间传输存储块的数量，即最小化磁盘存取次数；实现手段是在主存中保持尽量多的块&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;缓冲区&lt;/strong&gt;：是主存中可以存储磁盘块副本的区域&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;缓存管理器&lt;/strong&gt;：负责缓存空间分配，内外存交换&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;缓冲区组织与管理&quot;&gt;缓冲区组织与管理&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;缓冲区被组织为一个固定大小的页面数组，每个元素称为帧，存放磁盘上的一个页 / 块&lt;/li&gt;
  &lt;li&gt;缓冲区元数据——页表 (page table)，跟踪当前内存中的所有页，并保存了每个页的元数据，包括
    &lt;ul&gt;
      &lt;li&gt;Dirty Flag：由修改页的线程设置，通知存储管理器该页必须写回磁盘&lt;/li&gt;
      &lt;li&gt;Pin / Reference 计数器：在一页被进程读写操作前要钉住 (Pin)，方式该页被移出，操作结束后解除钉（计数器减 1），只有计数器 = 0 时，才能被移出或写回磁盘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓冲区的共享锁与排它锁
    &lt;ul&gt;
      &lt;li&gt;缓冲区管理器提供封锁系统，允许数据库进程以共享或排他模式封锁页，在完成操作后释放封锁&lt;/li&gt;
      &lt;li&gt;实现并发控制，读操作加共享锁，更新操作加排他锁&lt;/li&gt;
      &lt;li&gt;加锁规则：一次只能由一个进程获得排它锁，共享锁与排它锁不能同时加，多个进程可以同时持有共享锁&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓冲区替换策略
    &lt;ul&gt;
      &lt;li&gt;最近最少使用 (LRU, Least Recently Used) 策略及其改进算法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;索引&quot;&gt;索引&lt;/h4&gt;

&lt;h5 id=&quot;基本概念&quot;&gt;基本概念&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;索引文件构成
    &lt;ul&gt;
      &lt;li&gt;索引记录 / 索引项，是索引文件的记录，包括两个域：
        &lt;ul&gt;
          &lt;li&gt;索引域（搜索码）：存储数据文件中一个或一组域（属性）&lt;/li&gt;
          &lt;li&gt;指针：指向索引域值为 K 的记录所在磁盘块的地址&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;索引将表中的部分属性进行组织或排序，使得利用这些属性能够快速有效进行表的访问&lt;/li&gt;
      &lt;li&gt;DBMS 负责在执行查询时使用最恰当的索引&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;索引的分类&quot;&gt;索引的分类&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基本类型&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;排序索引&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;索引项是排序的&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;哈希索引&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;索引项使用索引域上的 hash 函数确定位置&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;聚集索引与非聚集索引&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;聚集索引&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;索引项值排列顺序与记录在文件中的排列顺序一致，也成为&lt;strong&gt;主索引&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;非聚集索引&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;索引项指定的次序与文件中记录的排列顺序不同，也称为&lt;strong&gt;辅助索引&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;稠密索引与稀疏索引&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;稠密索引&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;对文件中的每个搜索码值都有一个索引项&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;稀疏索引&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;只有部分索引域值有索引记录，当文件记录以索引域排序时，可以采用&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;相比稠密索引，稀疏索引占空间小且维护代价低，但定位记录慢。非聚集索引都是稠密索引&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;多级索引&quot;&gt;多级索引&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;对索引文件建立稀疏索引
    &lt;ul&gt;
      &lt;li&gt;外层索引：基本索引的稀疏索引&lt;/li&gt;
      &lt;li&gt;内层索引：基本索引文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二叉树索引&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多枝树索引&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;B 树（平衡树）索引&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;是附加限制条件的索引树。限制了每个节点放置关键字与指针的最小和最大个数：根节点有 [2, n] 个子节点，中间节点有 [n/2, n] 个子结点，叶节点有 [n/2, n-1] 个记录指针，n 值对于特定树是固定的。
        &lt;ul&gt;
          &lt;li&gt;从树根到叶节点每条路径的长度都相同，因此所有的叶结点都在同一层上&lt;/li&gt;
          &lt;li&gt;B 树的关键字是散布在各层上&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;B+ 树&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;是 B 树的改进，把树中所有关键字都按递增次序从左到右安排在节点上，并且链接起来。B+ 树能同时进行随机查找和顺序查找。&lt;/li&gt;
      &lt;li&gt;节点结构
        &lt;ul&gt;
          &lt;li&gt;每个节点最多包含 n-1 个搜索码 / 索引码值 $K_1, K_2, …, K_{n-1}$，以及 n 个指针 $P_1, P_2, …, P_n$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hash 索引&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;基于哈希表 (Hash Table) 实现&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;哈希表实现 key 到 value 的映射。通过键值映射到表中一个位置来访问记录，这个映射函数叫做 Hash 函数，存放记录的数组叫做哈希表。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;哈希表&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;哈希函数&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;将很大的 key 空间映射到比较小的域，用于计算桶 / 槽数组的元素符号；非用于加密算法的哈希函数，计算速度快且碰撞率低&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;哈希方案&lt;/strong&gt; (scheme)&lt;/p&gt;

            &lt;p&gt;解决一个哈希值对应多条记录。最长使用溢出链接 (Chaining) 法&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;分类&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;静态哈希&lt;/strong&gt;：哈希表的大小是固定的
            &lt;ul&gt;
              &lt;li&gt;文件增大时，太多的溢出桶将降低访问性能&lt;/li&gt;
              &lt;li&gt;数据规模缩小时，会造成空间浪费&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;动态哈希&lt;/strong&gt;：允许哈希表的大小动态修改
            &lt;ul&gt;
              &lt;li&gt;定期重哈希：创建新的大的哈希表，把原表上的 key 重新哈希到新表上&lt;/li&gt;
              &lt;li&gt;线性哈希：以一种递增的方式重新哈希&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;第七章-关系查询处理与查询优化&quot;&gt;第七章 关系查询处理与查询优化&lt;/h1&gt;

&lt;h2 id=&quot;关系查询处理步骤&quot;&gt;关系查询处理步骤&lt;/h2&gt;

&lt;h3 id=&quot;1-查询分析&quot;&gt;1. 查询分析&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;词法分析&lt;/li&gt;
  &lt;li&gt;SQL 语法检查和语法分析&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-查询检查&quot;&gt;2. 查询检查&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;语义检查&lt;/li&gt;
  &lt;li&gt;存取权限检查&lt;/li&gt;
  &lt;li&gt;SQL 语句转换为关系代数表达式（查询树 / 语法分析树）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-查询优化&quot;&gt;3. 查询优化&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;选择一个高效执行的查询处理策略&lt;/li&gt;
  &lt;li&gt;生成查询计划&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-查询执行&quot;&gt;4. 查询执行&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;生成查询计划的代码&lt;/li&gt;
  &lt;li&gt;代码执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;查询代价的度量&quot;&gt;查询代价的度量&lt;/h2&gt;

&lt;p&gt;假设存取一个块就需要进行一次磁盘访问，使用&lt;strong&gt;访问磁盘的块数&lt;/strong&gt;作为估计代价的因素&lt;/p&gt;

&lt;h2 id=&quot;查询操作的实现&quot;&gt;查询操作的实现&lt;/h2&gt;

&lt;h3 id=&quot;选择运算实现算法&quot;&gt;选择运算实现算法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;全表扫描法&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;按照物理顺序读表的 M 块到内存，检查内存的每个元组 t，如果满足条件则输出 t，直到表所有块都经过上述检查&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;索引扫描法&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果在选择条件的属性上有索引，先通过索引找到目标索引项，再通过索引项找到元组&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;连接运算实现算法&quot;&gt;连接运算实现算法&lt;/h3&gt;

&lt;h4 id=&quot;嵌套循环法&quot;&gt;嵌套—循环法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;两个连接的表，第一个表为外循环，另一个为内循环。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;连接运算 $r \bowtie _{\theta} s$ 的实现算法，$r$ 是外循环表，$s$ 是内循环表&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/post/forfor.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不需要索引，并使用于任何连接条件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要检查两个关系中的每一对元组，代价高&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果连接操作使用的缓冲区的块数为 k，分配 (k-1) 块给外表 r，1 块给内表 s，则存取块数为：$b_r+\frac{b_r}{k-1}\times b_s$，其中 $b_r$ 为表 r 的块数，$b_s$ 为表 s 的块数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;应选择较小的表作为外表&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;索引连接法&quot;&gt;索引连接法&lt;/h4&gt;

&lt;p&gt;第二个表按照连接属性建索引，取第一个表元组的连接属性与第二个表元组的连接属性比较。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果内层关系 s 的连接属性上有索引，则对于外层关系 r 中的每一个元组 $t_r$，可以用索引查找 s 中与 $t_r$ 满足连接条件的元组&lt;/li&gt;
  &lt;li&gt;如果 r 和 s 在连接属性上都有索引，则以元组较少的关系作为外层关系，代价最小&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;排序合并法&quot;&gt;排序—合并法&lt;/h4&gt;

&lt;p&gt;两个表都按照连接属性排序，取第一个表元组的连接属性与第二个表元组的连接属性比较。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将两个关系在连接属性上排序&lt;/li&gt;
  &lt;li&gt;为每个关系分配一个指针，分别为 $p_r$ 和 $p_s$，对于 $p_r$ 指向 r 的一个连接属性值，移动 $p_s$ 找到 s 中与该值相等的元组，与 $p_r$ 指向的元组做连接，如此移动两个指针分别遍历 r 和 s&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;两个关系的每个块都只需要读一次，访问块数 = $b_r$ + $b_s$&lt;/li&gt;
  &lt;li&gt;只能用于等值连接或自然连接&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hash-join-法&quot;&gt;Hash Join 法&lt;/h4&gt;

&lt;p&gt;连接属性作为 hash 码，用同一个 hash 函数把两个连接表的元组散列到同一个 hash 文件。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;哈希函数 h 用于划分两个关系，h 将连接属性值映射到 {0, 1, …, n} 集合上。将 r 的元组划分为 $r_0, r_1, …, r_n$ 个部分，如果 h($t_r$[JoinAttrs])=i，则元组 $t_r$ 将被放入 $r_i$，同理将 s 页划分成 $s_0, s_1, …, s_n$ 个部分&lt;/li&gt;
  &lt;li&gt;对于某个连接属性值，若被哈希为 i，则 s 中相应的元组必定在 $s_i$ 中，而 r 中的元组必定在 $r_i$ 中，因此只需要将 $s_i$ 和 $r_i$ 中的元组相比较&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;适用于等值连接或自然连接&lt;/p&gt;

&lt;h3 id=&quot;排序&quot;&gt;排序&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;内存中完全容纳的关系，可采用快速排序 (quicksort) 法等算法&lt;/li&gt;
  &lt;li&gt;内存无法容纳的关系，可采用&lt;strong&gt;外排序-归并&lt;/strong&gt;算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;外排序-归并&quot;&gt;外排序-归并&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;建立多个排序好的归并段 (run)，每个段仅包含关系的部分记录&lt;/li&gt;
  &lt;li&gt;对归并段进行归并&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;其他运算&quot;&gt;其他运算&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;去重&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;使重复数据向相邻，保留一个数据删除其它&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;排序方法&lt;/li&gt;
      &lt;li&gt;哈希方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;投影&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;在每个元组上执行投影，之后再去重&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;集合运算——并、交、差&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;类似排序-合并连接，排序然后对每个已排序的关系扫描一次&lt;/li&gt;
      &lt;li&gt;类似 hash-join 将两个关系分区，再两个关系对应区中执行运算&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;库函数&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;基于分组属性进行排序或散列以聚集同组的元组，再执行库函数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;表达式的执行&quot;&gt;表达式的执行&lt;/h3&gt;

&lt;p&gt;可选方法包括物化 (materialized) 方法和流水线 (pipeline) 方法&lt;/p&gt;

&lt;h4 id=&quot;物化方法&quot;&gt;物化方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;按次序每次只执行一个运算，运算结构被物化到一个临时关系中，这些临时关系一般需要写到磁盘上&lt;/li&gt;
  &lt;li&gt;方法适用性广泛，但临时表的写和读代价大&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;流水线方法&quot;&gt;流水线方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;同时执行多个运算，将结果传递给下一个运算&lt;/li&gt;
  &lt;li&gt;不需要在磁盘上存储临时关系，代价小，但对有些运算不适用，如排序等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;查询优化&quot;&gt;查询优化&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;查询优化目标&lt;/strong&gt;：选择一个高效执行的查询处理策略，使得查询代价最小，即发个文磁盘的块数最少&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;分类&quot;&gt;分类&lt;/h4&gt;

&lt;h5 id=&quot;代数优化&quot;&gt;代数优化&lt;/h5&gt;

&lt;p&gt;关系代数表达式的优化，即按照一定的规则，改变代数表达式中操作的次序和组合&lt;/p&gt;

&lt;h5 id=&quot;物理优化&quot;&gt;物理优化&lt;/h5&gt;

&lt;p&gt;存取路径和底层操作算法的选择。包括基于规则或基于代价等&lt;/p&gt;

&lt;h4 id=&quot;查询优化的结果&quot;&gt;查询优化的结果&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;查询计划&lt;/strong&gt;：定义了每个操作的算法以及这些操作执行的顺序&lt;/p&gt;

&lt;h4 id=&quot;代数优化-1&quot;&gt;代数优化&lt;/h4&gt;

&lt;p&gt;通过对关系代数表达式的等价变化来提高查询效率&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关系代数表达式的&lt;strong&gt;等价&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;关系代数表达式等价变换规则&quot;&gt;关系代数表达式等价变换规则&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;连接、笛卡尔积交换律
\(E_1 \times E_2 = E_2 \times E_1 \\
E_1 \bowtie E_2 = E_2 \bowtie E_1 \\ 
E_1 \underset{F}{\bowtie} E_2 = E_2 \underset{F}{\bowtie} E_1\)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;连接、笛卡尔积的结合律
\((E_1\times E_2)\times E_3 = E_1\times (E_2\times E_3)\\
(E_1\bowtie E_2)\bowtie E_3=E_1 \bowtie (E_2\bowtie E_3) \\
(E_1\underset{F_1}{\bowtie} E_2)\underset{F_2}{\bowtie} E_3 = E_1\underset{F_1}{\bowtie}(E_2\underset{F_2}{\bowtie}E_3)\)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;投影的串联定理
\(\Pi_{A_1, A_2,...,A_n}(\Pi_{B_1,B_2,...,B_m}(E)) = \Pi_{A_1, A_2,...,A_n}(E)\)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择的串联定律
\(\sigma_{F_1}(\sigma_{F_2}(E)) = \sigma_{F_1\wedge F_2}(E)\)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择与投影的交换律
\(\sigma_{F_1}(\Pi_{A_1, A_2, ..., A_n}(E)) = \Pi_{A_1, A_2,...,A_n}(\sigma_F(E))\)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择与笛卡尔积交换律&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;$F$ 中只有 $E_1$ 的属性&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;$F=F_1\wedge F_2$，且 $F_1$ 只有 $E_1$ 的属性，$F_2$ 中只有 $E_2$ 的属性&lt;/p&gt;

        &lt;p&gt;$\sigma_F{E_1\times E_2}=\sigma_{F_1}(E_1)\times \sigma_{F_2}(E_2)$&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;$F_1$ 只有 $E_1$ 的属性，$F_2$ 有 $E_1$ 和 $E_2$ 的属性&lt;/p&gt;

        &lt;p&gt;$\sigma_F(E_1\times E_2)=\sigma_{F_2}(\sigma_{F_1}(E_1)\times E_2)$&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择与并的分配律&lt;/p&gt;

    &lt;p&gt;$\sigma_F(E_1\cup E_2)=\sigma_F(E_1)\cup \sigma_F(E_2)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择与差的分配律&lt;/p&gt;

    &lt;p&gt;$\sigma_F(E_1-E_2)=\sigma_F(E_1)-\sigma_F(E_2)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择对自然连接的分配律&lt;/p&gt;

    &lt;p&gt;$\sigma_F(E_1\bowtie E_2)=\sigma_F(E_1)\bowtie\sigma_F(E_2)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;投影与笛卡尔积的分配律&lt;/p&gt;

    &lt;p&gt;$\Pi_{A_1, A_2,…,A_n,B_1,B_2,…,B_m}(E_1\times E_2)=\Pi_{A_1,A_2,…,A_n}(E_1)\times \Pi_{B_1,B_2,..,B_m}(E_2)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;投影与并的分配律&lt;/p&gt;

    &lt;p&gt;$\Pi_{A_1,A_2,…,A_n}(E_1\cup E_2)=\Pi_{A_1,A_2,…,A_n}(E_1)\cup\Pi_{A_1, A_2,…,A_n}(E_2)$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;查询树&quot;&gt;查询树&lt;/h5&gt;

&lt;p&gt;查询树的关系代数表达式的树形表示&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;操作的关系位于叶结点&lt;/li&gt;
  &lt;li&gt;关系运算位于内部节点&lt;/li&gt;
  &lt;li&gt;执行方式：自底向上执行，当一个内部节点的操作分量可用时，该节点的操作启动执行，执行结束后用结果关系代替该节点&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;查询树的构造&quot;&gt;查询树的构造&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;将 SQL 语句转换为关系代数表达式
    &lt;ul&gt;
      &lt;li&gt;SELECT 子句对应投影操作&lt;/li&gt;
      &lt;li&gt;FROM 子句对应笛卡尔积&lt;/li&gt;
      &lt;li&gt;WHERE 子句对应选择操作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将关系代数表达式转换为查询树&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;查询树的启发式优化优化的一般准则&quot;&gt;查询树的启发式优化（优化的一般准则）&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;选择运算尽早执行&lt;/strong&gt;。是优化策略中最重要，最基本的一条（减少中间关系-减少元组数据）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;投影运算尽早执行&lt;/strong&gt;（减小中间关系-减少属性数目）&lt;/li&gt;
  &lt;li&gt;把投影运算和选择运算同时进行；把投影同其前或其后的双目运算结合起来（减少扫描关系的次数）&lt;/li&gt;
  &lt;li&gt;把某些选择同在它前面要执行的笛卡尔积结合起来称为一个连接运算（把笛卡尔积与选择转换为连接）&lt;/li&gt;
  &lt;li&gt;找出公共子表达式，把公共子表达式的结果写入中间文件，重复使用。（中间结果复用）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;物理优化-1&quot;&gt;物理优化&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;选择高效合理的操作算法或存取路径，得到优化的查询计划&lt;/li&gt;
  &lt;li&gt;查用方法
    &lt;ul&gt;
      &lt;li&gt;基于规则的启发式优化算法&lt;/li&gt;
      &lt;li&gt;基于代价估算的优化算法&lt;/li&gt;
      &lt;li&gt;两者结合的优化算法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;基于启发式规则的存取路径选择优化&quot;&gt;基于启发式规则的存取路径选择优化&lt;/h4&gt;

&lt;h5 id=&quot;选择操作的启发式规则&quot;&gt;选择操作的启发式规则&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;对于小关系，使用全表顺序扫描&lt;/li&gt;
  &lt;li&gt;对于大关系：可以采用索引扫描法（如结果的元组数目较小），全表顺序扫描&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;连接关系的启发式规则&quot;&gt;连接关系的启发式规则&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;如果两个表都已经按照连接属性排序——排序-合并法&lt;/li&gt;
  &lt;li&gt;如果一个表在连接属性上有索引——索引连接法&lt;/li&gt;
  &lt;li&gt;如果连接属性上未排序且未建索引，且其中一个表较小——Hash Join 法&lt;/li&gt;
  &lt;li&gt;最后可选用嵌套循环法，并选择较小的表作为外循环表&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;查询优化的一般步骤&quot;&gt;查询优化的一般步骤&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;把查询转换成语法树，如关系代数语法树&lt;/li&gt;
  &lt;li&gt;把语法树利用代数优化转换成优化后的标准形式&lt;/li&gt;
  &lt;li&gt;利用基于启发式规则的物理优化，选择底层的存取路径。生成查询计划，利用基于代价的物理优化，选择代价最小的&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;第八章-事务处理技术&quot;&gt;第八章 事务处理技术&lt;/h1&gt;

&lt;h2 id=&quot;事务&quot;&gt;事务&lt;/h2&gt;

&lt;h3 id=&quot;定义-3&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;事务&lt;/strong&gt; (Transaction) 是用户定义的数据库操作序列，这些操作要么都做，要么都不做，是一个不可分割的工作单位。&lt;/p&gt;

&lt;h3 id=&quot;特性&quot;&gt;特性&lt;/h3&gt;

&lt;h4 id=&quot;原子性-atomicity&quot;&gt;原子性 (Atomicity)&lt;/h4&gt;

&lt;p&gt;事务中包括的所有操作要么都做，要么都不做&lt;/p&gt;

&lt;h4 id=&quot;一致性-consistency&quot;&gt;一致性 (Consistency)&lt;/h4&gt;

&lt;p&gt;事务执行的结果必须是使数据库从一个一致性状态，变到另一个一致性状态&lt;/p&gt;

&lt;h4 id=&quot;隔离性-isolation&quot;&gt;隔离性 (Isolation)&lt;/h4&gt;

&lt;p&gt;一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰&lt;/p&gt;

&lt;h4 id=&quot;持久性-durability&quot;&gt;持久性 (Durability)&lt;/h4&gt;

&lt;p&gt;一个事务一旦提交之后，它对数据库的映像必须是永久的。其它操作或故障不应该对其执行结果有任何影响&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;事务的 &lt;strong&gt;ACID&lt;/strong&gt; 特性对于数据库数据的正确、有效具有重要意义。但事务的特性有可能遭破坏，主要有两种情况：
    &lt;ul&gt;
      &lt;li&gt;多个事务并行运行时，不同事物的操作交叉进行&lt;/li&gt;
      &lt;li&gt;事物在运行过程中被强行停止&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;利用数据库&lt;strong&gt;并发控制&lt;/strong&gt;机制以及数据库&lt;strong&gt;恢复&lt;/strong&gt;机制保证事物的特性不被破坏，从而保证数据库数据的正确、有效
    &lt;ul&gt;
      &lt;li&gt;原子性由恢复机制实现&lt;/li&gt;
      &lt;li&gt;一致性是由事物的原子性保证的&lt;/li&gt;
      &lt;li&gt;隔离性通过并发控制机制实现&lt;/li&gt;
      &lt;li&gt;持久性通过恢复机制实现&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事务是数据库恢复和并发控制的基本单位&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;事务的开始与结束可以由用户&lt;strong&gt;显式&lt;/strong&gt;控制。如果用户没有显式定义事务，则由 DBMS 按缺省规定自动划分事务。&lt;/li&gt;
  &lt;li&gt;事务与应用程序是两个概念，一般来说，一个应用程序可以包含多个事务&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-中事务的定义&quot;&gt;SQL 中事务的定义&lt;/h3&gt;

&lt;h4 id=&quot;事务开始&quot;&gt;事务开始&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BEGIN TRANSACTION&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;事务结束&quot;&gt;事务结束&lt;/h4&gt;

&lt;h5 id=&quot;正常结束&quot;&gt;正常结束&lt;/h5&gt;

&lt;p&gt;提交事务，正常结束&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COMMIT&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;非正常结束&quot;&gt;非正常结束&lt;/h5&gt;

&lt;p&gt;撤销全部更新，回滚到事务开始时状态。非正常结束&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROLLBACK&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;数据库恢复技术&quot;&gt;数据库恢复技术&lt;/h2&gt;

&lt;h3 id=&quot;定义-4&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;数据库管理系统必须具有把数据库&lt;strong&gt;从错误状态恢复到某一已知正确状态&lt;/strong&gt;的功能，这就是数据库的恢复&lt;/p&gt;

&lt;h3 id=&quot;方法&quot;&gt;方法&lt;/h3&gt;

&lt;p&gt;数据库恢复是通过数据库管理系统的恢复子系统完成的&lt;/p&gt;

&lt;p&gt;数据库恢复的基本原理为&lt;strong&gt;冗余&lt;/strong&gt;。即利用存储在系统别处的冗余数据来重建或恢复修正数据库&lt;/p&gt;

&lt;h3 id=&quot;意义&quot;&gt;意义&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;保证事务的原子性&lt;/strong&gt;。实现事务非正常终止时的回滚&lt;/li&gt;
  &lt;li&gt;当&lt;strong&gt;系统发生故障&lt;/strong&gt;以后，数据库能够恢复到正确状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;故障&quot;&gt;故障&lt;/h3&gt;

&lt;h4 id=&quot;种类&quot;&gt;种类&lt;/h4&gt;

&lt;h5 id=&quot;事务内部的故障&quot;&gt;事务内部的故障&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;可预期的&lt;/strong&gt;：事务根据内部的测试条件，确定是否回滚&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不可预期的&lt;/strong&gt;：指不能由应用程序处理的事务故障，如死锁、运算溢出，违反完整性规则等&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;系统故障&quot;&gt;系统故障&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;是指&lt;strong&gt;造成系统停止运行&lt;/strong&gt;的任何事情，使得系统要重新启动，如硬件错误，操作系统故障，停电等。&lt;/li&gt;
  &lt;li&gt;这类故障打断所有正在运行的事务，使事务都异常中止，但&lt;strong&gt;不会破坏数据库&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;介质故障&quot;&gt;介质故障&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;介质故障指外存故障，如磁盘损坏，瞬时强磁场干扰等&lt;/li&gt;
  &lt;li&gt;这类故障将&lt;strong&gt;破坏全部或部分数据库&lt;/strong&gt;，并&lt;strong&gt;影响正在存取这部分数据的所有事务&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;计算机病毒&quot;&gt;计算机病毒&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;计算机病毒是一种人为的破坏或故障，已成为数据库系统的主要威胁之一&lt;/li&gt;
  &lt;li&gt;多数病毒&lt;strong&gt;对数据进行非法修改&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据转储&quot;&gt;数据转储&lt;/h2&gt;

&lt;h3 id=&quot;定义-5&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;是 DBA 定期的将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本成为&lt;strong&gt;后备副本或后援副本&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;分类-1&quot;&gt;分类&lt;/h3&gt;

&lt;h4 id=&quot;静态转储&quot;&gt;静态转储&lt;/h4&gt;

&lt;h5 id=&quot;定义-6&quot;&gt;定义&lt;/h5&gt;

&lt;p&gt;系统中无事务进行时进行的转储操作。并在转储过程中，不允许对数据库进行任何读取，修改。&lt;/p&gt;

&lt;h5 id=&quot;优点&quot;&gt;优点&lt;/h5&gt;

&lt;p&gt;保证副本的数据一致性&lt;/p&gt;

&lt;h5 id=&quot;缺点&quot;&gt;缺点&lt;/h5&gt;

&lt;p&gt;由于转储必须等待正在运行的事务结束才能开始，而新的事物必须等待转储结束才能进行，降低了数据库的可用性&lt;/p&gt;

&lt;h4 id=&quot;动态转储&quot;&gt;动态转储&lt;/h4&gt;

&lt;h5 id=&quot;定义-7&quot;&gt;定义&lt;/h5&gt;

&lt;p&gt;转储期间允许对数据库进行存取或修改&lt;/p&gt;

&lt;h5 id=&quot;优点-1&quot;&gt;优点&lt;/h5&gt;

&lt;p&gt;不影响数据的可用性&lt;/p&gt;

&lt;h5 id=&quot;缺点-1&quot;&gt;缺点&lt;/h5&gt;

&lt;p&gt;不能保证副本上的数据正确，有效。还必须把转储期间各事物对数据库的修改记录下来，建立&lt;strong&gt;日志文件&lt;/strong&gt;。后援副本加上日志文件就能把数据库恢复到某一时刻的正确状态。&lt;/p&gt;

&lt;h3 id=&quot;转储方式&quot;&gt;转储方式&lt;/h3&gt;

&lt;h4 id=&quot;海量转储&quot;&gt;海量转储&lt;/h4&gt;

&lt;p&gt;海量转储指每次转储全部数据库&lt;/p&gt;

&lt;h4 id=&quot;增量转储&quot;&gt;增量转储&lt;/h4&gt;

&lt;p&gt;增量转储指每次只转储上一次转储后更新过的数据&lt;/p&gt;

&lt;h2 id=&quot;日志文件的建立与使用&quot;&gt;日志文件的建立与使用&lt;/h2&gt;

&lt;h3 id=&quot;定义-8&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;日志是用来&lt;strong&gt;记录事务对数据库更新操作&lt;/strong&gt;的文件。&lt;/p&gt;

&lt;h3 id=&quot;格式&quot;&gt;格式&lt;/h3&gt;

&lt;h4 id=&quot;以记录为单位&quot;&gt;以记录为单位&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;记载的内容
    &lt;ul&gt;
      &lt;li&gt;各个事务的开始标记&lt;/li&gt;
      &lt;li&gt;各个事务的结束标记&lt;/li&gt;
      &lt;li&gt;各个事务的所有更新操作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;每个日志记录中包含的信息项
    &lt;ul&gt;
      &lt;li&gt;事务标识（标明是哪个事务）&lt;/li&gt;
      &lt;li&gt;操作的类型（输入、删除或修改）&lt;/li&gt;
      &lt;li&gt;操作对象（记录的内部标识）&lt;/li&gt;
      &lt;li&gt;更新前数据的旧值（对插入操作，此项为空）&lt;/li&gt;
      &lt;li&gt;更新后数据的新值（对删除操作，此项为空）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;以数据块为单位&quot;&gt;以数据块为单位&lt;/h4&gt;

&lt;p&gt;日志记录的内容包括事务标识以及更新前和更新后的数据块&lt;/p&gt;

&lt;h3 id=&quot;作用&quot;&gt;作用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;事务故障和系统故障修复&lt;/strong&gt;必须使用日志文件&lt;/li&gt;
  &lt;li&gt;在&lt;strong&gt;动态转储&lt;/strong&gt;方式中必须建立日志文件，后备副本和日志文件综合起来才能有效地恢复数据库&lt;/li&gt;
  &lt;li&gt;在&lt;strong&gt;静态转储&lt;/strong&gt;方式中，用日志文件恢复转储结束时刻到故障点间的事务&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;日志文件的写入规则&quot;&gt;日志文件的写入规则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;登记的次序严格按并发事务执行的时间顺序&lt;/li&gt;
  &lt;li&gt;必须&lt;strong&gt;先写日志文件，后写数据库&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;故障的恢复策略&quot;&gt;故障的恢复策略&lt;/h2&gt;

&lt;h3 id=&quot;事务故障的恢复&quot;&gt;事务故障的恢复&lt;/h3&gt;

&lt;p&gt;事务故障的恢复——&lt;strong&gt;UNDO&lt;/strong&gt;，即撤销事务&lt;/p&gt;

&lt;p&gt;在不影响其它事务的情况下，&lt;strong&gt;强行回滚&lt;/strong&gt;，撤销已做的修改。具体步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;反向扫描日志文件，查找该事务的更新操作&lt;/li&gt;
  &lt;li&gt;对该事务的更新操作（插入、删除、修改）执行逆操作，即将日志记录中的“更新前的值”写入数据库&lt;/li&gt;
  &lt;li&gt;如此处理下去，直到读到该事务的开始标志&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;系统故障-1&quot;&gt;系统故障&lt;/h3&gt;

&lt;p&gt;系统故障——&lt;strong&gt;UNDO+REDO&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;系统故障造成数据库不一致状态的原因
    &lt;ul&gt;
      &lt;li&gt;未完成的事务对数据库的更新可能已经写入数据库&lt;/li&gt;
      &lt;li&gt;已提交事务对数据库的更新可能还留在缓冲区未写入数据库&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;恢复操作需要&lt;strong&gt;撤销 (UNDO) 故障发生时未完成的任务，重做 (REDO) 已完成的任务&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;步骤&quot;&gt;步骤&lt;/h3&gt;

&lt;h4 id=&quot;系统故障-2&quot;&gt;系统故障&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;正向扫描日志文件，找出故障发生前已经提交的事务，将其事务标识记入&lt;strong&gt;重做 (REDO) 队列&lt;/strong&gt;，同时找出故障发生时尚未完成的事务，将其事务标识记入&lt;strong&gt;撤销 (UNDO)&lt;/strong&gt; 队列&lt;/li&gt;
  &lt;li&gt;对撤销队列中的各个事务进行 UNDO 处理&lt;/li&gt;
  &lt;li&gt;对重做队列中的各个事务进行 REDO 处理&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;介质故障-1&quot;&gt;介质故障&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致状态。对于动态转储的副本，还需要装入转储开始时刻的日志文件副本，将数据库恢复到一致状态&lt;/li&gt;
  &lt;li&gt;装入存储以后的日志文件副本，重做已经完成的事务&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;具有检查点的恢复技术&quot;&gt;具有检查点的恢复技术&lt;/h3&gt;

&lt;h4 id=&quot;优势&quot;&gt;优势&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;利用日志技术进行恢复时，恢复子系统通常需要检查大量日志记录，存在的问题是：
    &lt;ul&gt;
      &lt;li&gt;搜索日志耗费大量时间&lt;/li&gt;
      &lt;li&gt;不必要重做某些事物&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;检查点技术可以改善效率，使得在检查点之前提交的事务，在数据库恢复处理时不必重做&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;检查点技术&quot;&gt;检查点技术&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在日志文件中增加&lt;strong&gt;检查点 (checkpoint) 记录&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;检查点记录的内容
    &lt;ul&gt;
      &lt;li&gt;建立检查点时刻&lt;strong&gt;所有正在执行的事务清单&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;这些事务&lt;strong&gt;最近一个日志记录的地址&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;系统中增加一个&lt;strong&gt;重新开始文件&lt;/strong&gt;，用来记录各个&lt;strong&gt;检查点记录在日志文件中的地址&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;恢复子系统&lt;strong&gt;动态维护日志文件&lt;/strong&gt;，即周期性地执行如下操作
    &lt;ul&gt;
      &lt;li&gt;将当前日志缓存中的所有&lt;strong&gt;日志记录写入磁盘的日志文件上&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;在日志文件上&lt;strong&gt;写入一个检查点记录&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;将当前数据缓存的所有&lt;strong&gt;数据记录写入磁盘的数据库中&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;把&lt;strong&gt;检查点记录在日志文件中的地址写入重新开始文件&lt;/strong&gt;s&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;利用检查点技术进行恢复&quot;&gt;利用检查点技术进行恢复&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;利用重新开始文件定位最近检查点记录&lt;/strong&gt;：在重新开始文件中找到最后一个检查点记录在日志文件中的地址&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;找到检查点时刻运行事务清单&lt;/strong&gt;：由该检查点记录得到检查点建立时刻所有正在运行的事务清单 ACTIVE-LIST，把 ACTIVE-LIST 暂时放入 UNDO-LIST&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;确定需要撤销和重做的事务&lt;/strong&gt;：从&lt;strong&gt;检查点开始&lt;/strong&gt;正向扫描日志文件，做如下处理，直到文件结束
    &lt;ul&gt;
      &lt;li&gt;如果有新开始的事务 $T_i$，把 $T_i$ 暂时放入 UNDO-LIST&lt;/li&gt;
      &lt;li&gt;如果有提交的事务 $T_j$ ，把 $T_j$ 从 UNDO-LIST 队列移入到 REDO-LIST 队列&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;执行撤销或重做动作&lt;/strong&gt;：对 UNDO-LIST 中的每一个事物执行 UNDO 操作，对 REDO-LIST 中的每个事务执行 REDO 操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据库镜像&quot;&gt;数据库镜像&lt;/h2&gt;

&lt;p&gt;根据 DBA 的要求，自动把整个 DB 或其中的关键数据复制到另一个磁盘上，由 DBMS 自动保证镜像数据库与主数据库的一致性。&lt;/p&gt;

&lt;h2 id=&quot;并发控制&quot;&gt;并发控制&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/concurrent.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;并发控制-1&quot;&gt;并发控制&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;事务并发执行的优点
    &lt;ul&gt;
      &lt;li&gt;一个事务由不同的步骤组成，所设计的系统资源也不同。这些步骤可以并发执行，以&lt;strong&gt;提高系统的吞吐量&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;系统中存在着周期不等的各种事务，串行会导致难以预测的时延。如果各个事务所涉及的是数据库的不同部分，采用并发会&lt;strong&gt;减少平均响应时间&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;事务并发执行带来的问题
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;多个事务同时存取同一数据&lt;/strong&gt;时，如不加控制就可能会读取或存储不正确的数据，破坏数据库的一致性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;并发操作导致的数据不一致性&quot;&gt;并发操作导致的数据不一致性&lt;/h3&gt;

&lt;h4 id=&quot;丢失更新-lost-update&quot;&gt;丢失更新 (Lost Update)&lt;/h4&gt;

&lt;p&gt;两个事务 T1 和 T2 读入同一数据并修改，T2 提交的结果破坏了 T1 提交的结果，导致 T1 的修改被丢失&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/lostUpdate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;脏数据的读出-dirty-read&quot;&gt;“脏”数据的读出 (Dirty Read)&lt;/h4&gt;

&lt;p&gt;事务 T1 修改某一数据，并将其写回磁盘，事务 T2 读取同一数据后，T1 由于某种原因被撤销，这时 T1 已修改过的数据恢复为原值，T2 读到的数据就与数据库中的不一致，则 T2 读到的数据就为“脏”数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/dirtyRead.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;不能重复读-non-repeatable-read&quot;&gt;不能重复读 (Non-Repeatable Read)&lt;/h4&gt;

&lt;p&gt;事务 T1 读取数据后，事务 T2 执行更新（修改、插入、删除操作），使 T1 无法再现前一次读取的结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/nonrepeatableread.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;并发控制基本思想&quot;&gt;并发控制基本思想&lt;/h3&gt;

&lt;p&gt;并发控制就是要&lt;strong&gt;合理调度并发事务&lt;/strong&gt;，&lt;strong&gt;避免并发事务之间的互相干扰造成数据的不一致性&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;并发控制的基本手段封锁&quot;&gt;并发控制的基本手段——封锁&lt;/h3&gt;

&lt;h4 id=&quot;定义-9&quot;&gt;定义&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;封锁&lt;/strong&gt;就是事务 T 在对某个数据对象等操作之前，先向系统发出请求，对其&lt;strong&gt;加锁&lt;/strong&gt;，从而对该数据有了一定的控制权&lt;/p&gt;

&lt;h4 id=&quot;分类-2&quot;&gt;分类&lt;/h4&gt;

&lt;h5 id=&quot;排他锁x-锁exclusive-lock&quot;&gt;排他锁（X 锁，eXclusive lock）&lt;/h5&gt;

&lt;p&gt;事务 T 对数据对象 R 加上 X 锁，则&lt;strong&gt;只允许 T 读取和修改 R&lt;/strong&gt;，其它事务对 R 的&lt;strong&gt;任何&lt;/strong&gt;封锁请求都不能成功，直至 T 释放 R 上的 X 锁。&lt;/p&gt;

&lt;h5 id=&quot;共享锁s-锁share-lock&quot;&gt;共享锁（S 锁，Share lock）&lt;/h5&gt;

&lt;p&gt;事务 T 对数据对象 R 加上 S 锁，则事务 T &lt;strong&gt;可以读取但不能修改 R&lt;/strong&gt;，其它事务只能对 R 加 S 锁，而不能对 R 加 X 锁，直到 T 释放 R 上的 S 锁。&lt;/p&gt;

&lt;h4 id=&quot;基本锁的相容矩阵&quot;&gt;基本锁的相容矩阵&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;T1 \ T2&lt;/th&gt;
      &lt;th&gt;X&lt;/th&gt;
      &lt;th&gt;S&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;封锁协议&quot;&gt;封锁协议&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/rule.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;内容&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;一级封锁协议&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;事务 T 在修改数据 R 之前必须对其家 X 锁，直到事务结束（正常结束 &amp;amp; 非正常结束）才释放。&lt;/td&gt;
      &lt;td&gt;方式丢失修改，并保证事务 T 是可恢复的。不能保证可重复读和读“脏”数据。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;二级封锁协议&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，&lt;strong&gt;读完后&lt;/strong&gt;即可释放 S 锁。&lt;/td&gt;
      &lt;td&gt;可以防止丢失更新，还可以进一步防止读“脏”数据。但不能保证可重复读。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;三级封锁协议&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;一级封锁协议加上事务 T 在读取 R 之前必须对其加 S 锁，&lt;strong&gt;直到事务结束&lt;/strong&gt;才释放。&lt;/td&gt;
      &lt;td&gt;防止丢失修改，读“脏”数据和不可重复读。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;封锁的粒度&quot;&gt;封锁的粒度&lt;/h4&gt;

&lt;h5 id=&quot;定义-10&quot;&gt;定义&lt;/h5&gt;

&lt;h6 id=&quot;封锁对象&quot;&gt;封锁对象&lt;/h6&gt;

&lt;p&gt;属性值、属性值集合、元组、关系、某索引项、整个索引、整个数据库、物理页、块等&lt;/p&gt;

&lt;h6 id=&quot;封锁粒度&quot;&gt;封锁粒度&lt;/h6&gt;

&lt;p&gt;封锁对象的大小成为封锁粒度&lt;/p&gt;

&lt;h5 id=&quot;性质&quot;&gt;性质&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;封锁粒度大，则并发度低，封锁机构简单，开销小&lt;/li&gt;
  &lt;li&gt;封锁粒度小，则并发度搞，封锁机构复杂，开销高&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;多粒度封锁&quot;&gt;多粒度封锁&lt;/h5&gt;

&lt;p&gt;在一个系统中&lt;strong&gt;同时支持多种封锁粒度&lt;/strong&gt;供不同的事务选择。选择封锁粒度时应考虑&lt;strong&gt;封锁开销&lt;/strong&gt;和&lt;strong&gt;并发度&lt;/strong&gt;两个因素，适当选择封锁粒度以达到最优效果。&lt;/p&gt;

&lt;h4 id=&quot;多粒度封锁-1&quot;&gt;多粒度封锁&lt;/h4&gt;

&lt;h5 id=&quot;多粒度树&quot;&gt;多粒度树&lt;/h5&gt;

&lt;p&gt;多粒度树的根节点是整个数据库，表示最大的粒度。叶结点表示最小的粒度。&lt;/p&gt;

&lt;h5 id=&quot;多粒度封锁协议&quot;&gt;多粒度封锁协议&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;多粒度封锁协议&lt;strong&gt;允许多粒度树种的每个节点被独立的加锁。对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁&lt;/strong&gt;。因此，在多粒度封锁种一个数据对象可能以两种方式加锁，即：
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;显式封锁&lt;/strong&gt;：是应事务的要求直接加到数据对象上的封锁&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;隐式封锁&lt;/strong&gt;：是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加锁&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在多粒度封锁方法中，&lt;strong&gt;显式封锁和隐式封锁的效果相同&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;存在的问题&quot;&gt;存在的问题&lt;/h5&gt;

&lt;p&gt;在多粒度封锁方法中，一般对某个数据对象加锁，系统要做如下检查：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是否&lt;strong&gt;与该数据对象上的显式封锁冲突&lt;/strong&gt;（检查对象本身）&lt;/li&gt;
  &lt;li&gt;是否&lt;strong&gt;与该数据对象上的隐式封锁冲突&lt;/strong&gt;（检查对象的所有上级结点）&lt;/li&gt;
  &lt;li&gt;是否&lt;strong&gt;与该数据对象的下级的显示封锁冲突&lt;/strong&gt;（检查其所有下级结点）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;意向锁&quot;&gt;意向锁&lt;/h4&gt;

&lt;h5 id=&quot;定义-11&quot;&gt;定义&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;意向锁&lt;/strong&gt;的含义是该结点的下层结点正在被加锁。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对任意结点加锁时，必须先对其上级结点加意向锁&lt;/li&gt;
  &lt;li&gt;意向锁的好处是：在对象加锁时，&lt;strong&gt;不再检查下级结点的封锁&lt;/strong&gt;，只需检查对象和它的上级结点&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;分类-3&quot;&gt;分类&lt;/h5&gt;

&lt;h6 id=&quot;意向共享锁-intent-share-lock简称-is-锁&quot;&gt;意向共享锁 (Intent Share Lock，简称 IS 锁)&lt;/h6&gt;

&lt;p&gt;如果要对一个数据对象加 IS 锁，表示它的后裔结点拟（意向）加 S 锁。&lt;/p&gt;

&lt;h6 id=&quot;意向排它锁-intent-exclusive-lock简称-ix-锁&quot;&gt;意向排它锁 (Intent Exclusive Lock，简称 IX 锁)&lt;/h6&gt;

&lt;p&gt;如果要对一个数据对象加 IX 锁，表示它的后裔结点拟（意向）加 X 锁。&lt;/p&gt;

&lt;h6 id=&quot;意向共享排它锁-share-intent-exclusive-lock简称-six-锁&quot;&gt;意向共享排它锁 (Share Intent Exclusive Lock，简称 SIX 锁)&lt;/h6&gt;

&lt;p&gt;如果要对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁，即 &lt;strong&gt;SIX = S + IX&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;加锁方法&quot;&gt;加锁方法&lt;/h5&gt;

&lt;p&gt;任意事务 T 要对一个数据对象加锁，&lt;strong&gt;先对它的上级对象加意向锁&lt;/strong&gt;，申请封锁按自上而下的次序进行；释放封锁时，应按照自下而上的次序进行。&lt;/p&gt;

&lt;h5 id=&quot;相容矩阵&quot;&gt;相容矩阵&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;T1 \ T2&lt;/th&gt;
      &lt;th&gt;S&lt;/th&gt;
      &lt;th&gt;X&lt;/th&gt;
      &lt;th&gt;IS&lt;/th&gt;
      &lt;th&gt;IX&lt;/th&gt;
      &lt;th&gt;SIX&lt;/th&gt;
      &lt;th&gt;-&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;IS&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;IX&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;SIX&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;活锁与死锁&quot;&gt;活锁与死锁&lt;/h4&gt;

&lt;h5 id=&quot;活锁&quot;&gt;活锁&lt;/h5&gt;

&lt;h6 id=&quot;定义-12&quot;&gt;定义&lt;/h6&gt;

&lt;p&gt;任务或执行者没有被阻塞，但由于某些条件没有满足，导致一直无法得到执行。&lt;/p&gt;

&lt;h6 id=&quot;解决&quot;&gt;解决&lt;/h6&gt;

&lt;p&gt;采用先来先服务的策略&lt;/p&gt;

&lt;h5 id=&quot;死锁&quot;&gt;死锁&lt;/h5&gt;

&lt;h6 id=&quot;定义-13&quot;&gt;定义&lt;/h6&gt;

&lt;p&gt;当两个以上的运算单元，双方都在等待对方停止执行，以取得系统资源，但是没有一方提前退出时，发生死锁。&lt;/p&gt;

&lt;h6 id=&quot;解决-1&quot;&gt;解决&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;预防死锁&lt;/li&gt;
  &lt;li&gt;死锁检测和解除&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;死锁预防&quot;&gt;死锁预防&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;一次封锁法&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;要求每个事务必须&lt;strong&gt;一次&lt;/strong&gt;将所有要使用的数据&lt;strong&gt;全部&lt;/strong&gt;加锁，否则&lt;strong&gt;不能&lt;/strong&gt;执行。&lt;/li&gt;
      &lt;li&gt;可以有效地防止死锁的发生，但由于需要扩大加锁范围，因此会&lt;strong&gt;降低系统的并发度&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;顺序封锁法&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;预先对数据对象规定一个封锁顺序&lt;/strong&gt;。所有的事务都要按照这个顺序执行封锁。&lt;/li&gt;
      &lt;li&gt;可以有效的防止死锁，但由于数据库中数据的不断变化和事务封锁要求的动态提出而&lt;strong&gt;实现难度大&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;死锁检测&quot;&gt;死锁检测&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;超时法&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果一个事务的等待时间超过了规定的期限，就认为发生了死锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;等待图法&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;事务等待图是一个有向图 G=(T, U)，其中 T 为结点集合，每个结点表示正在运行的事务，U 为边集，每条边表示事务的等待情况。并发控制子系统周期性的检测事务等待图，&lt;strong&gt;如果发现图中存在环路，则表示系统出现死锁&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;死锁恢复&quot;&gt;死锁恢复&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;通常采用的方法是&lt;strong&gt;选择一个处理死锁代价最小的事务，将其撤销&lt;/strong&gt;，释放此事务持有的所有锁，使其他食物得以继续运行下去。对于所撤销的食物所作的操作必须加以恢复。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;事务的调度&quot;&gt;事务的调度&lt;/h2&gt;

&lt;h3 id=&quot;定义-14&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;N 个事务的一个调度 S 是 N 个事务所有操作的一个&lt;strong&gt;序列&lt;/strong&gt;。表示这些操作的&lt;strong&gt;执行顺序&lt;/strong&gt;。并且这个序列满足：对于每个事务 T，如果操作 i 在事务 T 中先于操作 k 执行，则在 S 中操作 i 也必须先于操作 k 执行。&lt;/p&gt;

&lt;h3 id=&quot;并发调度的可串行性&quot;&gt;并发调度的可串行性&lt;/h3&gt;

&lt;h4 id=&quot;定义-15&quot;&gt;定义&lt;/h4&gt;

&lt;h5 id=&quot;可串行化调度&quot;&gt;可串行化调度&lt;/h5&gt;

&lt;p&gt;多个事务的并发执行是&lt;strong&gt;正确&lt;/strong&gt;的，当且仅当其结果与&lt;strong&gt;按某一次序串行执行&lt;/strong&gt;它们时的结果相同，我们称这种调度策略为&lt;strong&gt;可串行化调度&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;冲突操作&quot;&gt;冲突操作&lt;/h5&gt;

&lt;p&gt;冲突操作是&lt;strong&gt;不同事务&lt;/strong&gt;对&lt;strong&gt;同一数据&lt;/strong&gt;的&lt;strong&gt;读-写&lt;/strong&gt;操作以及&lt;strong&gt;写-写&lt;/strong&gt;操作。&lt;/p&gt;

&lt;h4 id=&quot;性质-1&quot;&gt;性质&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;可串行性是并行事务正确性的准则&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;判定&quot;&gt;判定&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一个调度 Sc 在保证冲突操作次序不变的情况下，可以通过交换两个事务不冲突操作的顺序，得到另一个穿行调度 Sc’，则调度 Sc 为&lt;strong&gt;冲突可串行化调度&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;不同事务的冲突操作与同一个事物的两个操作不能交换。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;一个冲突可串行化调度，一定是可串行化调度&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;两段锁协议-two-phase-locking&quot;&gt;两段锁协议 (Two-phase Locking)&lt;/h4&gt;

&lt;h5 id=&quot;内容&quot;&gt;内容&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;在对任何数据进行读、写操作之前，事务首先要获得对数据的封锁&lt;/li&gt;
  &lt;li&gt;在释放一个封锁之后，事务不再获得其它封锁&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;含义&quot;&gt;含义&lt;/h5&gt;

&lt;p&gt;事务分为两个阶段，第一个阶段是获得封锁，也称为&lt;strong&gt;扩展阶段&lt;/strong&gt;，第二个阶段是释放封锁，也称为&lt;strong&gt;收缩阶段&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;作用-1&quot;&gt;作用&lt;/h5&gt;

&lt;p&gt;可保证并行事务的可串行性&lt;/p&gt;

&lt;h4 id=&quot;并发调度的可串行性-1&quot;&gt;并发调度的可串行性&lt;/h4&gt;

&lt;h5 id=&quot;定理-2&quot;&gt;定理&lt;/h5&gt;

&lt;p&gt;若所有事物均遵从两段锁协议，则这些食物的所有并发调度都是可串行化的。&lt;/p&gt;

&lt;h5 id=&quot;注意的问题&quot;&gt;注意的问题&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;事务遵守两段锁协议是可串行化调度的充分条件而不是必要条件&lt;/li&gt;
  &lt;li&gt;两段锁协议并不要求事务在执行任何数据库读、写操作之前就一次申请全部封锁，因此&lt;strong&gt;遵守两段锁的事务仍可能发生死锁&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;第九章-数据库保护&quot;&gt;第九章 数据库保护&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;数据安全性控制&lt;/strong&gt;是保护数据库防止恶意的破坏和非法存取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据完整性控制&lt;/strong&gt;是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;安全性防范的是非法用户和非法操作，完整性措施防范的对象是不合语义的数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;数据库安全性控制&quot;&gt;数据库安全性控制&lt;/h2&gt;

&lt;h3 id=&quot;定义-16&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;数据库的安全性是指保护数据库以&lt;strong&gt;防止不合法的使用所造成的数据泄露、更改和破坏&lt;/strong&gt;，它包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向授权用户提供可靠的信息服务&lt;/li&gt;
  &lt;li&gt;拒绝对数据的非授权存取访问请求，保证给数据的可用性、完整性和一致性，进而保护数据库所有者和使用者的合法权益&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据库安全性控制-1&quot;&gt;数据库安全性控制&lt;/h3&gt;

&lt;h4 id=&quot;用户标识与鉴别&quot;&gt;用户标识与鉴别&lt;/h4&gt;

&lt;p&gt;用户标识和认证是系统提供的&lt;strong&gt;最外层&lt;/strong&gt;安全保护措施&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;标识&lt;/strong&gt;是指系统采用一定的方式标识其用户或应用程序的名字或身份&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;认证&lt;/strong&gt;是指系统在用户或应用程序登录时判断其是否为合法的授权用户&lt;/li&gt;
  &lt;li&gt;常用的方法是采用&lt;em&gt;用户名&lt;/em&gt;和&lt;em&gt;口令&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;存取控制&quot;&gt;存取控制&lt;/h4&gt;

&lt;h5 id=&quot;定义-17&quot;&gt;定义&lt;/h5&gt;

&lt;p&gt;存取控制确保合法用户&lt;strong&gt;按照指定的权限&lt;/strong&gt;使用 DBMS 和访问数据，而非法用户或不具有相关权限的用户则不能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;用户权限定义&lt;/strong&gt;：将用户权限记录到数据字典中，形成安全规则或授权规则&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;合法权限检查&lt;/strong&gt;：每当用户发出数据库操作请求后，DBMS 根据数据字典中的安全规则进行合法权限检查，决定是否接受用户的操作请求。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;用户权限定义和合法权限检查机制一起组成了 DBMS 的安全子系统&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;自主存取控制-discretionary-access-control-dac&quot;&gt;自主存取控制 (discretionary access control, DAC)&lt;/h5&gt;

&lt;p&gt;用户对于不同的数据对象拥有不同的存取权限，不同的用户对同一对象也有不同的权限，而且&lt;strong&gt;用户还可以将其拥有的权限转授给其他用户&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;根据预先定义的用户权限进行存取控制。&lt;strong&gt;用户权限&lt;/strong&gt;是指用户对数据对象允许执行的操作类型，由&lt;strong&gt;数据对象&lt;/strong&gt;和&lt;strong&gt;操作类型&lt;/strong&gt;两个要素组成。&lt;/p&gt;

&lt;p&gt;对于用户存取权限的定义称为&lt;strong&gt;授权&lt;/strong&gt;。在授权中应指明：&lt;strong&gt;用户名、数据对象名、允许的操作类型&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;强制存取控制-mandatory-access-control-mac&quot;&gt;强制存取控制 (mandatory access control, MAC)&lt;/h5&gt;

&lt;p&gt;每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。&lt;strong&gt;对于任一个对象，只有具有合法许可证的用户才可以存取&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;强制存取方法&quot;&gt;强制存取方法&lt;/h4&gt;

&lt;p&gt;在 MAC 中，DBMS 所管理的全部实体被分为&lt;strong&gt;主体&lt;/strong&gt;和&lt;strong&gt;客体&lt;/strong&gt;两类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;主体&lt;/strong&gt;是系统中的活动实体，既包括 DBMS 所管理的&lt;strong&gt;实际用户&lt;/strong&gt;，也包括&lt;strong&gt;代表用户的各进程&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;客体&lt;/strong&gt;是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引、视图等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于主体和客体，DBMS 为他们每个实例指定一个&lt;strong&gt;敏感度标记 (Label)&lt;/strong&gt;。敏感度标记被分为若干级别，如&lt;strong&gt;绝密&lt;/strong&gt;、&lt;strong&gt;机密&lt;/strong&gt;、&lt;strong&gt;秘密&lt;/strong&gt;、&lt;strong&gt;公开&lt;/strong&gt;等。&lt;strong&gt;主体&lt;/strong&gt;的敏感度标记称为&lt;strong&gt;许可证级别&lt;/strong&gt;，&lt;strong&gt;客体&lt;/strong&gt;的敏感度标记称为&lt;strong&gt;密级&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;MAC 机制通过&lt;strong&gt;对比主体和客体的 Label&lt;/strong&gt;来确定是否能够存取。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;仅当主体的许可证级别&lt;strong&gt;大于或等于&lt;/strong&gt;客体的密级时，该主体才能&lt;strong&gt;读取&lt;/strong&gt;相应的客体。&lt;/li&gt;
  &lt;li&gt;当且仅当主体的许可证级别&lt;strong&gt;等于&lt;/strong&gt;客体的密级时，该主体才能&lt;strong&gt;写&lt;/strong&gt;相应的客体。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;其它方法&quot;&gt;其它方法&lt;/h4&gt;

&lt;h5 id=&quot;视图控制&quot;&gt;视图控制&lt;/h5&gt;

&lt;p&gt;为不同的用户定义不同的视图，可以将用户对数据的访问限制在一定的范围内。&lt;/p&gt;

&lt;h5 id=&quot;审计&quot;&gt;审计&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;把用户对数据库的所有曹祖都自动记录下来放入审计日志中&lt;/strong&gt;。DBA 可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。&lt;/p&gt;

&lt;h5 id=&quot;数据加密&quot;&gt;数据加密&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;防止数据库中数据在存储和传输中失密&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;sql-的数据安全性控制&quot;&gt;SQL 的数据安全性控制&lt;/h3&gt;

&lt;h4 id=&quot;用户权限&quot;&gt;用户权限&lt;/h4&gt;

&lt;h5 id=&quot;用户级权限&quot;&gt;用户级权限&lt;/h5&gt;

&lt;p&gt;是数据库管理员&lt;strong&gt;为每个用户授予的特定权限&lt;/strong&gt;，是对用户&lt;strong&gt;使用整个数据库权限的限定&lt;/strong&gt;。与整个数据库相关，与数据库中具体的关系无关。&lt;/p&gt;

&lt;h5 id=&quot;关系级权限&quot;&gt;关系级权限&lt;/h5&gt;

&lt;p&gt;是数据库管理员或数据库对象的拥有者为用户授予的&lt;strong&gt;与关系或视图有关的权限&lt;/strong&gt;，这种权限是对用户&lt;strong&gt;使用关系和视图权限的限定&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;角色与用户组&quot;&gt;角色与用户组&lt;/h4&gt;

&lt;p&gt;为了管理数据库特权的方便，数据库还支持&lt;strong&gt;角色与用户组&lt;/strong&gt;的概念。&lt;/p&gt;

&lt;h5 id=&quot;角色&quot;&gt;角色&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;角色是一组权限的集合&lt;/strong&gt;，可以把它授予用户或其他角色。当把某个角色授予用户（或角色）或从用户（或角色）收回时，就同时授予或收回了该角色代表的全部权限。&lt;/p&gt;

&lt;h5 id=&quot;用户组&quot;&gt;用户组&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;用户组是一组具有相同特性用户的集合&lt;/strong&gt;。在授权或收回权限时，可以以用户组为单位进行。&lt;/p&gt;

&lt;h4 id=&quot;授予grant-语句&quot;&gt;授予——&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grant&lt;/code&gt; 语句&lt;/h4&gt;

&lt;p&gt;在 SQL 语言中，通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grant&lt;/code&gt; 语句授予用户用户级权限或角色&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Grant &amp;lt;用户名权限&amp;gt;|&amp;lt;角色&amp;gt; [{, 用户级权限&amp;gt;|&amp;lt;角色&amp;gt;}]
	To &amp;lt;用户名&amp;gt;|&amp;lt;角色&amp;gt;|public [{, &amp;lt;用户名&amp;gt;|&amp;lt;角色&amp;gt;}] # public: 数据库中的全部用户
	[With Grant Option] # 允许被授权的用户将指定的用户级权限或角色授予其他用户
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DBA 和数据库对象所有者将这些数据库对象上的部分或全部权限授予其他用户。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Grant ALL | &amp;lt;权限&amp;gt; [{, &amp;lt;权限&amp;gt;}]
	On &amp;lt;表名&amp;gt;|&amp;lt;视图名&amp;gt; [{, &amp;lt;表名&amp;gt;|&amp;lt;视图名&amp;gt;}]
	To {&amp;lt;用户&amp;gt; [{, &amp;lt;用户&amp;gt;}] | public}
	[With Grant Option]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;收回revoke-语句&quot;&gt;收回——&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Revoke&lt;/code&gt; 语句&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Revoke &amp;lt;用户级权限&amp;gt;|&amp;lt;角色&amp;gt; [{, &amp;lt;用户级权限&amp;gt;|&amp;lt;角色&amp;gt;}]
	From &amp;lt;用户名&amp;gt;|&amp;lt;角色&amp;gt;|public [{, &amp;lt;用户名&amp;gt;|&amp;lt;角色&amp;gt;}]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Revoke ALL | &amp;lt;表级权限&amp;gt; [{, &amp;lt;表级权限&amp;gt;}]
	On &amp;lt;表名&amp;gt;|&amp;lt;视图名&amp;gt; [{, &amp;lt;表名&amp;gt;|&amp;lt;视图名&amp;gt;}]
	To {&amp;lt;用户&amp;gt; [{, &amp;lt;用户&amp;gt;}] | public}
	[With Grant Option]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;收回权限时，若该用户已将权限授予其他用户，则也一并收回&lt;/p&gt;

&lt;h3 id=&quot;可信计算机系统评测标准&quot;&gt;可信计算机系统评测标准&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;TCSEC (Trusted Computer System Evaluation Criteria)&lt;/li&gt;
  &lt;li&gt;TDI (Trusted Database Interpretation) / TCSEC&lt;/li&gt;
  &lt;li&gt;TDI 与 TCSEC 从安全策略、责任、保证、文档四个方面描述了安全级别划分的指标&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据库完整性控制&quot;&gt;数据库完整性控制&lt;/h2&gt;

&lt;h3 id=&quot;数据完整性含义&quot;&gt;数据完整性含义&lt;/h3&gt;

&lt;p&gt;数据完整性是指数据的&lt;strong&gt;正确性&lt;/strong&gt;和&lt;strong&gt;相容性&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;正确性&lt;/strong&gt;是指数据应具有合法的类型，并在有效的取值范围之内&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;相容性&lt;/strong&gt;是指表示同一个事实的两个数据应该相同&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据库能否保持完整性关系到数据库系统是否能够反映现实世界，因此维护数据库完整性十分重要。&lt;/p&gt;

&lt;h3 id=&quot;完整性约束条件&quot;&gt;完整性约束条件&lt;/h3&gt;

&lt;h4 id=&quot;定义-18&quot;&gt;定义&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;施加在数据库数据之上的语义约束条件&lt;/strong&gt;称为数据库完整性约束条件。数据库系统依据完整性约束条件进行完整性检查。&lt;/p&gt;

&lt;p&gt;作用对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;列&lt;/strong&gt;（主要是类型、取值范围、精度等）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;元组&lt;/strong&gt;（主要是各个字段间联系的约束）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;关系&lt;/strong&gt;（主要是若干元组间、关系间联系的约束）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分类-4&quot;&gt;分类&lt;/h4&gt;

&lt;h5 id=&quot;静态约束&quot;&gt;静态约束&lt;/h5&gt;

&lt;p&gt;静态约束是指数据库在每一&lt;strong&gt;确定状态&lt;/strong&gt;数据对象所应满足的约束条件，它是&lt;strong&gt;反映数据库状态合理性的约束&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;静态列级约束&lt;/strong&gt;是对一个列的取值域的说明，包括对数据类型（类型、长度、单位、精度等）、数据格式、取值范围或取值集合、空值等的约束。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;静态元组约束&lt;/strong&gt;规定了组成一个元组的各个列之间的约束关系。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;静态关系约束&lt;/strong&gt;规定了一个关系的若干元组或者若干关系之间常常存在的各种联系或约束。包括：实体完整性约束、参照完整性约束、函数依赖、统计约束等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;动态约束&quot;&gt;动态约束&lt;/h5&gt;

&lt;p&gt;动态约束是指数据库从一种状态转变为另一种状态时，&lt;strong&gt;新、旧值之间&lt;/strong&gt;所应满足的约束条件，它是&lt;strong&gt;反映数据库状态变迁的约束&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;动态列级约束&lt;/strong&gt;是修改列定义或列值时应满足的约束条件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;动态元组约束&lt;/strong&gt;指修改元组指时元组中各个字段间需要满足的约束。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;动态关系约束&lt;/strong&gt;指加载关系变化前后状态上的限制条件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;完整性控制&quot;&gt;完整性控制&lt;/h3&gt;

&lt;h4 id=&quot;包括&quot;&gt;包括&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;定义功能&lt;/strong&gt;：提供定义完整性约束条件的机制&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;检查功能&lt;/strong&gt;：检查用户发出的操作请求是否违背了完整性约束条件&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;违约响应&lt;/strong&gt;：若违背了完整性约束条件，则采取一定措施来保证数据的完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分类-5&quot;&gt;分类&lt;/h4&gt;

&lt;h5 id=&quot;立即执行约束&quot;&gt;立即执行约束&lt;/h5&gt;

&lt;p&gt;在执行用户事务的过程中，在&lt;strong&gt;一条语句执行完后&lt;/strong&gt;立即进行完整性约束的检查。若违背了完整性约束，系统将拒绝&lt;strong&gt;该操作&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;延迟执行约束&quot;&gt;延迟执行约束&lt;/h5&gt;

&lt;p&gt;在&lt;strong&gt;整个用户事务执行完毕后&lt;/strong&gt;，再进行完整性约束检查，结果正确方能提交，否则系统将拒绝&lt;strong&gt;整个事务&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;完整性规则的表示&quot;&gt;完整性规则的表示&lt;/h4&gt;

&lt;p&gt;用五元组 (D, O, A, C, P) 表示&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;D&lt;/strong&gt; (Data) 约束所作用的数据对象&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;O&lt;/strong&gt; (Operation) 除法完整性检查的数据库操作&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A&lt;/strong&gt; (Assertion) 数据对象必须满足的断言或语义约束&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;C&lt;/strong&gt; (Condition) 选择 A 作用的数据对象值的谓词&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;P&lt;/strong&gt; (Procedure) 违反完整性规则时除法的过程&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sql-支持&quot;&gt;SQL 支持&lt;/h4&gt;

&lt;h5 id=&quot;create-table&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CREATE TABLE&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;Create Table &amp;lt;表名&amp;gt;
	(&amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt; [&amp;lt;列级完整性约束&amp;gt;]
    [{, &amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt; [&amp;lt;列级完整性约束&amp;gt;]}]
    [{, &amp;lt;表级完整性约束&amp;gt;}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，完整性约束可以是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;NULL / NOTNULL
UNIQUE
PRIMARY KEY
FOREIGN KEY
CHECK
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;assertion-断言&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASSERTION&lt;/code&gt; 断言&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;CREATE ASSERTION &amp;lt;断言名&amp;gt; &amp;lt;CHECK 子句&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;trigger-触发器&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TRIGGER&lt;/code&gt; 触发器&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;触发器&lt;/strong&gt; (Trigger) 是用户定义再关系上的一类由事件驱动的特殊过程&lt;/p&gt;

&lt;p&gt;对于用户对表的更新操作，系统自动激活相应触发器，执行完整性控制&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;CREATE TRIGGER &amp;lt;触发其名称&amp;gt;
	{BEFORE | AFTER} &amp;lt;触发器事件&amp;gt; ON &amp;lt;表名&amp;gt;
	REFERENCING NEW | OLD ROW AS &amp;lt;变量&amp;gt;
	FOR EACH {ROW|STATEMENT}
	[WHEN &amp;lt;触发条件&amp;gt;]
	&amp;lt;触发动作体&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;第四部分-数据库新技术&quot;&gt;第四部分 数据库新技术&lt;/h1&gt;

&lt;h2 id=&quot;数据仓库-data-warehouse&quot;&gt;数据仓库 (Data Warehouse)&lt;/h2&gt;

&lt;h3 id=&quot;定义-19&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;数据仓库&lt;/strong&gt;(Data Warehouse) 1990 年提出，是&lt;strong&gt;支持管理决策过程&lt;/strong&gt;的、&lt;strong&gt;面向主题&lt;/strong&gt;的、集成的、随时间而增长的持久数据集合。&lt;/p&gt;

&lt;h3 id=&quot;业务&quot;&gt;业务&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;数据仓库上的业务处理称作 &lt;strong&gt;OLAP&lt;/strong&gt; (On-line Analytical Processing)，即&lt;strong&gt;联机分析处理&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;数据库上的业务处理称作 &lt;strong&gt;OLTP&lt;/strong&gt; (On-line Transaction Processing)，即&lt;strong&gt;联机事务处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;新时代数据管理面临的挑战&quot;&gt;新时代数据管理面临的挑战&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;数据量&lt;/strong&gt;：互联网时代，数据量呈指数级飞速增长，从 TB 到 PB 或更多&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;用户数&lt;/strong&gt;：从几千人到几亿人&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;非结构化数据&lt;/strong&gt;占总数据量的 80% 以上&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据库管理技术的新发展&quot;&gt;数据库管理技术的新发展&lt;/h2&gt;

&lt;h3 id=&quot;sql&quot;&gt;SQL&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;传统关系型数据库，支持 SQL 操作，事务 ACID 特性&lt;/li&gt;
  &lt;li&gt;几千用户，TB 级数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nosql&quot;&gt;NoSQL&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Not Only SQL，非关系型的数据库，水平可扩展、分布式&lt;/li&gt;
  &lt;li&gt;不使用 SQL，不支持事务的 ACID 操作&lt;/li&gt;
  &lt;li&gt;HBase, MongoDB 等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;newsql&quot;&gt;NewSQL&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;新的可扩展 / 高性能数据库&lt;/li&gt;
  &lt;li&gt;不仅具有 NoSQL 的海量数据存储管理能力，还保持了传统数据库支持 ACID 和 SQL 等特性&lt;/li&gt;
  &lt;li&gt;VoltDB, ScaleBase, 阿里 DRDS 等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第九章-分布式数据库系统&quot;&gt;第九章 分布式数据库系统&lt;/h2&gt;

&lt;h3 id=&quot;基本概念-1&quot;&gt;基本概念&lt;/h3&gt;

&lt;h4 id=&quot;定义-20&quot;&gt;定义&lt;/h4&gt;

&lt;p&gt;分布式数据库是由一组分布再计算机网络的&lt;strong&gt;不同结点上的数据&lt;/strong&gt;组成，&lt;strong&gt;每个结点具有独立的处理能力（称为场地自治），可以执行局部应用，同时每个结点也能通过网络通信支持全局应用&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;局部应用&lt;/strong&gt;：只操作一个结点上数据库的应用&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;全局应用&lt;/strong&gt;：操作两个或两个以上结点上的数据库的应用&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;特点&quot;&gt;特点&lt;/h4&gt;

&lt;p&gt;分布式数据库以“&lt;strong&gt;数据分布&lt;/strong&gt;”为前提，强调&lt;strong&gt;场地自治性（局部应用）&lt;/strong&gt;以及&lt;strong&gt;自治场地之间的协作性（全局应用）&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;场地自治性&lt;/strong&gt;：每个场地有自己的数据库、一组终端，运行局部 DBMS，是独立的 DBS，具有高度自治性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;自治场地之间的协作性&lt;/strong&gt;：各结点组成整体。整体性的含义是，从用户角度看，&lt;strong&gt;分布式数据库系统逻辑上如同一个集中式数据库一样&lt;/strong&gt;，用户可以再任何场地执行全局应用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分布式数据库系统的特点有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;数据独立性&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;数据的逻辑独立性和物理独立性&lt;/li&gt;
      &lt;li&gt;数据的&lt;strong&gt;分布独立性（也称分布透明性）&lt;/strong&gt;：数据的逻辑分片、数据物理位置分布的细节、重复剧本（冗余数据）一致性问题、局部结点上的数据模型等域用户程序无关。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;集中与自治相结合的控制结构&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;数据的共享有两个层次
        &lt;ul&gt;
          &lt;li&gt;一是&lt;strong&gt;局部共享&lt;/strong&gt;。即在局部数据库中存储局部结点各用户的共享数据&lt;/li&gt;
          &lt;li&gt;二是&lt;strong&gt;全局共享&lt;/strong&gt;。即在分布式数据库系统的各个结点也存储供其他结点的用户共享的数据，支持系统的全局应用。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;分布式数据库系统常常采用集中和自治相结合的控制结构
        &lt;ul&gt;
          &lt;li&gt;各局部的 DBMS 可以独立的管理局部的数据库，具有&lt;strong&gt;自治功能&lt;/strong&gt;。&lt;/li&gt;
          &lt;li&gt;系统又设有&lt;strong&gt;集中控制结构&lt;/strong&gt;，协调各局部 DBMS 的工作，执行全局应用。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;适当增加数据冗余&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;在分布式数据库系统中适当的增加了冗余数据，&lt;strong&gt;在不同的结点存储同一数据的多个副本&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;在提高系统的可靠性、可用性&lt;/strong&gt;，当某一结点出现故障时，系统可以对另一结点的相同副本进行操作，不会因为一处故障而造成整个系统的瘫痪。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;提高系统性能&lt;/strong&gt;，系统可以选择用户最近的数据副本来进行操作，减少通信代价，改善整个系统的性能。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;不利于更新，增加了系统维护的代价&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;全局的一致性、可串行性和可恢复性
    &lt;ul&gt;
      &lt;li&gt;分布式数据库除了各局部数据库应满足集中式数据库的一致性、可串行性和可恢复性以外，还应保证数据库的&lt;strong&gt;全局一致性、并行操作的可串行性和系统的全局可恢复性&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;体系结构&quot;&gt;体系结构&lt;/h3&gt;

&lt;h4 id=&quot;模式结构&quot;&gt;模式结构&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;全局外模式及全局外模式 / 全局概念模式映像&lt;/strong&gt;（映像 1）&lt;/p&gt;

    &lt;p&gt;全局外模式全局应用的用户视图，是全局概念模式的子集；映像 1 定义全局外模式到全局概念模式的映像。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;全局概念模式&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;定义分布式数据库中数据的整体逻辑结构，使得数据如同没有分布一样&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;分片模式及全局概念模式 / 分片模式映像&lt;/strong&gt;（映像2）&lt;/p&gt;

    &lt;p&gt;每一个全局关系可以分为若干互不相交的部分，每一部分称为一个&lt;strong&gt;片段&lt;/strong&gt;。分片模式及映像2定义片段以及全局关系到片段的映像。这种映像是一对多的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;分布模式及分片模式 / 分布模式映像&lt;/strong&gt;（映像 3）&lt;/p&gt;

    &lt;p&gt;定义片段的存放结点及片段到结点的映像。分布模式的映像类型确定了分布式数据库是冗余的还是非冗余的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;分布模式 / 局部数据库概念模式映像&lt;/strong&gt;（映像 4）&lt;/p&gt;

    &lt;p&gt;该映像把存储在局部场地的全局关系或全局关系的片段映像为各局部概念模式。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/ddbms.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;数据分片&quot;&gt;数据分片&lt;/h4&gt;

&lt;h5 id=&quot;水平分片&quot;&gt;水平分片&lt;/h5&gt;

&lt;p&gt;将关系依照一定条件&lt;strong&gt;按行&lt;/strong&gt;分为不相交的若干子集，每个子集称为一个水平片段。&lt;/p&gt;

&lt;h5 id=&quot;垂直分片&quot;&gt;垂直分片&lt;/h5&gt;

&lt;p&gt;将关系&lt;strong&gt;按列&lt;/strong&gt;分为若干属性子集，每个子集称为一个垂直片段。垂直分片的片段通过连接的方法恢复原关系。因此&lt;strong&gt;垂直分片的诸片段通常都包含关系的码&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;导出分片&quot;&gt;导出分片&lt;/h5&gt;

&lt;p&gt;导出水平分片，分片的条件不是关系本身属性条件，而是其它关系的属性条件。&lt;/p&gt;

&lt;h5 id=&quot;混合分片&quot;&gt;混合分片&lt;/h5&gt;

&lt;p&gt;指按上述三种分片方式得到的片段，继续按另一种方式分片&lt;/p&gt;

&lt;h5 id=&quot;数据分片的约束&quot;&gt;数据分片的约束&lt;/h5&gt;

&lt;h6 id=&quot;完全性&quot;&gt;完全性&lt;/h6&gt;

&lt;p&gt;一个全局关系中的数据&lt;strong&gt;必须完全划分为若干片段&lt;/strong&gt;，不允许某些数据属于全局关系但不属于任何片段。&lt;/p&gt;

&lt;h6 id=&quot;不相交性&quot;&gt;不相交性&lt;/h6&gt;

&lt;p&gt;不允许一个全局关系的某些数据既属于该全局关系的某一个片段，又属于另一个片段（垂直分片的码属性除外）&lt;/p&gt;

&lt;h6 id=&quot;可重构性&quot;&gt;可重构性&lt;/h6&gt;

&lt;p&gt;可以由片段重构全局关系&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;垂直分片可用连接操作重构&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;水平分片可用并操作重构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分布透明性&quot;&gt;分布透明性&lt;/h4&gt;

&lt;h5 id=&quot;分片透明性&quot;&gt;分片透明性&lt;/h5&gt;

&lt;p&gt;用户或应用程序只对全局关系进行操作而不必考虑关系的分片。它是分布透明性的&lt;strong&gt;最高层次&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;位置透明性&quot;&gt;位置透明性&lt;/h5&gt;

&lt;p&gt;用户或应用程序不必了解片段的存储场地也不必关系各数据副本的一致性&lt;/p&gt;

&lt;h5 id=&quot;局部数据模型透明性&quot;&gt;局部数据模型透明性&lt;/h5&gt;

&lt;p&gt;用户或应用程序不必了解局部场地上是哟个的是哪一种数据模型。模型的转换以及查询语言等的转换均由分布式 / 局部概念模式（映像 4）完成&lt;/p&gt;

&lt;h4 id=&quot;分布式数据库管理系统-ddbms&quot;&gt;分布式数据库管理系统 DDBMS&lt;/h4&gt;

&lt;h5 id=&quot;组成&quot;&gt;组成&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;LDBMS&lt;/strong&gt;（局部场地上的数据库管理系统）
    &lt;ul&gt;
      &lt;li&gt;功能：建立和管理局部数据库，提供场地自治能力，执行局部应用及全局查询的子查询。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GDBMS&lt;/strong&gt;（全局数据库管理系统）
    &lt;ul&gt;
      &lt;li&gt;功能：提供分布透明性，协调全局事务的执行，协调各局部 DBMS 以完成全局应用，并保证数据库的全局一致性，执行并发控制，实现更新同步，提供全局恢复功能&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GDD&lt;/strong&gt;（全局数据字典）
    &lt;ul&gt;
      &lt;li&gt;存放全局概念模式、分片模式、分布模式的定义以及各模式之间映像的定义&lt;/li&gt;
      &lt;li&gt;存放有关用户存取权限的定义，以保证全局用户的合法权限和数据库的安全性&lt;/li&gt;
      &lt;li&gt;存放数据完整性约束条件的定义&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CM&lt;/strong&gt;（通信管理）
    &lt;ul&gt;
      &lt;li&gt;在分布式数据库各场地之间传递消息和数据，完成通信功能&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;分类-6&quot;&gt;分类&lt;/h5&gt;

&lt;h6 id=&quot;按全局控制方式分类&quot;&gt;按全局控制方式分类&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;全局控制集中的 DDBMS&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;特点：GDBMS 集中在某一结点上，GDD 只有一个，也放在该结点上&lt;/li&gt;
      &lt;li&gt;优点：控制简单，容易设计实现&lt;/li&gt;
      &lt;li&gt;缺点：易形成瓶颈，并且一旦该结点出现故障，整个系统将瘫痪&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;全局控制分散的 DDBMS&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;特点：GDBMS 分散在每一个结点上，GDD 也在每个结点上有一份。这类结构称为&lt;strong&gt;完全分布的 DDBMS&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;优点：结点独立、自治性强，单个结点出席那问题不会使系统瘫痪&lt;/li&gt;
      &lt;li&gt;缺点：全局控制的协调机制和一致性维护都比较复杂&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;全局控制部分分散的&lt;/strong&gt; &lt;strong&gt;DDBMS&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;根据应用的需要将全局数据库管理器和全局数据字典分散在&lt;strong&gt;某些&lt;/strong&gt;结点上，介于上述两者之间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;按局部-dbms-的类型分类&quot;&gt;按局部 DBMS 的类型分类&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;同构型 DDBMS&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;每个结点的局部数据库具有相同的 DBMS，即使硬件与操作系统互不相同&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;异构型 DDBMS&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;各结点的局部数据库具有不同的 DBMS&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;主要技术&quot;&gt;主要技术&lt;/h3&gt;

&lt;h4 id=&quot;分布式查询处理和优化&quot;&gt;分布式查询处理和优化&lt;/h4&gt;

&lt;h5 id=&quot;分布式查询类型与处理过程&quot;&gt;分布式查询类型与处理过程&lt;/h5&gt;

&lt;p&gt;分为局部查询、远程查询和全局查询&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;局部查询和远程查询&lt;strong&gt;只涉及单个结点的数据&lt;/strong&gt;（本地或远程），可以采用&lt;strong&gt;集中式数据库的处理技术&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;全局查询涉及到多个结点的数据，十分复杂&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;分布式查询处理过程&quot;&gt;分布式查询处理过程&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;查询分解&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;把查询操作分解为若干子查询，每个子查询只涉及某一个结点的数据，可由局部 DBMS 处理。必须选择查询开销最省的哪些结点（物理片段）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;选择操作执行次序&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;确定涉及不同结点上关系的连接和并操作的次序&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;选择执行操作的算法&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;包括选择存取路径、选择某种操作的算法以及连接的执行方法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;查询优化的目标&quot;&gt;查询优化的目标&lt;/h5&gt;

&lt;p&gt;首要目标是：&lt;strong&gt;使查询执行时通信代价最省&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不同结点之间的连接操作和并操作是数据传输的主要原因，因此连接查询的优化是优化中需要研究的中重要问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;连接查询的优化&quot;&gt;连接查询的优化&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;半连接&lt;/strong&gt;：使用半连接来缩减关系（或片段）进而节省传输的开销
    &lt;ul&gt;
      &lt;li&gt;定义&lt;img src=&quot;/assets/images/post/half.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;性质 &lt;img src=&quot;/assets/images/post/half1.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分布式事务管理&quot;&gt;分布式事务管理&lt;/h4&gt;

&lt;h5 id=&quot;分布事务的原子性和可串行性&quot;&gt;分布事务的原子性和可串行性&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;在分布式数据库系统中，一个全局事务被划分为许多结点上的子事务&lt;/li&gt;
  &lt;li&gt;分布事务的&lt;strong&gt;原子性&lt;/strong&gt;是：组成该事务的所有子事务要么一致的全部提交，要么一致的全部回滚&lt;/li&gt;
  &lt;li&gt;在多用户系统中，还必须保证分布式数据的&lt;strong&gt;可串行性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;事务的恢复&quot;&gt;事务的恢复&lt;/h5&gt;

&lt;p&gt;每个场地都有一个&lt;strong&gt;局部事务管理器&lt;/strong&gt;，负责管理局部子事务的执行。同时，&lt;strong&gt;各局部事务管理器之间必须有相互协调，保证分布事务的原子性&lt;/strong&gt;：各子事务要么都提交，要么都回滚&lt;/p&gt;

&lt;p&gt;对局部事务管理进行协调，保证分布事务原子性最常用的技术——&lt;strong&gt;两段提交协议&lt;/strong&gt; (2-Phase-Commitment Protocol)&lt;/p&gt;

&lt;h6 id=&quot;两段提交协议-2-phase-commitment-protocol&quot;&gt;两段提交协议 (2-Phase-Commitment Protocol)&lt;/h6&gt;

&lt;p&gt;把分布事务的所有局部事务管理分为两类：&lt;strong&gt;协调者&lt;/strong&gt;（一个），&lt;strong&gt;参与者&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;协调者&lt;/strong&gt;：负责作出该事务是提交还是撤销的最后决定&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;参与者&lt;/strong&gt;：负责管理相应于子事务的执行以及在各自局部数据库上执行写操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;内容&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;第一阶段：协调者征求意见做决定&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;协调者向所有参与者发出”准备提交“信息，并记入日志；参与者准备提交就回答”就绪“，否则回答”撤销“，并记入日志&lt;/li&gt;
      &lt;li&gt;如果在规定时间内，协调者收到所有参与者的”就绪“信息，则做出”提交“决定，否则”撤销“&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;第二阶段：参与者执行决定&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;协调者将有关决定写入日志，然后把这个决定发送给所有参与者&lt;/li&gt;
      &lt;li&gt;所有参与者收到命令后，首先在日志中记入”收到提交 / 撤销决定“的信息，并向协调者发送应答信息，最后执行相应决定。&lt;/li&gt;
      &lt;li&gt;协调者收到所有参与者的应答消息后，一个事务的执行到此结束。有关日志信息可以脱机保存。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;采用两段提交协议后，当系统发生故障时，各场地利用各自有关的日志进行事务恢复&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;事务的并发控制&quot;&gt;事务的并发控制&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;分布式数据库系统中的并发控制也可以采用&lt;strong&gt;封锁技术&lt;/strong&gt;，但更加复杂
    &lt;ul&gt;
      &lt;li&gt;分布式数据库系统支持&lt;strong&gt;多副本&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;由于事务的分布执行，封锁的方法会引起&lt;strong&gt;全局死锁&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;策略：
    &lt;ul&gt;
      &lt;li&gt;处理多副本封锁的几种可能方法
        &lt;ul&gt;
          &lt;li&gt;对&lt;strong&gt;写&lt;/strong&gt;操作，要申请&lt;strong&gt;所有&lt;/strong&gt;副本的 X 锁；对&lt;strong&gt;读&lt;/strong&gt;操作，只要申请&lt;strong&gt;某个&lt;/strong&gt;副本的 S 锁。&lt;/li&gt;
          &lt;li&gt;无论是写操作还是读操作都要对&lt;strong&gt;大多数&lt;/strong&gt;副本申请 X 锁或 S 锁&lt;/li&gt;
          &lt;li&gt;规定某个场地上的副本为主副本，所有的读、写操作均申请对主副本的封锁&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;解决全局自锁（两个以上场地上发生死锁）
        &lt;ul&gt;
          &lt;li&gt;死锁检测及解除方式&lt;/li&gt;
          &lt;li&gt;死锁预防&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>ericaaaaaaaa</name></author><category term="Data" /><category term="note" /><category term="data" /><category term="database" /><summary type="html">数据库系统原理</summary></entry><entry><title type="html">Artificial Intelligence</title><link href="http://localhost:4000/artificialintelligence/2022/01/03/ArtificialIntelligence.html" rel="alternate" type="text/html" title="Artificial Intelligence" /><published>2022-01-03T00:00:00+08:00</published><updated>2022-01-03T00:00:00+08:00</updated><id>http://localhost:4000/artificialintelligence/2022/01/03/ArtificialIntelligence</id><content type="html" xml:base="http://localhost:4000/artificialintelligence/2022/01/03/ArtificialIntelligence.html">&lt;h1 id=&quot;loss-function&quot;&gt;Loss Function&lt;/h1&gt;

&lt;h2 id=&quot;regularization-add-term-to-loss&quot;&gt;Regularization: Add term to loss&lt;/h2&gt;

&lt;p&gt;$L=\frac{1}{N}\sum_{i=1}^{N}\sum_{j\not= y_i}\max(0, f(x_i;W)&lt;em&gt;j-f(x_i;W)&lt;/em&gt;{y_i}+1)+\lambda R(W)$&lt;/p&gt;

&lt;p&gt;In common use:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/reg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dropout&quot;&gt;Dropout&lt;/h3&gt;

&lt;p&gt;In each forward pass, randomly set some neurons to zero&lt;/p&gt;

&lt;p&gt;Probability of dropping is a hyperparameter; 0.5 is common&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/drop.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;data-augmentation&quot;&gt;Data Augmentation&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Horizontal Flipping 水平翻转&lt;/li&gt;
  &lt;li&gt;Random Cropping 随机裁剪&lt;/li&gt;
  &lt;li&gt;Random Scaling 随机放缩&lt;/li&gt;
  &lt;li&gt;Color Jittering 颜色抖动&lt;/li&gt;
  &lt;li&gt;Random Translation 随机平移&lt;/li&gt;
  &lt;li&gt;Random Shearing 随机剪切&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;regression&quot;&gt;Regression&lt;/h2&gt;

&lt;h3 id=&quot;l1-loss&quot;&gt;L1 Loss&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$L(y, \hat{y})=w(\theta)&lt;/td&gt;
      &lt;td&gt;\hat{y}-y&lt;/td&gt;
      &lt;td&gt;$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;l2-loss&quot;&gt;L2 Loss&lt;/h3&gt;

&lt;p&gt;$L(y, \hat{y})=w(\theta)(\hat{y}-y)^2$&lt;/p&gt;

&lt;h2 id=&quot;classification&quot;&gt;Classification&lt;/h2&gt;

&lt;h3 id=&quot;hinge-loss-function-铰链损失函数&quot;&gt;Hinge Loss Function 铰链损失函数&lt;/h3&gt;

&lt;p&gt;$L(y, \hat{y}) = \max{(0, 1-\hat{y}y)}$&lt;/p&gt;

&lt;p&gt;$y\in{-1, 1}$&lt;/p&gt;

&lt;h3 id=&quot;cross-entropy-loss-function-交叉熵损失函数&quot;&gt;Cross-Entropy Loss Function 交叉熵损失函数&lt;/h3&gt;

&lt;p&gt;In binary classification, $L(y, \hat{y}) = -y\log{(\hat{y})}-(1-y)\log{(1-\hat{y})}$&lt;/p&gt;

&lt;p&gt;In multiclass classification (class number = M), $L(y) = -\sum_{c=1}^My_o, c\log{(p_o, c)}$&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;M - number of classes (dog, cat, fish)&lt;/li&gt;
    &lt;li&gt;log - the natural log&lt;/li&gt;
    &lt;li&gt;y - binary indicator (0 or 1) if class label cc is the correct classification for observation $o$&lt;/li&gt;
    &lt;li&gt;p - predicted probability observation $o$ is of class $c$&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;exponential-loss-function-指数损失函数&quot;&gt;Exponential Loss Function 指数损失函数&lt;/h3&gt;

&lt;p&gt;$L(y,\hat{y}) = \exp{(-y\hat{y})}$&lt;/p&gt;

&lt;h2 id=&quot;sgd-stochastic-gradient-descent-随机梯度下降&quot;&gt;SGD, Stochastic Gradient Descent 随机梯度下降&lt;/h2&gt;

&lt;p&gt;在梯度下降时，为了加快收敛速度，通常使用一些优化方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/sgd.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SGD每次都会在当前位置上沿着负梯度方向更新（下降，沿着正梯度则为上升），并不考虑之前的方向梯度大小等等。而动量（moment）通过引入一个新的变量 v去积累之前的梯度（通过指数衰减平均得到），得到加速学习过程的目的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最直观的理解就是，若当前的梯度方向与累积的历史梯度方向一致，则当前的梯度会被加强，从而这一步下降的幅度更大。若当前的梯度方向与累积的梯度方向不一致，则会减弱当前下降的梯度幅度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;nesterov-momentum&quot;&gt;Nesterov Momentum&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180518154303163&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ada-grad-adaptive-gradient&quot;&gt;Ada Grad (Adaptive Gradient)&lt;/h3&gt;

&lt;p&gt;通常，我们在每一次更新参数时，对于所有的参数使用相同的学习率。而AdaGrad算法的思想是：每一次更新参数时（一次迭代），不同的参数使用不同的学习率。&lt;/p&gt;

&lt;p&gt;Added element-wise scaling of the gradient based on the historical sum of squares in each dimension.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/ada.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;rmsprop-leaky-adagrad&quot;&gt;RMSProp: “Leaky AdaGrad”&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/rms.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;adam&quot;&gt;Adam&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/adam.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Adam with beta1 = 0.9, beta2 = 0.999, and learning_rate = 1e-3 or 5e-4 is a great starting point for many models&lt;/p&gt;

&lt;h1 id=&quot;gradient-descent&quot;&gt;Gradient Descent&lt;/h1&gt;

&lt;h2 id=&quot;1-dimension&quot;&gt;1 Dimension&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Randomly pick an initial value $w^0$&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Compute $\frac{\partial L}{\partial w}&lt;/td&gt;
          &lt;td&gt;_{w=w^0}$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;$w^1\gets w^0-\eta\frac{\partial L}{\partial w}&lt;/td&gt;
          &lt;td&gt;_{w=w^0}$, where $\eta$ stands for &lt;strong&gt;learning rate&lt;/strong&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-dimension&quot;&gt;2 Dimension&lt;/h2&gt;

&lt;p&gt;$y=wx_1+b$&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Randomly pick an initial value $w^0, b^0$&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Compute $\frac{\partial L}{\partial w}&lt;/td&gt;
          &lt;td&gt;_{w=w^0}$, $\frac{\partial L}{\partial b}&lt;/td&gt;
          &lt;td&gt;_{w=w^0, b=b^0}$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Update $w$ and $b$ iteratively: $w^1\gets w^0-\eta\frac{\partial L}{\partial w}&lt;/td&gt;
          &lt;td&gt;_{w=w^0}$, $b^1\gets b^0-\eta\frac{\partial L}{\partial b}&lt;/td&gt;
          &lt;td&gt;_{w=w^0, b=b^0}$, where $\eta$ stands for &lt;strong&gt;learning rate&lt;/strong&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;learning-rate-decay&quot;&gt;Learning rate decay&lt;/h2&gt;

&lt;h3 id=&quot;step&quot;&gt;Step&lt;/h3&gt;

&lt;p&gt;Reduce learning rate at a few fixed points. E.g. for ResNets, multiply LR by 0.1 after epochs 30, 60, and 90&lt;/p&gt;

&lt;h3 id=&quot;cosine&quot;&gt;Cosine&lt;/h3&gt;

&lt;p&gt;$\alpha_t=\frac{1}{2}\alpha_0(1+\cos (t\pi/T))$&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\alpha_0$: initial learning rate&lt;/li&gt;
  &lt;li&gt;$\alpha_t$: learning rate at epoch t&lt;/li&gt;
  &lt;li&gt;$T$: total number of epochs&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linear&quot;&gt;Linear&lt;/h3&gt;

&lt;p&gt;$\alpha_t=\alpha_0(1-t/T)$&lt;/p&gt;

&lt;h3 id=&quot;inverse-sqrt&quot;&gt;Inverse Sqrt&lt;/h3&gt;

&lt;p&gt;$\alpha_t = \alpha_1/\sqrt{t}$&lt;/p&gt;

&lt;h2 id=&quot;looking-at-learning-curves&quot;&gt;Looking at learning curves&lt;/h2&gt;

&lt;p&gt;Losses may be noisy, use a scatter plot and also plot moving average to see trends better.&lt;/p&gt;

&lt;h1 id=&quot;activation-function&quot;&gt;Activation Function&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;introduce non-linear properties to the network&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/activationFunction.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sigmoid&quot;&gt;Sigmoid&lt;/h2&gt;

&lt;h3 id=&quot;formula&quot;&gt;Formula&lt;/h3&gt;

\[\sigma(x) = \frac{1}{1+e^{-x}}\]

&lt;h3 id=&quot;features&quot;&gt;Features&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Squashes numbers to range &lt;strong&gt;[0, 1]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;problems&quot;&gt;Problems&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Saturated neurons &lt;strong&gt;“kill” the gradients&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sigmoid outputs are &lt;strong&gt;not zero-centered&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;The gradient on $w$ is always all positive or negative, so the gradient can upgrade in only one direction.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A bit &lt;strong&gt;compute expensive&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tanh&quot;&gt;Tanh&lt;/h2&gt;

&lt;h3 id=&quot;formula-1&quot;&gt;Formula&lt;/h3&gt;

\[\tanh(x) = \frac{\sinh(x)}{\cosh(x)}=\frac{e^x-e^{-x}}{e^x+e^{-x}}\]

&lt;h3 id=&quot;features-1&quot;&gt;Features&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Squashes number to range &lt;strong&gt;[-1, 1]&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Zero centered&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;problems-1&quot;&gt;Problems&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Saturated neurons &lt;strong&gt;“kill” the gradients&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;relu&quot;&gt;ReLU&lt;/h2&gt;

&lt;h3 id=&quot;formula-2&quot;&gt;Formula&lt;/h3&gt;

\[f(x) = \max(0, x)\]

&lt;h3 id=&quot;features-2&quot;&gt;Features&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Does not saturate&lt;/strong&gt; (in &amp;gt;0 region)&lt;/li&gt;
  &lt;li&gt;Very &lt;strong&gt;computationally efficient&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Converges much &lt;strong&gt;faster&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;More biologically plausible&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;problems-2&quot;&gt;Problems&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Not zero-centered&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;“kill” the gradients&lt;/strong&gt; (in $\le$ 0 region), what we called the &lt;em&gt;“dead ReLU”&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;leaky-relu&quot;&gt;Leaky ReLU&lt;/h2&gt;

&lt;h3 id=&quot;formula-3&quot;&gt;Formula&lt;/h3&gt;

\[f(x) = \max(0.01x, x)\]

&lt;h3 id=&quot;features-3&quot;&gt;Features&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Does &lt;strong&gt;not saturate&lt;/strong&gt; (in &amp;gt;0 region)&lt;/li&gt;
  &lt;li&gt;Vary &lt;strong&gt;computationally efficient&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Converges much &lt;strong&gt;faster&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Will &lt;strong&gt;not “die”&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;

&lt;h4 id=&quot;parametric-rectifier-prelu&quot;&gt;Parametric Rectifier (PReLU)&lt;/h4&gt;

\[f(x) = \max(\alpha x, x)\]

&lt;h2 id=&quot;elu&quot;&gt;ELU&lt;/h2&gt;

&lt;h3 id=&quot;formula-4&quot;&gt;Formula&lt;/h3&gt;

\[f(x) = \left\{ \begin{array}{lc} x &amp;amp; if\ x &amp;gt; 0\\\alpha(\exp{(x)}-1) &amp;amp; if\ x \le 0\end{array}\right.\]

&lt;h3 id=&quot;features-4&quot;&gt;Features&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;All&lt;/strong&gt; benefits of ReLU&lt;/li&gt;
  &lt;li&gt;Closer to zero mean outputs&lt;/li&gt;
  &lt;li&gt;Negative saturation regime compared with Leaky ReLU adds some robustness to noise&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;problems-3&quot;&gt;Problems&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Computation requires exp()&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;maxout&quot;&gt;Maxout&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is also another popular variant called &lt;em&gt;maxout&lt;/em&gt; which is the generalized form above relu and leaky relu.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;formula-5&quot;&gt;Formula&lt;/h3&gt;

\[\max(w_1^T x+b_1, w_2^T x+b_2)\]

&lt;h3 id=&quot;features-5&quot;&gt;Features&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Generalizes&lt;/strong&gt; ReLU and Leaky ReLU&lt;/li&gt;
  &lt;li&gt;Does &lt;strong&gt;not saturate&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Does &lt;strong&gt;not die&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;problems-4&quot;&gt;Problems&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Doubles the number of parameters / neuron&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;layers&quot;&gt;Layers&lt;/h1&gt;

&lt;h2 id=&quot;fully-connected-layer&quot;&gt;Fully Connected Layer&lt;/h2&gt;

&lt;p&gt;dot product&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/q1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;convolution-layer&quot;&gt;Convolution Layer&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/cnn.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Number of parameters in the layer: $K\times (F^2\times C + 1)$&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$+1$ for bias&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;gans-generative-adversarial-network-生成对抗网络&quot;&gt;GANS, Generative Adversarial Network 生成对抗网络&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/gan.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;generative-model-g-生成器&quot;&gt;Generative Model G 生成器&lt;/h2&gt;

&lt;p&gt;Captures data distribution and generate samples close to real distribution&lt;/p&gt;

&lt;h2 id=&quot;discriminative-model-d-判别器&quot;&gt;Discriminative Model D 判别器&lt;/h2&gt;

&lt;p&gt;Estimates the probability that a sample came from the training data rather than G&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/q0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/q2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/q3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/t0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/t1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/t2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/t3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>ericaaaaaaaa</name></author><category term="ArtificialIntelligence" /><category term="note" /><category term="artificial-intelligence" /><summary type="html">Loss Function</summary></entry><entry><title type="html">Compiler</title><link href="http://localhost:4000/computerarchitecture/2021/12/22/Compiler.html" rel="alternate" type="text/html" title="Compiler" /><published>2021-12-22T00:00:00+08:00</published><updated>2021-12-22T00:00:00+08:00</updated><id>http://localhost:4000/computerarchitecture/2021/12/22/Compiler</id><content type="html" xml:base="http://localhost:4000/computerarchitecture/2021/12/22/Compiler.html">&lt;center&gt;&lt;h1&gt;编译实验课程设计文档&lt;/h1&gt;&lt;/center&gt;

&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;本文档对于编译器的每个部分的实现进行了说明，大体上分为数据结构、算法思路和难点分析三个部分。&lt;/p&gt;

&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;p&gt;[toc]&lt;/p&gt;

&lt;h2 id=&quot;词法分析&quot;&gt;词法分析&lt;/h2&gt;

&lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token&lt;/code&gt; 类，存储每个 Token 所在的行号 (lineNum)，包含的内容 (content) 和 Token 的类别 (TokenType)。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TokenType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IDENFR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTCON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STRCON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAINTK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CONSTTK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTTK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BREAKTK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CONTINUETK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IFTK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ELSETK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WHILETK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VOIDTK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GETINTTK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRINTFTK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RETURNTK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PLUS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MINU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DIV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MOD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LSS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LEQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GRE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GEQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EQL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NEQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ASSIGN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SEMICN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COMMA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPARENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RPARENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LBRACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RBRACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LBRACE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RBRACE&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Token&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 行号&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 内容&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 类别&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TokenType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokenType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 默认构造&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TokenType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokenType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;算法流程&quot;&gt;算法流程&lt;/h3&gt;

&lt;p&gt;以字符为单位遍历输入程序，根据下图所示的流程图，将输入字符流逐一转化为相应 Token&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/resources/lexical_analysis.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;难点分析&quot;&gt;难点分析&lt;/h3&gt;

&lt;p&gt;词法分析的正确实现需要细致，这体现在以下几个方面：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不漏读，不复读字符：
    &lt;ul&gt;
      &lt;li&gt;在判断当前字符所对应的 Token 类型时，若不符合当前类型，应继续分析可能的下一种 Token 类型，而非将指针向后移动，从而跳过当前字符；也不能在当前字符已符合某种 Token 类型时继续判断当前字符类型，造成字符重复使用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Token 前缀相同时的判断
    &lt;ul&gt;
      &lt;li&gt;如 &amp;lt;= 与 &amp;lt;，&amp;gt;= 与 &amp;gt;，!= 与 !，== 与 = 等前缀相同的情况，需要根据后一个字符判断 Token 类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;语法分析&quot;&gt;语法分析&lt;/h2&gt;

&lt;h3 id=&quot;数据结构-1&quot;&gt;数据结构&lt;/h3&gt;

&lt;h3 id=&quot;astnode&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASTNode&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;建立 AST 结点类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASTNode&lt;/code&gt;，所有语法成分将继承自此节点。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ASTNode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ASTNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;ASTNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 默认构造&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 输出形式&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对文法中的每个终结符和非终结符建类，所有类均继承自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASTNode&lt;/code&gt;，类内含有该类可推导出的语法成分的指针。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;例：&lt;/p&gt;
  &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ASTNode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 表达式&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;AddExp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addExp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;Exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ASTNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddExp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ae&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addExp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ae&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

 &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;Exp&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;算法流程-1&quot;&gt;算法流程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;消除文法中的左递归
    &lt;blockquote&gt;
      &lt;p&gt;e.g.
原文法：AddExp := MulExp | AddExp (‘+’ | ‘-‘) MulExp
消除左递归后的文法：AddExp := MulExp | MulExp (‘+’ | ‘-‘) AddExp&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;采用 LL(n) 的方式进行语法分析，避免回溯&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构建 AST (Abstract Syntax Tree，抽象语法树)&lt;/p&gt;

    &lt;p&gt;采用递归的方式对每个非终结符构建 parse 函数。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;例：&lt;/p&gt;
      &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Exp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseExp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 解析 Exp 类&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parseAddExp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 调用 addExp 调用程序 (返回 * addExp)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ASTTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 将 expression 结点加入树中&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/div&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;难点分析-1&quot;&gt;难点分析&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;消除左递归：
    &lt;ul&gt;
      &lt;li&gt;由于原文法中存在左递归的情况，因此为了避免在语法分析中出现循环的情况，需要消除原文法中的左递归。但由于输出为根据原文法生成的语法树的后缀形式，因此在消除左递归后应适当变换，使输出满足原文法要求。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;指针的使用
    &lt;ul&gt;
      &lt;li&gt;在设计时考虑在每个类中存储对象本身而非对象的指针，但在实现过程中，由于各个类之间存在复杂的调用关系（包括环路），因此可能需要提前使用未定义的类。因此于其在类中用对象的形式存储属性，用指针更加节约空间且灵活，除此之外，还能避免拷贝构造时发生浅拷贝等问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;利用堆空间而非栈空间存储对象
    &lt;ul&gt;
      &lt;li&gt;在设计时，设想直接在 parse 函数中创建各个类的对象，但由于复杂的程序往往涉及到多层深入的调用关系，而函数内部声明的对象也有其生存周期，因此发生了程序在面对长输入程序时出现信息丢失和爆栈的情况。&lt;/li&gt;
      &lt;li&gt;解决方案是用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; 声明对象，将各个类的对象存放在堆空间中，加长对象的生存周期，避免爆栈和信息缺失的问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;符号表生成&quot;&gt;符号表生成&lt;/h2&gt;

&lt;h3 id=&quot;数据结构-2&quot;&gt;数据结构&lt;/h3&gt;

&lt;h4 id=&quot;symbol&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Symbol&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;建立符号类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Symbol&lt;/code&gt; 记录符号的名字，地址，维度，声明行号和使用行号等信息。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VarType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTCONST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTVAR&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Symbol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dimension&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;VarType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// const?&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;declareLine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 声明行号&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usedLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 使用行号&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VarType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dimension&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                                               &lt;span class=&quot;n&quot;&gt;declareLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;usedLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;symboltable&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SymbolTable&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;建立符号表类，用 map 的方式存储符号集 Symbol，其中，键为 Symbol 的名称，值为 Symbol 的指针&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SymbolTable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// symbol 符号集&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SymbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;father&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 指向父符号表的指针&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SymbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 指向子符号表的指针集&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;SymbolTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 默认构造&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sym&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 向符号表中插入 Symbol* sym&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* return 1 on success, return 0 on failure */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sym_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sym&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sym_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not find&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sym_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sym&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sym_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 在符号表及其父符号表中查找名为 sym_name 的 Symbol&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sym_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not find&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;father&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;father&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sym_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;SymbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newSon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 建立子符号表并返回其指针&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SymbolTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;symbolTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;father&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbolTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbolTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;SymbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newBrother&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 建立兄弟符号表返回其指针&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SymbolTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;symbolTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;father&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;father&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;father&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;father&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbolTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbolTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;SymbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 返回父符号表的指针&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;father&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;算法流程-2&quot;&gt;算法流程&lt;/h3&gt;

&lt;p&gt;建立根符号表，并将当前符号表的指针指向根符号表。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;SymbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SymbolTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SymbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentSymbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbolTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每当进入一个新的 Block 或新的函数时，建立新的子符号表，并将当前符号表的指针 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentSymbolTable&lt;/code&gt; 指向新的子符号表。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Block&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;currentSymbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentSymbolTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newSon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;currentSymbolTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentSymbolTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当遇到声明 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Decl&lt;/code&gt;) 语句和函数形参声明时，向符号表中填入 Symbol 并检查是否存在重名问题&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stmt&lt;/code&gt; 中使用符号时，由当前符号表逐层向上检索所用符号名和符号类型，检查是否存在未定义和改变 const 值等问题。&lt;/p&gt;

&lt;h3 id=&quot;难点分析-2&quot;&gt;难点分析&lt;/h3&gt;

&lt;p&gt;符号表实现中的困难主要来自于对变量生存周期和作用域的理解。&lt;/p&gt;

&lt;p&gt;在函数中，形参和函数体应共享一个符号表，而不能因为函数体为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Block&lt;/code&gt; 而创建只属于函数体的符号表。因此在进入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parseBlock&lt;/code&gt; 时，应首先判断是否在函数体内，若是，则不创建新符号表，否则创建新的子符号表，并将当前符号表的指针指向该符号表。&lt;/p&gt;

&lt;h2 id=&quot;函数表生成&quot;&gt;函数表生成&lt;/h2&gt;

&lt;h3 id=&quot;数据结构-3&quot;&gt;数据结构&lt;/h3&gt;

&lt;h4 id=&quot;function&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Function&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;建立 Function 类，存储函数名，形参和返回值等信息&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReturnType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;VOID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 函数名&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ReturnType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VOID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 函数返回值类型&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReturnType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returnType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paramsMatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 判断函数参数个数，类别是否吻合&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* return: 0 -- success, -1 -- number doesn't fit, -2 -- type doesn't fit */&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;require_iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;require_iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;require_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;varType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;varType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;require_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dimension&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dimension&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;require_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;functiontable&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FunctionTable&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;建立函数表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FunctionTable&lt;/code&gt;，用于存储全部声明函数的函数名，返回值等信息。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FunctionTable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;functions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 用 map 存储全部声明函数&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;FunctionTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 默认构造&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* return 1 on success, return 0 on failure */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;functions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;functions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not find&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;functions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 在函数表中寻找名为 func_name 的函数&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;functions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;functions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not find&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;算法流程-3&quot;&gt;算法流程&lt;/h3&gt;

&lt;p&gt;建立全局函数表 functionTable，每声明一个新的函数时向其中加入 Function 并判断函数是否存在重名等问题。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;FunctionTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functionTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FunctionTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每次用到函数时在函数表中根据函数名查找函数，判断是否存在未声明的问题。若函数已经声明，则进一步判断参数个数与类型是否与声明中相吻合。&lt;/p&gt;

&lt;h3 id=&quot;难点分析-3&quot;&gt;难点分析&lt;/h3&gt;

&lt;p&gt;函数表中不仅需要记录函数名和返回值等信息，还需记录函数参数个数和类型等信息。&lt;/p&gt;

&lt;h2 id=&quot;错误处理&quot;&gt;错误处理&lt;/h2&gt;

&lt;h3 id=&quot;数据结构-4&quot;&gt;数据结构&lt;/h3&gt;

&lt;h4 id=&quot;error&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Error&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Error&lt;/code&gt; 类，存储错误行号和错误类型&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 错误行号&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errorType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 错误类型&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 默认构造&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;et&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errorType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;et&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ostream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ostream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errorType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;算法流程-4&quot;&gt;算法流程&lt;/h3&gt;

&lt;p&gt;建立全局错误队列，存储所有程序中出现的错误，由于错误处理的输出需要有序，因此在输出前统一对错误进行排序，再逐一输出。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;错误处理办法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;分析每个错误所有可能出现的位置&lt;/li&gt;
  &lt;li&gt;在语法分析建立 AST 的同时对生成符号表、函数表并对错误进行判断。&lt;/li&gt;
  &lt;li&gt;每判断出一个错误将错误的行号和类型码存储在 Error 类中，并将其加入 errors&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;错误类别码&lt;/th&gt;
      &lt;th&gt;错误类型&lt;/th&gt;
      &lt;th&gt;判断方法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;非法符号&lt;/td&gt;
      &lt;td&gt;当 Token 为 STRCONST 时，对格式字符串的合法性进行判断。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;b&lt;/td&gt;
      &lt;td&gt;名字重定义&lt;/td&gt;
      &lt;td&gt;建立符号表与函数表，每定义新的符号 / 函数时向表中添加，当前符号 / 函数名在当前作用域内已定义，则产生名字重定义问题。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;未定义的名字&lt;/td&gt;
      &lt;td&gt;在使用变量和函数时在符号表和函数表中查询，若无法查询到，则证明出现未定义的名字。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;d&lt;/td&gt;
      &lt;td&gt;函数参数个数不匹配&lt;/td&gt;
      &lt;td&gt;在函数声明时在 Function 类中存储函数的形参信息（类别、数量、顺序），在调用函数时记录传递参数的信息，并于 Function 中的参数个数相对比，若不同，则抛出函数参数个数不匹配的错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;e&lt;/td&gt;
      &lt;td&gt;函数参数类型不匹配&lt;/td&gt;
      &lt;td&gt;函数声明时在 Function 类中存储函数的形参信息（类别、数量、顺序），在调用函数时记录传递参数的信息，并于 Function 中的参数类型（类型、维度）相对比，若不同，则抛出函数参数个数不匹配的错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;f&lt;/td&gt;
      &lt;td&gt;无返回值的函数存在不匹配的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;在函数声明时，若函数的 returnType 为 VOIDTK，则获取函数块内最后一条语句，若其为 return 语句且不为 “return;”，则报错&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;g&lt;/td&gt;
      &lt;td&gt;有返回值的函数缺少 return 语句&lt;/td&gt;
      &lt;td&gt;在函数声明时，若函数的 returnType 为 INTTK，则获取函数块内最后一条语句，若其不为 return 语句，则报错&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;h&lt;/td&gt;
      &lt;td&gt;不能改变常量的值&lt;/td&gt;
      &lt;td&gt;在变量声明并加入符号表时存储其是否为 const，在对变量赋值时，若变量存在且为 INTCONST，则报错&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i&lt;/td&gt;
      &lt;td&gt;缺少分号&lt;/td&gt;
      &lt;td&gt;在 parse 函数遇到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto *semicn = new Semicn(*(iter++));&lt;/code&gt; 时将其替换为先检查当前 iter 的 Token 类是否为 SEMICN，若是，则重复之前的操作，若不是，则自动补全分号并抛出 i 型错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;j&lt;/td&gt;
      &lt;td&gt;缺少右小括号&lt;/td&gt;
      &lt;td&gt;在 parse 函数遇到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto *rparent = new Rparent(*(iter++));&lt;/code&gt; 时将其替换为先检查当前 iter 的 Token 类是否为 RPARENT，若是，则重复之前的操作，若不是，则自动补全右小括号并抛出 j 型错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k&lt;/td&gt;
      &lt;td&gt;缺少右中括号&lt;/td&gt;
      &lt;td&gt;在 parse 函数遇到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto *rbrack = new Rbrack(*(iter++));&lt;/code&gt; 时将其替换为先检查当前 iter 的 Token 类是否为 RBRACK，若是，则重复之前的操作，若不是，则自动补全右中括号并抛出 k 型错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt; 中格式字符串与表达式个数不匹配&lt;/td&gt;
      &lt;td&gt;在语法分析的过程中，在遇到 Stmt -&amp;gt; printf ‘(‘ FormatString {, Exp} ‘)’ 时记录 Exp 的数量和 FormatString 中 ‘%d’ 的数量，将两者对比，若不同，则抛出 l 型错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;m&lt;/td&gt;
      &lt;td&gt;在非循环块中使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;break&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;continue&lt;/code&gt; 语句&lt;/td&gt;
      &lt;td&gt;设立 recursive 变量，用于记录所在的循环层数，当循环层数为 0 (不处于任何循环当中时)，若出现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;break&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;continue&lt;/code&gt; 则抛出 m 类型错误。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;难点分析-4&quot;&gt;难点分析&lt;/h3&gt;

&lt;p&gt;错误处理考察实现细节，需要对每种错误可能出现的情况进行详细的讨论，并适当修改语法分析代码。&lt;/p&gt;

&lt;p&gt;另外，对于“缺失”类型的错误，需要注意不让程序进入死循环。&lt;/p&gt;

&lt;p&gt;例：在语法分析中，读取函数形参 parseFuncFParams 在读入右小括号时退出&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tokenType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LBRACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但需要考虑右小括号缺失的情况，此时应添加条件判断，即：若读入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt; （代表进入函数体），也视作函数形参输入完成，且抛出右小括号缺失类型错误。&lt;/p&gt;

&lt;h2 id=&quot;中间代码生成&quot;&gt;中间代码生成&lt;/h2&gt;

&lt;p&gt;中间代码采用 SSA（静态单一赋值）的形式，采用类似 LLVMIR 的语言，便于后续优化。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在静态单一赋值的代码中，每个变量仅被赋值一次。生成 SSA 形式的中间代码极大的简化了优化的实现和优化程序的效率，但缺点在于构建 SSA 形式的代码难度较大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;中间代码语法简述&quot;&gt;中间代码语法简述&lt;/h3&gt;

&lt;p&gt;由于中间代码并不需要真正被 LLVM 编译器编译通过，因此在实现上以方便书写且满足 SSA 规范为准，在具体语法上可能与标准的 LLVM 有所差异。&lt;/p&gt;

&lt;h4 id=&quot;类型&quot;&gt;类型&lt;/h4&gt;

&lt;p&gt;中间代码中需要对变量的类型进行标识，为了使得优化程序更好的对于各个不同的变量类型执行相应的优化操作，因此选择保留尽量多的信息。如：源程序中的 int 在中间代码中可以对应全局变量和局部变量。&lt;/p&gt;

&lt;p&gt;中间代码中所使用的变量 / 常量类型如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;临时变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TEMP&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;在定义后使用一次即消亡的变量，不对应程序中的变量，用于在计算时保存临时结果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;全局变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INTGLOBAL&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;对应程序中全局声明的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 类型。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;全局常量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INTGLOBALCONST&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;对应程序中全局声明的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const int&lt;/code&gt; 类型。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;局部变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INTLOCAL&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;对应程序中局部声明的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 类型。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;局部常量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INTLOCALCONST&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;对应程序中局部声明的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const int&lt;/code&gt; 类型。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指针变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POINTER&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;对应程序中声明的局部数组类型。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数字 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NUMBER&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;对应程序中的立即数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FORMATSTRING&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;对应程序中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt; 中的字符串。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数名称 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FUNCTIONNAME&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;对应程序中的函数名。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;label &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LABEL&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;用于表示基本块的开始和便于基本块之间跳转语句的正常实现。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了能够更加直观的在输出到文件中的中间代码中辨识各个变量类型，对每种类型均定义了不同的输出方式，如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;变量类型&lt;/th&gt;
      &lt;th&gt;输出方式&lt;/th&gt;
      &lt;th&gt;举例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TEMP&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32 ${id}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32 $1&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INTGLOBAL&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INTGLOBALCONST&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32 @{id}&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[{size} * i32]* @{id}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32 @0&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[3 * i32] @4&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INTLOCAL&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INTLOCALCONST&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32 %{id}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32 %5&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POINTER&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32* %{id}&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[size * i32]* %{id}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32* %1&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[2 * i32]* %5&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LABEL&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;label{id}&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;label1&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FUNCTIONNAME&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@{name}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@func&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NUMBER&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32 {number}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32 512&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;语句&quot;&gt;语句&lt;/h4&gt;

&lt;p&gt;中间代码的语句主要分为一下几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;声明语句&lt;/li&gt;
  &lt;li&gt;算数语句：实现基本的加减乘除等操作，变量类型可以为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TEMP&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NUMBER&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;双目运算
        &lt;ul&gt;
          &lt;li&gt;算数运算 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADDIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUBIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MULIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DIVIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MODIR&lt;/code&gt;)&lt;/li&gt;
          &lt;li&gt;逻辑运算 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ANDIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ORIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EQIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEQIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GREIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GEQIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LSSIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LEQIR&lt;/code&gt;)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;单目运算
        &lt;ul&gt;
          &lt;li&gt;算数运算 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADDSINGLEIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUBSINGLEIR&lt;/code&gt;)&lt;/li&gt;
          &lt;li&gt;逻辑运算 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOTIR&lt;/code&gt;)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;跳转语句
    &lt;ul&gt;
      &lt;li&gt;无条件跳转 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BR&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;有条件跳转 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BRTRUE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BRFALSE&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;跳转并移动栈指针（由于存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;continue&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;break&lt;/code&gt; 语句，在跳转时可能出现跳转前后栈指针不一致的情况，因此这种指令需要在跳转后将栈指针移动至正确的位置）&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BRCHECK&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;函数相关语句
    &lt;ul&gt;
      &lt;li&gt;函数定义 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FUNCDECLIR&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;函数调用 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CALL&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;函数返回 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RET&lt;/code&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;存取语句 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOAD&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STORE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GETPOINTER&lt;/code&gt;)，其中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GETPOINTER&lt;/code&gt; 可获得数组相应位置的地址&lt;/li&gt;
  &lt;li&gt;mem2reg 相关语句 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEM2REGASSIGN&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEM2REGMOVE&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;其它语句（用于标识程序中 Block 的开始和结尾，便于栈指针移动至正确位置）
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LBRACEIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RBRACEIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LSHARPIR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RSHARPIR&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了能更清楚的在输出后的中间代码中辨识语句类型，对每种语句定义了相应的输出操作。&lt;/p&gt;

&lt;h4 id=&quot;mem2reg-与-phi&quot;&gt;mem2reg 与 phi&lt;/h4&gt;

&lt;p&gt;静态单一赋值要求同一个变量只能被赋值一次，但遇到下图所示的情况，应当如何确定应该输出哪一个 i 的值呢？&lt;/p&gt;

&lt;p&gt;一个最简单的实现办法就是利用 LOAD 和 STORE 语句，每次直接从内存中读写，而不需要考虑具体应当取哪一种赋值（如下图中左边代码所示），但这样做显然效率不高，大量的存取指令会占用大量的程序运行时间。&lt;/p&gt;

&lt;p&gt;为了能够提高程序的运行效率，需要消解 LOAD 与 STORE 语句，将其变为 SSA 形式的赋值语句，而实现从 LOAD, STORE 到 SSA 的转化的步骤就被称作 mem2reg。为了使程序能够在具有分支的情况下依然保持正确性，引入 phi 指令。&lt;/p&gt;

&lt;p&gt;phi 指令的语法是&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;phi 指令被安排在每个基本块的最开头，且执行没有先后顺序。phi 指令中的 label 对应着基本块的前驱，而 val 则是 result 可能的取值。&lt;/p&gt;

&lt;p&gt;举例来说，下图中右面的代码就是插入了 phi 的代码。其中，语句 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;4 = phi [&amp;amp;2, label1] [&amp;amp;3, label2]&lt;/code&gt; 代表若从 label1 跳转至该基本块，则 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;4&lt;/code&gt; 取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;2&lt;/code&gt; 的值，否则若从 label2 跳转至该基本块，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;4&lt;/code&gt; 取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;3&lt;/code&gt; 的值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mem2reg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;数据结构-5&quot;&gt;数据结构&lt;/h3&gt;

&lt;h4 id=&quot;value&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Value&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;在 SSA 形式的中间代码中，包括变量、常量、label 等一切皆是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Value&lt;/code&gt;，因此建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Value&lt;/code&gt; 类以及其对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VarType&lt;/code&gt; 枚举类。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VarType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTCONST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTVAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VOIDVAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;INTGLOBAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTGLOBALCONST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTLOCAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTLOCALCONST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LABEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POINTER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUMBER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FUNCTIONNAME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FORMATSTRING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TEMP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STRING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PMET&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 独一无二的 id，若为 NUMBER 则 id 为其对应的值&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;VarType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Value 类型&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbolTableId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 对应的符号表&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 对应的函数名或变量名&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 变量大小&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;declLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 定义变量的行号&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;useLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 使用变量的行号&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;llvmir&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVMIR&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;建立中间代码类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVMIR&lt;/code&gt; 以及其对应的枚举类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRType&lt;/code&gt;，用于表示各类中间代码，它的构造函数接受不同数量的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Value&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRType&lt;/code&gt;，生成各种形式的 IR。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IRTYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// DEFAULT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ADDIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SUBIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MULIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DIVIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MODIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 加减乘除&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ANDIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ORIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EQIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NEQIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 与或非、等于、不等于&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NOTIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ADDSINGLEIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SUBSINGLEIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 单目运算&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GREIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GEQIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LSSIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LEQIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 比较运算&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BRTRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BRFALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BRCHECK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 跳转运算&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FUNCDECLIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLOBALDECLIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOCALDECLIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CONSTDECLIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 定义（函数、全局、局部、常量）&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STORE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALLOCA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LABELIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ASSIGNIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEMPALLOCA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 存取运算&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LBRACEIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RBRACEIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LSHARPIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RSHARPIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 大括号 / 中括号（用于标记 Block 的始末，便于 stack pointer 移动到正确的位置）&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GETPOINTERIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 数组取地址&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MEM2REGASSIGN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEM2REGMOVE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEMPPHI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PHI&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// mem2reg 有关指令&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LLVMIR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IRType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRTYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// IR 类型&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// IR 行号&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockLineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 在 BasicBlock 中的行号（在变量冲突分析时使用）&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 以下属性均为 LLVMIR 构造时需要用到的参数&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varParams&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valueId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;basicblock&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicBlock&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicBlock&lt;/code&gt; 的含义是”基本块“，用来表示一段连续执行的程序序列。基本块中的代码只能顺序执行，只能从开头进入，从结尾离开。将程序划分为基本块的优点在于便于分析程序的控制流，从而使得优化能够更加方便的完成。&lt;/p&gt;

&lt;p&gt;由基本块的特性，定义对应的类及其属性如下：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 每个 BasicBlock 独有的 id, 对应其开头的 label 值&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dfnNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 深度优先搜索遍历顺序，在构建控制流图时使用&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;precursor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 前驱基本块&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;successor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 后继基本块&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 深度优先搜索树中的孩子节点，在构建控制流图时使用&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strictDominator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 严格支配基本块&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dominanceFrontier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 支配边界&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sdom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 直接支配基本块&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 半支配基本块&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dfsFather&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 深度优先搜索树中的父亲节点&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 当前基本块中定义的变量&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;useValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 当前基本块中使用的变量&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 当前基本块开头插入的 phi 指令&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 当前基本块中定义的变量及其定义行号&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 当前基本块中使用的变量及其使用行号&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defBeforeUse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 当前基本块中定义先于使用的变量&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;useBeforeDef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 当前基本快中使用先于定义的变量&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 进入基本快的数据流&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 从基本快中出来的数据流&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;edge&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Edge&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;为了更方便的得到控制流图，还需要了解基本块之间的跳转关系，对应图论中两个节点之间的边，因此定义边类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Edge&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Edge&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 边的起始点&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 边的终点&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;算法流程-5&quot;&gt;算法流程&lt;/h3&gt;

&lt;h4 id=&quot;0-判断代码是否存在错误&quot;&gt;0. 判断代码是否存在错误&lt;/h4&gt;

&lt;p&gt;若代码有错误，则直接退出程序。在需要编译的代码无语法错误时，进入中间代码生成程序。&lt;/p&gt;

&lt;h4 id=&quot;1-含有-alloca-load-store-的中间代码&quot;&gt;1. 含有 ALLOCA, LOAD, STORE 的中间代码&lt;/h4&gt;

&lt;p&gt;遍历语法树，对其中的每一个节点建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CodeGen&lt;/code&gt; 函数，并返回一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Value&lt;/code&gt; 值。&lt;/p&gt;

&lt;p&gt;例如，对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AddExp&lt;/code&gt;，其在文法中的定义为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AddExp -&amp;gt; MulExp | AddExp ('+' | '-') MulExp&lt;/code&gt;，由定义可知，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AddExp&lt;/code&gt; 需要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MulExp&lt;/code&gt; 计算出的结果进行加法或减法操作并返回计算结果。故其生成中间代码的函数为：（只展示主题结构）&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AddExp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;codeGen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mulExps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;codeGen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addSubASTs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp_val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mulExps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;codeGen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 调用每个 MulExp 的 codeGen 函数，得到 MulExp 的运算结果。&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;midCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LLVMIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PLUS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ADDIR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SUBIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;llvmLineNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 根据运算符生成对应的中间代码（加法 / 减法）&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将遍历语法树时产生的所有中间代码都保存在全局的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;midCode&lt;/code&gt; 中，便于之后进行多遍优化。&lt;/p&gt;

&lt;p&gt;需要注意的是，由于中间代码需要保持静态单一赋值的特性，因此所有对变量的定义均转化为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALLOCA&lt;/code&gt; 语句，意为直接为变量分配一段内存；所有对变量的取值操作则转化为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOAD&lt;/code&gt; 语句，意为从内存中读相应值；而所有对变量的赋值操作则转化为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STORE&lt;/code&gt;，意为向内存中存入相应值。&lt;/p&gt;

&lt;p&gt;特别的，对于数组，用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GETPOINTER&lt;/code&gt; 指令获取数组的首地址，再用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOAD&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STORE&lt;/code&gt; 指令对数组内容进行存取。&lt;/p&gt;

&lt;h4 id=&quot;2-mem2reg&quot;&gt;2. mem2reg&lt;/h4&gt;

&lt;p&gt;mem2reg 需要将 load / store 形式的中间代码通过插入 phi 的方式转化为 phi 形式的 SSA。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要注意的是，该步骤只针对局部 int 类型变量进行处理，而不考虑数组、全局变量等情况。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;a-划分基本块&quot;&gt;a. 划分基本块&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;基本块&lt;/strong&gt;的程式有以下特点：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;单一入口点，其他程式中，没有任何一个分支指令的目标在这段程式基本块之内（基本块的第一行除外）。&lt;/li&gt;
    &lt;li&gt;单一结束点，这段程式一定要执行完最后一行才会执行其他基本块的程式。&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;因为上述特点，基本块中的程式，只要执行了第一行，后面的程式码就会依序执行，每一行程式都会执行一次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由基本块的特性，在划分基本块时只需关心跳转指令，并根据不同的跳转指令生成基本块的前驱、后继关系，其具体算法如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;由于在生成中间代码时，需要跳转到的地址前均有一个对应的 label，因此先针对每一个 label 新建其对应的基本块类，并初始化其前驱、后继基本块为空集。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;遍历所有中间代码，并记录当前基本块 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentBasicBlock&lt;/code&gt; 和上一个遍历完的基本块 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prevBasicBlock&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;当遇到一个新的 label 时&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;若 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prevBasicBlock&lt;/code&gt; 为空，则说明当前基本块为程序第一个基本块，没有对应的前驱。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;否则，寻找上一个基本块中最后一条指令，并分类讨论&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;/assets/images/post/branch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;b-建立深度优先搜索树&quot;&gt;b. 建立深度优先搜索树&lt;/h5&gt;

&lt;p&gt;根据基本块的定义，我们很容易联想到图论中的知识，我们可以把每个基本块当作一个节点，而基本块之间的跳转关系则为基本块之间的边。这样生成的图就是程序的控制流图 (CFG, Control Flow Graph)。可以发现，由于循环和跳转的存在，有些基本块无法被到达，而有些可以形成环路。但这样复杂的跳转关系不利于生成 phi 节点，因此我们需要在控制流图的基础上生成支配树。&lt;/p&gt;

&lt;p&gt;从第一个基本块开始，依照深度优先的顺序遍历所有基本块，每遇到一个新的基本块时则将其的 dfn 更新为深度优先搜索树的遍历顺序。&lt;/p&gt;

&lt;h5 id=&quot;c-无用基本块删除&quot;&gt;c. 无用基本块删除&lt;/h5&gt;

&lt;p&gt;在深度优先遍历后，未被遍历到（dfn 未更新）的基本块是在程序中不可到达的，因此可以直接删除。&lt;/p&gt;

&lt;h5 id=&quot;d-计算半必经点&quot;&gt;d. 计算半必经点&lt;/h5&gt;

&lt;h6 id=&quot;前置概念参考链接1-参考链接2-&quot;&gt;前置概念（&lt;a href=&quot;https://buaa-se-compiling.github.io/miniSysY-tutorial/challenge/mem2reg/help.html&quot;&gt;参考链接1&lt;/a&gt;, &lt;a href=&quot;https://www.cnblogs.com/ZeonfaiHo/p/6594642.html&quot;&gt;参考链接2&lt;/a&gt; ）&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：对变量进行初始化、赋值等改变变量的值的行为。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用&lt;/strong&gt;：在语句/指令中将变量的值作为参数的行为。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;控制流图&lt;/strong&gt;（Control Flow Graph, CFG）：一个程序中所有基本块执行的可能流向图，图中的每个节点代表一个基本块，有向边代表基本块间的跳转关系。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;支配&lt;/strong&gt;（dominate）：对于 CFG 中的节点 $n_1$ 和 $n_2$，$n_1$ 支配 $n_2$ 当且仅当所有从入口节点到 $n_2$ 的路径中都包含 $n_1$，即 $n_1$ 是从入口节点到 $n_2$ 的必经节点。需要特别注意的是，每个基本块都支配自身。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;严格支配&lt;/strong&gt;（strictly dominate）：$n_1$ 严格支配 $n_2$ 当且仅当 $n_1$ 支配 $n_2$ 且 $n_1\neq n_2$。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;直接支配者&lt;/strong&gt;（immediate dominator, idom）：节点 $n$ 的直接支配者严格支配 $n$，且不严格支配任何严格支配 $n$ 的节点的节点）. 入口节点以外的节点都有直接支配者. 节点之间的直接支配关系可以形成一棵&lt;strong&gt;支配树&lt;/strong&gt;（dominator tree）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;必经点&lt;/strong&gt;：若 $n_1$ 严格支配 $n_2$，则 $n_1$ 为 $n_2$ 的必经点&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;半必经点&lt;/strong&gt;：对于一个节点 $n_2$，若存在某个点 $n_1$ 能够通过一系列点 $p_i$ （不包含 $n_1$ 和 $n_2$）到达且 $\forall p_i$ 都有 dfn[$p_i$] &amp;gt; dfn[$n_2$]，则称 $n_1$ 是 $n_2$ 的半必经点，用 sdom 表示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/cfg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;算法流程-6&quot;&gt;算法流程&lt;/h6&gt;

&lt;p&gt;依据深度优先搜索的相反顺序遍历所有基本块，并通过下面的算法找出每个基本块的半必经点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于基本块 Y，对于它的每一个前驱基本块 X，若 dfn[X] &amp;lt; dfn[Y]，则 X 是 Y 的一个半必经点。&lt;/li&gt;
  &lt;li&gt;否则，对于 X 在深度优先搜索树中的祖先 Z （包括 X 自身），如果满足 dfn[Z] &amp;gt; dfn[Y]，那么 Z 的半必经点也是 Y 的半必经点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;e-计算直接支配点&quot;&gt;e. 计算直接支配点&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个点的半必经点可能是也可能不是一个点的支配点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于一个点 X，考虑深度优先搜索树上从 X 的 半必经点 X.sdom 到 X 路径上的所有点 $p_0, p_1, …, p_k$，对于所有的 $p_i:0&amp;lt;i&amp;lt; k$，记其中 dfn[$p_i$.sdom] 最小的一个 $p_i$ 为 Z。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;若 Z.sdom = X.sdom，则 X.idom = X.sdom&lt;/li&gt;
  &lt;li&gt;否则，X.idom = Z.idom&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此，已经计算出所有基本块的直接支配者，也就是在支配树中的父节点。&lt;/p&gt;

&lt;h5 id=&quot;f-计算支配边界&quot;&gt;f. 计算支配边界&lt;/h5&gt;

&lt;p&gt;在完成上一步后，我们已经成功将控制流图转化为支配树，下一步需要计算出每个基本块的支配边界 (Dominance Frontier)，以便之后插入 phi 节点。&lt;/p&gt;

&lt;p&gt;计算支配边界的算法如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://buaa-se-compiling.github.io/miniSysY-tutorial/pic/algorithm_compute_DF.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;g-插入-phi-节点&quot;&gt;g. 插入 phi 节点&lt;/h5&gt;

&lt;p&gt;构建出支配树，求出各基本块的支配边界之后，我们终于可以向正规的 SSA 形式迈进了，这种实现从 STORE, LOAD 形式的代码向 SSA 转换的过程被称为 mem2reg，具体的实现方法则是插入 phi 节点。&lt;/p&gt;

&lt;p&gt;插入 phi 节点需要计算出每个变量的定义、使用情况，其具体算法如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://buaa-se-compiling.github.io/miniSysY-tutorial/pic/algorithm_insert_phi.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;h-变量重命名&quot;&gt;h. 变量重命名&lt;/h5&gt;

&lt;p&gt;在插入 phi 节点后，我们还需要对变量进行重命名，从而使其满足 SSA 的要求。&lt;/p&gt;

&lt;p&gt;具体的来说，对于 STORE 指令，我们新产生一个变量，并将其转化为对该变量的赋值语句 (assign)；对于 LOAD 指令，我们将其转化为 move 指令；而对于 phi 指令，我们也新产生一个变量，并将 phi 指令中的 val 值相应的填充为变量号。&lt;/p&gt;

&lt;p&gt;一个具体的例子如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/phi.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过上述一系列的操作，我们终于得到了含有 phi 语句，且符合 SSA 规范的程序了。&lt;/p&gt;

&lt;h3 id=&quot;难点分析-5&quot;&gt;难点分析&lt;/h3&gt;

&lt;p&gt;生成 SSA 形式的中间代码是整个编译器中较为复杂的一步，它设计到大量图论相关的知识，且在实现时也需要阅读很多的教材、文献。&lt;/p&gt;

&lt;p&gt;笔者在最初生成中间代码时由于懒惰和过分自信，并没有阅读文献就自行编写 mem2reg 相关代码。编写出的编译器针对小型样例可以通过，但在编译大型程序时出现了时间复杂度过高的情况，因此不得不阅读论文并重构，在这一步走了不少弯路。事实证明，阅读文献是很重要的，文献中的方法不但经过了正确性的检验，算法的时间复杂度也较低，虽然阅读文献需要耗费时间和经历，但却能大大提高写码时的效率，也让 debug 变得简单。&lt;/p&gt;

&lt;h2 id=&quot;中间代码优化&quot;&gt;中间代码优化&lt;/h2&gt;

&lt;p&gt;下面简单介绍编译器中在中间代码中进行的优化，需要注意的是，在实现时对每一种优化均设置了开关，这样便于查看优化效果，也便于程序调试。&lt;/p&gt;

&lt;p&gt;生成 SSA 形式的中间代码极大的简化了中间代码的优化难度。以下是一些笔者采用的代码优化：&lt;/p&gt;

&lt;h3 id=&quot;死代码删除&quot;&gt;死代码删除&lt;/h3&gt;

&lt;h4 id=&quot;一般代码删除&quot;&gt;一般代码删除&lt;/h4&gt;

&lt;p&gt;生成 SSA 形式的代码后，死代码删除就很好实现了，只需要找到定义但未被使用的变量，将其相关语句删除即可。&lt;/p&gt;

&lt;h4 id=&quot;跳转代码删除&quot;&gt;跳转代码删除&lt;/h4&gt;

&lt;p&gt;对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BRTRUE&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BRFALSE&lt;/code&gt; 语句，当判断跳转的变量取固定值时，则只有一种跳转的可能，因此可删去无法跳转到的分支。&lt;/p&gt;

&lt;h3 id=&quot;常量折叠&quot;&gt;常量折叠&lt;/h3&gt;

&lt;p&gt;由于每个变量只被定义一次，因此若在定义时为常数，则变量始终为常数。特别的，当 phi 语句可取的值均为常数且相同时，phi 语句生成的变量也为常数。&lt;/p&gt;

&lt;h3 id=&quot;函数内联&quot;&gt;函数内联&lt;/h3&gt;

&lt;h4 id=&quot;1-判断函数是否内联&quot;&gt;1. 判断函数是否内联&lt;/h4&gt;

&lt;p&gt;当函数不存在递归调用时，则可以内联。由于 SysY 语法中不包含函数声明语句，因此不需要生成函数调用关系图即可以判断函数是否可以内联。&lt;/p&gt;

&lt;p&gt;具体的来说，在语法分析的过程中，若在函数定义中调用了自己，则存在递归调用；否则则为可以内联的函数。&lt;/p&gt;

&lt;h4 id=&quot;2-函数内联实现&quot;&gt;2. 函数内联实现&lt;/h4&gt;

&lt;h5 id=&quot;返回语句&quot;&gt;返回语句&lt;/h5&gt;

&lt;p&gt;函数内联实现时，需要特别注意返回语句的处理。由于返回语句执行后将不再执行之后的语句，因此需要对每个内联的函数末尾生成一个 label，将返回语句转化为向相应 label 的跳转语句。&lt;/p&gt;

&lt;h5 id=&quot;返回值&quot;&gt;返回值&lt;/h5&gt;

&lt;p&gt;由于函数可能包含多条返回语句，且可能有多种可能的返回值，因此将返回值作为一个变量处理。&lt;/p&gt;

&lt;p&gt;具体的来说，若函数的返回类型为 int，则在开始函数内联之前先声明一个变量，用于存储返回值。在遇到内联函数的返回语句时向该变量中填入相应的值。&lt;/p&gt;

&lt;h3 id=&quot;循环优化&quot;&gt;循环优化&lt;/h3&gt;

&lt;p&gt;循环是程序中很重要的组成部分，且虽然语句量不一定多，但占据了程序运行中的大量时间，因此针对循环的优化可以有效提高程序的运行效率。&lt;/p&gt;

&lt;h4 id=&quot;1-while---do-while&quot;&gt;1. while -&amp;gt; do-while&lt;/h4&gt;

&lt;p&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; 语句改写为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do-while&lt;/code&gt; 形式，可以减少跳转次数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/dowhile.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;删除无用循环&quot;&gt;删除无用循环&lt;/h4&gt;

&lt;p&gt;当循环内部的变量在循环外不再使用时，可以将整个循环删除。判断循环内变量是否使用需要配合活跃变量分析。&lt;/p&gt;

&lt;h4 id=&quot;循环展开&quot;&gt;循环展开&lt;/h4&gt;

&lt;p&gt;将小循环体展开，配合跳转代码删除，可以有效减少循环所需要的判断。&lt;/p&gt;

&lt;h3 id=&quot;局部数组提升--标记常量数组&quot;&gt;局部数组提升 &amp;amp; 标记常量数组&lt;/h3&gt;

&lt;p&gt;由于在全局中可直接用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.word&lt;/code&gt; 进行初始化且不需要占用运行时间。因此，若局部数组的值未被改变或原本就定义为常量数组，则可以将其提升为全局数组并在全局中初始化。&lt;/p&gt;

&lt;h3 id=&quot;全局转局部&quot;&gt;全局转局部&lt;/h3&gt;

&lt;p&gt;由于对全局变量的读写均需要直接进行内存的读写，占用程序运行时间，因此对于函数中不会直接引用到的全局变量，可将其转化为局部变量并对其分配寄存器，减少存取指令，提高运行效率。&lt;/p&gt;

&lt;h2 id=&quot;目标代码生成&quot;&gt;目标代码生成&lt;/h2&gt;

&lt;p&gt;下面介绍由中间代码生成目标代码的过程。&lt;/p&gt;

&lt;h3 id=&quot;数据结构-6&quot;&gt;数据结构&lt;/h3&gt;

&lt;h4 id=&quot;registertype&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RegisterType&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;为了能够更方便的表示各个寄存器，新建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RegisterType&lt;/code&gt; 枚举类，如下：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegisterType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REGZERO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGAT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REGV0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGV1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REGA0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGA1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGA2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGA3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REGT0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGT1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGT2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGT3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGT4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGT5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGT6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGT7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGT8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGT9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REGS0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGS1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGS2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGS3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;19&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGS4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGS5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGS6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGS7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REGK0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGK1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REGGP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGSP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGFP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REGRA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REGDEFAULT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;mipscode&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIPSCode&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;构建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIPSCode&lt;/code&gt; 类，用来表示 mips 代码。此外，为了更好的区别不同种类的 mips 代码，新建枚举类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIPSType&lt;/code&gt;，如下：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSADD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSADDI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSDIV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSMULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSUB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSUBI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSMUL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSMULU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSANDI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSORI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSNOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSBEQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSBGEZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSBGTZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSBLEZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSBLTZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSBNE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSSLT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSGT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSGE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSEQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSNE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSJ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSJAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSJALR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSJR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSMFHI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSMFLO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSSLL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSLLV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSLTI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSRA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSRAV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSRL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSRLV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSSW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSLW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSLWLABEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSSWLABEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSSYSCALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSLABEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSTEXT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSLI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSLA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSSPACE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSWORD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSASCIIZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIPSMOVE&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MIPSCode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MIPSType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 操作符&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RegisterType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGDEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// rs 寄存器&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RegisterType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGDEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// rt 寄存器&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RegisterType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGDEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// rd 寄存器&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 立即数&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;register&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Register&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20211114221256460.png&quot; alt=&quot;image-20211114221256460&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了能够更好的调度寄存器和存储寄存器的使用情况，构建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Register&lt;/code&gt; 类，用于存储各个寄存器是否被使用，已经分配空寄存器。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Register&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegisterType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;registers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 各个寄存器的标号及其使用情况&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// initialize register&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;registers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegisterType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 初始化寄存器，将所有使用位标志为空闲 (true)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freeRegister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;registers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegisterType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 将指定 id 的寄存器标记为空闲&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getFreeTRegister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 获得空闲的 t 寄存器，若全部 t 寄存器均被使用，则返回 -1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;算法流程-7&quot;&gt;算法流程&lt;/h3&gt;

&lt;p&gt;生成中间代码的主要算法流程用下图表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/mips.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，需要特别注意的是在函数调用过程中的寄存器偏移和在退出基本块时的寄存器偏移。&lt;/p&gt;

&lt;p&gt;此外，也需要在生成代码时记录下各个变量的地址，以便后续调用。&lt;/p&gt;

&lt;h3 id=&quot;难点分析-6&quot;&gt;难点分析&lt;/h3&gt;

&lt;h4 id=&quot;函数调用&quot;&gt;函数调用&lt;/h4&gt;

&lt;p&gt;函数调用时需要对 s 寄存器和必要的 t 寄存器进行保存，为了程序实现的正确性以及规范性，需要区分调用者和被调用者，并分别保存相应的变量。&lt;/p&gt;

&lt;p&gt;更具体的来说&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用者需要保存必要的临时变量&lt;/li&gt;
  &lt;li&gt;被调用者需要保存所有 s 寄存器，函数的返回地址，传入参数，初始栈指针与帧指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;栈指针偏移&quot;&gt;栈指针偏移&lt;/h4&gt;

&lt;p&gt;目标代码生成时最重要也最容易出问题的部分就是栈指针偏移。&lt;/p&gt;

&lt;p&gt;对于全局变量，可以直接用 la (load address) 从全局中获取变量地址并进行存取操作，而对于局部变量，则需要通过栈指针 sp 和帧指针 fp 来确定其相对地址。&lt;/p&gt;

&lt;p&gt;在实现时，在进入函数时将原帧指针地址保存并将帧指针移动至此时栈指针所在的位置，并在整个函数体内部不再改变，直至函数体执行完毕后再将帧指针恢复。这样做的好处是，在栈指针地址不断变化时可以通过相对于帧指针的偏移来获取局部变量的地址。&lt;/p&gt;

&lt;h4 id=&quot;phi-函数的实现&quot;&gt;phi 函数的实现&lt;/h4&gt;

&lt;p&gt;phi 函数两种可能的实现方式，一是在遇到 phi 函数时用 move 指令将所有可能的取值移动到同一个寄存器上，而另一种相对简单的方法是在分配寄存器时即将属于同一个 phi 函数的变量分配同一个寄存器。笔者采用的是后者。因此在全局分配寄存器前，需要先根据 phi 函数对变量进行归类，再将同一类的多个变量看作一个变量，进行活跃、冲突分析和寄存器分配操作。&lt;/p&gt;

&lt;h2 id=&quot;目标代码优化&quot;&gt;目标代码优化&lt;/h2&gt;

&lt;h4 id=&quot;寄存器分配&quot;&gt;寄存器分配&lt;/h4&gt;

&lt;p&gt;采用图着色寄存器分配法，先通过活跃变量分析得到各个变量之间的冲突图，再在图中不断移去变量，最终完成寄存器分配。&lt;/p&gt;

&lt;h3 id=&quot;乘除优化&quot;&gt;乘除优化&lt;/h3&gt;

&lt;p&gt;乘除法占据的指令周期数极大，尤其是除法指令，一条就可以占据 100 个时钟周期，因此乘除指令的优化效果也十分显著。&lt;/p&gt;

&lt;p&gt;主要针对一个操作数为常数的乘除指令进行优化。&lt;/p&gt;

&lt;p&gt;乘法的优化方式主要为：将乘法转化为左移和加法操作，需要注意正负号的问题。&lt;/p&gt;

&lt;p&gt;除法的优化方式参照论文 Division by Invariant Integers using Multiplication，可以将除法指令转化为乘法指令。&lt;/p&gt;

&lt;p&gt;余数也可以转化为乘除指令，再进行相应优化 (a % b = a - a / b)&lt;/p&gt;

&lt;h3 id=&quot;窥孔优化&quot;&gt;窥孔优化&lt;/h3&gt;

&lt;h4 id=&quot;无用跳转指令删除&quot;&gt;无用跳转指令删除&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/jump.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;无用-move-指令删除&quot;&gt;无用 move 指令删除&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/move.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;一学期的编译实验终于要告一段落了。&lt;/p&gt;

&lt;p&gt;在学期开始之初，我无论如何也想象不到自己可以用并（没）不（有）熟（用）练（过）的 c++ 写出上万行的程序，并且取得还不错的性能。因此，编译对我的代码能力和设计能力都有着极大的提升。看到编译器正确运行并且输出目标代码，还是很有成就感的。&lt;/p&gt;

&lt;p&gt;在编写大型系统时，一个清晰的设计尤其重要。因此，在编写代码前我都会给自己列出一个步骤清单，先把架构设计想清楚，从整体结构再到每步实现时的注意事项，然后严格按照之前书写的步骤进行编译器的书写。这样做虽然一开始进度可能会慢于周围的同学，但一个清晰的思路会让后面的工作轻松不少。&lt;/p&gt;

&lt;p&gt;除此之外，代码风格和命名也十分重要。在编译器的规模逐渐增加时，一些具体的函数实现方法可能已经变得模糊，如果能有一个清晰的命名和辅助的注释，则可以让自己迅速理解函数的作用，并决定是否调用。&lt;/p&gt;

&lt;p&gt;总的来说，虽然中间有过很痛苦的时候，但能自己写出一个基本的编译器还是很有趣的经历 : )&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;[1] 《编译技术》，张莉，史晓华等&lt;/p&gt;

&lt;p&gt;[2]  &lt;em&gt;Modern Compiler Implementation in C&lt;/em&gt;, Andrew W. Appel (2004)&lt;/p&gt;

&lt;p&gt;[3] &lt;em&gt;Static Single Assignment Book&lt;/em&gt;, 2018, Lots of authors&lt;/p&gt;

&lt;p&gt;[4] &lt;em&gt;LLVM IR TUTORIAL&lt;/em&gt;, LLVM Developers Conference, Vince Bridgers, Felipe de Azevedo Piovezan&lt;/p&gt;

&lt;p&gt;[5] &lt;em&gt;LLVM Cookbook&lt;/em&gt;, Mayur Pandey, Suyog Sarda&lt;/p&gt;

&lt;p&gt;[6] A Linear Time Alogorithm for Placing $\phi$-Nodes, Vugranam C. Sreedhar, Guang R. Gap, School of Computer Science, McGill University&lt;/p&gt;

&lt;p&gt;[7] Division by Invariant Integers using Multiplication., Granlund, Torbjorn &amp;amp; Montgomery, Peter. (2004).&lt;/p&gt;</content><author><name>ericaaaaaaaa</name></author><category term="ComputerArchitecture" /><category term="design-doc" /><category term="system" /><summary type="html">编译实验课程设计文档</summary></entry><entry><title type="html">Computer Vision</title><link href="http://localhost:4000/artificialintelligence/2021/09/14/ComputerVision.html" rel="alternate" type="text/html" title="Computer Vision" /><published>2021-09-14T00:00:00+08:00</published><updated>2021-09-14T00:00:00+08:00</updated><id>http://localhost:4000/artificialintelligence/2021/09/14/ComputerVision</id><content type="html" xml:base="http://localhost:4000/artificialintelligence/2021/09/14/ComputerVision.html">&lt;h1 id=&quot;计算机视觉&quot;&gt;&lt;center&gt;计算机视觉&lt;/center&gt;&lt;/h1&gt;

&lt;p&gt;本文档主要针对图像分类问题，在第一部 分中整理了相关背景知识，包括人工神经网络相关术语——激活函数、损失函数，正向与逆向传播等；在第二部分中主要介绍了图像分类相关的知识，包括它的输入输出与常见的处理方法。&lt;/p&gt;

&lt;h1 id=&quot;一知识&quot;&gt;（一）知识&lt;/h1&gt;

&lt;h2 id=&quot;1-拟合-fitting&quot;&gt;1. 拟合 (Fitting)&lt;/h2&gt;

&lt;p&gt;利用曲线描述样本，曲线应当具有良好的泛化能力 (generalization)。在拟合时可能出现两种可能的情况——&lt;strong&gt;过拟合&lt;/strong&gt; (overfitting) 和&lt;strong&gt;欠拟合&lt;/strong&gt; (underfitting)。其中，欠拟合反映在训练时模型效果良好，但测试时正确率较低的情况。它往往是由于过度依赖训练集数据，从而缺乏对更多数据良好的泛化性。一种可能的原因是模型过于复杂且训练集较小。欠拟合与过拟合相反，无法对样本给出较好的估计。一种可能的原因是模型过于简单，无法拟合或区分样本点。&lt;/p&gt;

&lt;h2 id=&quot;2-正则化-regularization&quot;&gt;2. 正则化 (Regularization)&lt;/h2&gt;

&lt;p&gt;正则化的引入是为了防止过拟合的发生。举例来说，在多项式拟合坐标点问题中，多项式的阶数越高，对于样本点的拟合情况越好，但由于可能出现过拟合问题，因此反而可能导致对于最终测试点的拟合情况较差。因此，正则化可以有效的评估模型的复杂程度，尽可能减少测试误差。&lt;/p&gt;

&lt;h2 id=&quot;3-激活函数-activation-function&quot;&gt;3. 激活函数 (Activation Function)&lt;/h2&gt;

&lt;p&gt;神经网络受人类神经元工作原理的启发，因此神经网络中很重要的一个部分是它的激活函数。激活函数负责将神经元的输入映射到输出端。常用的激活函数图像如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Gjl-t%28x%29.svg/320px-Gjl-t%28x%29.svg.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;a-sigmoid-函数-sigma&quot;&gt;a. sigmoid 函数 ($\sigma$​​​)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Logistic-curve.svg/320px-Logistic-curve.svg.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;sigmoid 函数[1]是饱和激活函数，其公式为 $S(x) = \frac{1}{1+\exp^{-x}} = \frac{\exp^x}{\exp^x+1}=1-S(-x)$​ ，可以将输入映射到 (0,1) 区间内。&lt;/p&gt;

&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;

&lt;p&gt;可以将任何范围的输入映射到 (0,1) 区间内&lt;/p&gt;

&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在输出接近 0 或 1 时梯度几乎为 0，对反向传输中的梯度下降运算不利&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;会使得大量的数据集中在 (0, 1) 区间内，数据密度分配不均&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输出并不是以 0 为中心，可能导致后续的神经元计算结果分布出现问题&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此在现在的神经网络中很少使用。&lt;/p&gt;

&lt;h3 id=&quot;b-tanh-函数&quot;&gt;b. tanh 函数&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/7/76/Sinh_cosh_tanh.svg/300px-Sinh_cosh_tanh.svg.png&quot; alt=&quot;Sinh cosh tanh.svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;tanh[2]是饱和激活函数，其公式为 $\tanh(x) = 2\sigma(2x)-1=\frac{\sinh(x)}{\cosh(x)} = \frac{\exp^x-\exp^{-x}}{\exp^x+\exp^{-x}}=\frac{\exp^{2x}-1}{\exp^{2x}+1}$​​&lt;/p&gt;

&lt;h3 id=&quot;c-relu-函数&quot;&gt;c. ReLU 函数&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/ReLU_and_GELU.svg/220px-ReLU_and_GELU.svg.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不同于上述两种激活函数，ReLU 函数[3]属于非饱和激活函数，它的全称是修正线性单元激活函数 (Recitified Linear Unit active function)，也可以成为 Rectifier，它的公式为 $ReLU(x) = x^+ = \max(0,x)$​​&lt;/p&gt;

&lt;h4 id=&quot;优点-1&quot;&gt;优点&lt;/h4&gt;

&lt;p&gt;相比于上述 Sigmoid 和 tanh 激活函数，ReLU 的计算量较小，计算速度较快&lt;/p&gt;

&lt;h4 id=&quot;缺点-1&quot;&gt;缺点&lt;/h4&gt;

&lt;p&gt;ReLU 可能造成神经网络中的有用信息丢失，因为所有小于 0 的输入都会映射到 0，因此这些神经元将不再工作，不再向下传播。&lt;/p&gt;

&lt;h4 id=&quot;变体&quot;&gt;变体&lt;/h4&gt;

&lt;p&gt;以下是 ReLU 的部分变体。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Leaky ReLU&lt;/p&gt;

    &lt;p&gt;$Leaky_ReLU(x)=\begin{cases}x&amp;amp;&amp;amp; x\gt 0\ 0.01x&amp;amp;&amp;amp;x\le0\end{cases}$​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;含参 ReLU&lt;/p&gt;

    &lt;p&gt;$Parameter_ReLU(x)=\begin{cases}x&amp;amp;&amp;amp; x\gt 0\ ax&amp;amp;&amp;amp;x\le0\end{cases}$​​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SiLU&lt;/p&gt;

    &lt;p&gt;$SiLU(x) = x\cdot sigmoid(x) = x\cot\sigma(x)$​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Softplus&lt;/p&gt;

    &lt;p&gt;$Softplus(x)=\ln(1+\exp^x)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ELU&lt;/p&gt;

    &lt;p&gt;$ELU(x) = \begin{cases}x&amp;amp;&amp;amp;x\gt0\ a(\exp^x-1)&amp;amp;&amp;amp;x\le0\end{cases}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GELU&lt;/p&gt;

    &lt;p&gt;$f(x)=x\cdot\Phi(x)$​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Maxout&lt;/p&gt;

    &lt;p&gt;$Maxout(x) = \max(w_1^Tx+b_1, w_2^Tx+b_2)$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-损失函数-loss-function&quot;&gt;4. 损失函数 (Loss Function)&lt;/h2&gt;

&lt;p&gt;损失函数反映了估计值与真实值之间的差距，即模型的估计效果和正确率，多用于反向传播，即通过损失函数的大小反向调整模型参数的大小。&lt;/p&gt;

&lt;p&gt;损失函数通常由两部分组成，&lt;strong&gt;规则化项&lt;/strong&gt;和&lt;strong&gt;惩罚项&lt;/strong&gt;，其中规则化项反映了模型对于样例的拟合水平，而规则化项则反映了模型的复杂程度。&lt;/p&gt;

&lt;p&gt;损失函数可以抽象的表示为：$L = \frac{1}{N}\sum_iL_i+\lambda R(W)$，其中 $L_i$ 为第 $i$ 个样本点的规则化损失，$N$ 为样本点总数，$R(W)$ 为正则化损失&lt;/p&gt;

&lt;p&gt;模型的目标是尽可能减小损失函数，即保障正确率且尽可能简单。&lt;/p&gt;

&lt;h3 id=&quot;a-规则化项&quot;&gt;a. 规则化项&lt;/h3&gt;

&lt;h4 id=&quot;支持向量机-multiclass-support-vector-machine-svm&quot;&gt;支持向量机 (Multiclass Support Vector Machine, SVM)&lt;/h4&gt;

&lt;p&gt;支持向量机是一种二分类模型，目标是将样本点尽可能的分成两类。在图片分类问题中，SVM 希望使正确类的估计值尽可能的高，错误类的估计值稳定在某个特定的范围 $\Delta$ 内。&lt;/p&gt;

&lt;p&gt;$SVM_loss = L_i = \sum_{j\not=y_i}\max{(0, s_j-s_{y_i}+\Delta)}$&lt;/p&gt;

&lt;p&gt;其中 $i$ 代表第 $i$ 个样本点，$y_i$ 是该样本点正确的类别，$j$ 代表所有可能的类别，$s_j$ 和 $s_{y_i}$ 分别代表模型对于第 $i$ 个样本点为 $j$ 类型和 $y_i$ 类型的估计值大小，$\Delta$ 为可接受范围。&lt;/p&gt;

&lt;h4 id=&quot;softmax&quot;&gt;Softmax&lt;/h4&gt;

&lt;p&gt;$Softmax_loss = L_i = -\log{(\frac{\exp^{f_{y_i}}}{\sum_j\exp^{f_j}})}-f_{y_j}+\log{\sum_j\exp^{f_j}}$，其中 $i$ 代表第 $i$ 个样本，$y_i$ 是该样本点正确的类别，$j$ 代表所有可能的类别，$s_j$ 和 $s_{y_i}$ 分别代表模型对于第 $i$ 个样本点为 $j$ 类型和 $y_i$ 类型的估计值大小，$\frac{e^{f_{y_j}}}{\sum_je^{f_j}}$ 相当于估计正确发生的标准化概论。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;SVM vs Softmax&lt;/p&gt;

  &lt;p&gt;SVM 与样本点的各个类别的估计值大小有关，而 Softmax 只关系其相对大小关系。&lt;/p&gt;

  &lt;p&gt;SVM 相比于 Softmax 在计算上相对简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;b-惩罚项&quot;&gt;b. 惩罚项&lt;/h3&gt;

&lt;p&gt;模型的复杂程度应该控制在合理的范围内，过于简单的模型从理论上就无法解决复杂的问题，而过于复杂的网络又可能导致训练时间的延长或出现过拟合的情况，反而使得模型的准确度降低。我们追求的模型应当在保障正确性的同时尽可能的简单，惩罚项反映了模型的复杂程度，模型越复杂，惩罚项的取值就越大，是损失函数中的一部分。&lt;/p&gt;

&lt;p&gt;以下为两个常见的惩罚项的表达式，其中 $W$ 为权重矩阵，$W_{k,l}$ 为其中的元素&lt;/p&gt;

&lt;h4 id=&quot;l1&quot;&gt;L1&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;L1 是一个常见的惩罚项，它的值为 $R(W) = \sum_k\sum_l&lt;/td&gt;
      &lt;td&gt;W_{k,l}&lt;/td&gt;
      &lt;td&gt;$​​&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;l2&quot;&gt;L2&lt;/h4&gt;

&lt;p&gt;L2 是一个常见的惩罚项，它的值为 $R(W) = \sum_k\sum_lW_{k,l}^2$​&lt;/p&gt;

&lt;h2 id=&quot;5-优化-optimization&quot;&gt;5. 优化 (optimization)&lt;/h2&gt;

&lt;p&gt;优化模型的目的是寻找适当的模型参数，使得损失函数最低。&lt;/p&gt;

&lt;h3 id=&quot;梯度下降-gradient-descent&quot;&gt;梯度下降 (gradient descent)&lt;/h3&gt;

&lt;p&gt;梯度下降是一种常用的优化方法，可以用来寻找局部最优点。它的思路是对现有模型的估计值计算梯度，找到下降最快的方向，根据损失函数 (loss function) 和学习率 (learning rate) 来决定参数的调整方向和大小，在一次次的迭代计算中找到模型参数的局部最优解。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;梯度下降需要涉及到求偏导等数学计算，在实际应用中可以用到求导的链式法则。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;6-反向传播-backpropagation&quot;&gt;6. 反向传播 (backpropagation)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;正向传播&lt;/strong&gt;是获得输入，将输入通过构建的模型计算后得到输出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;反向传播是根据模型的输出结果，根据计算出的损失函数去反向改变模型的参数，从而调整模型，使其更好的对样本进行拟合。&lt;/p&gt;

&lt;h1 id=&quot;二图像分类&quot;&gt;（二）图像分类&lt;/h1&gt;

&lt;h2 id=&quot;1-输入&quot;&gt;1. 输入&lt;/h2&gt;

&lt;h3 id=&quot;图像&quot;&gt;&lt;strong&gt;图像&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;像素 (pixel)&lt;/p&gt;

    &lt;p&gt;取值范围 0 ~ 255，0 表示黑色，255 表示白色&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通道 (channel)&lt;/p&gt;

    &lt;p&gt;彩色图像通常用 3 通道表示，分别为红色 (R)，绿色 (G) 和蓝色 (B)，简称为 RGB&lt;/p&gt;

    &lt;p&gt;而黑白图像则只由单通道表示&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-输出&quot;&gt;2. 输出&lt;/h2&gt;

&lt;p&gt;给出各类别的估计值&lt;/p&gt;

&lt;h2 id=&quot;3-难点&quot;&gt;3. 难点&lt;/h2&gt;

&lt;p&gt;图像识别对于多数人来说是极其自然的能力，但对于计算机而言却有着诸多困难，对于同一类物体而言，视角、尺度、形态的不同可能使其呈现完全不同的形态，此外，遮挡、光影等因素也会影响物体的呈现状态。另外，由于物体常常会在某个背景中出现，因此当物体与背景十分类似时，识别的困难也会增加。因此，图像处理对于计算机是较为复杂的工作。&lt;/p&gt;

&lt;h2 id=&quot;4-步骤&quot;&gt;4. 步骤&lt;/h2&gt;

&lt;p&gt;图像识别主要有三个步骤，如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;获取输入&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;获取 N 个图片作为输入，每个图片分别对应一个类别，共 k 个类别，称上述输入为&lt;strong&gt;训练集&lt;/strong&gt; (training set)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;学习训练集，训练模型&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;评估效果&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;利用&lt;strong&gt;不属于&lt;/strong&gt;训练集的数据（测试集，testing set）测试模型的准确率&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-方法&quot;&gt;5. 方法&lt;/h2&gt;

&lt;p&gt;由于上述分析中提到的，图像识别对于计算机而言有着诸多困难，因此，不同于一般的算法问题，图片分类难以有固定的解法，在实际应用中常常采用&lt;strong&gt;数据驱动&lt;/strong&gt;方法，即通过学习大量真实的样例对未知的图片进行分类。下文中将按照由简到繁的顺序介绍图像处理中应用到的各类方法。&lt;/p&gt;

&lt;h3 id=&quot;a-最近邻分类&quot;&gt;a. 最近邻分类&lt;/h3&gt;

&lt;p&gt;最近邻分类是解决图片分类问题中思路最为简单，也最为直观的方案。它在数据维度低的时候较为适宜，但由于图片普遍维度较高，尺寸较大，因此最近邻分类算法的准确度较低，在实际工程中也很少使用。此外，传统的最近邻分类器和 k-最近邻分类器虽然训练时间极短，但测试时间较长，与实际工程需求相悖。&lt;/p&gt;

&lt;h4 id=&quot;i-最近邻分类器-nearest-neighbor-classifier&quot;&gt;i. 最近邻分类器 (Nearest Neighbor Classifier)&lt;/h4&gt;

&lt;h5 id=&quot;思想&quot;&gt;思想&lt;/h5&gt;

&lt;p&gt;最近邻分类器首先获取并存储所有的训练数据，之后对应每一个待测试的数据，将其与存储的训练数据一一比较距离，距离最近的训练数据对应的类别则为最近邻分类器给出的该测试类的估计类别。&lt;/p&gt;

&lt;h5 id=&quot;距离&quot;&gt;距离&lt;/h5&gt;

&lt;p&gt;最近邻分类器以&lt;strong&gt;距离&lt;/strong&gt;作为度量图片相似度的标准，常用的距离公式如下（其中 $I_1$​ 与 $I_2$​ 分别为训练集和测试集中的一张图片，$d$​​ 为两幅图片的距离）：&lt;/p&gt;

&lt;h6 id=&quot;l1-距离-l1-distance&quot;&gt;L1 距离 (L1 distance)&lt;/h6&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$d_1(I_1, I_2)=\sum_p{&lt;/td&gt;
      &lt;td&gt;I_1^p-I_2^p&lt;/td&gt;
      &lt;td&gt;}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;该距离算法算出两幅图片相同位置上像素值的差并将其取绝对值再求和，从而得到两幅图片之间的距离。&lt;/p&gt;

&lt;h6 id=&quot;l2-距离-l2-distance&quot;&gt;L2 距离 (L2 distance)&lt;/h6&gt;

&lt;p&gt;$d_2(I_1, I_2) = \sqrt{\sum_p{(I_1^p-I_2^p)^2}}$&lt;/p&gt;

&lt;p&gt;该距离算法算出两幅图片相同位置上像素值的差并将其求平方之后加和，在开根号作为两幅图片之间的距离&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;L1&lt;/strong&gt; 与 &lt;strong&gt;L2&lt;/strong&gt; 距离的区别：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;极端数据对 L1 的影响程度小于 L2，因为 L2 会将数据进行平方运算。&lt;/li&gt;
    &lt;li&gt;计算复杂度：L2 &amp;gt; L1，因为涉及到平方与根号运算&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;优点-2&quot;&gt;优点&lt;/h5&gt;

&lt;p&gt;最近邻分类器的训练时间短（仅仅需要保存数据），且思路简单，便于实现。&lt;/p&gt;

&lt;h5 id=&quot;缺点-2&quot;&gt;缺点&lt;/h5&gt;

&lt;p&gt;正确率较低，且测试时需要与全部训练数据进行匹配，耗时较长，因此在实际工程中几乎不使用。&lt;/p&gt;

&lt;h4 id=&quot;ii-k-最近邻分类器-k-nearest-neighbor-classifier&quot;&gt;ii. k-最近邻分类器 (k-Nearest Neighbor Classifier)&lt;/h4&gt;

&lt;h5 id=&quot;思想-1&quot;&gt;思想&lt;/h5&gt;

&lt;p&gt;由于最近邻分类器可能产生过拟合的现象，k-最近邻分类器[4]在上述分类器的基础上进行改进，选出与测试样例最接近的 k 个训练样本，并取在 k 个样本中数量最多的样本类型为最终分类结果&lt;/p&gt;

&lt;h5 id=&quot;优点-3&quot;&gt;优点&lt;/h5&gt;

&lt;p&gt;k-最近拥有最近邻分类器训练时间短且思路简单的优点，且能在传统最近邻分类器上做到对于部分噪声 (noise) 的忽略，因此可以取得比传统做法更优秀的正确率。&lt;/p&gt;

&lt;h5 id=&quot;缺点-3&quot;&gt;缺点&lt;/h5&gt;

&lt;p&gt;和传统做法一样，k-NN 的测试时间长，且与训练集的大小成正比，且相比于之后提到的分类算法，k-NN 的正确率依然较低。&lt;/p&gt;

&lt;h5 id=&quot;超参数调试-hyperparameter-tuning&quot;&gt;超参数调试 (Hyperparameter tuning)&lt;/h5&gt;

&lt;p&gt;由于在 k-最近邻分类器中 k 值属于变量，无法通过直观的方法决定 k 的最佳取值，因此引入超参数调试方法，将 k 作为&lt;strong&gt;超参数&lt;/strong&gt; (hyperparameter)。&lt;/p&gt;

&lt;p&gt;超参数调试的思路是选取不同的参数取值，并测试每个参数的准确率。但需要注意的是，用测试集 (test set) 作为衡量参数正确性的标准是不合理的，测试集应当放在研究的最后阶段，理论上应当仅使用一次，用来衡量网络的效果。&lt;/p&gt;

&lt;p&gt;在网络形成过程中，为了更好的进行参数调试工作，从训练集 (training set) 中划分一部分作为验证集 (validation set)，在网络尚未完全搭建完成时利用验证集的完成情况进行超参数调试工作。&lt;/p&gt;

&lt;h5 id=&quot;交叉验证-cross-validation&quot;&gt;交叉验证 (Cross-validation)&lt;/h5&gt;

&lt;p&gt;考虑到验证集的规模可能导致对于准确率判断出现误差，因此不固定验证集，而是从训练集中随机或者按照一定的规模动态选择一部分作为训练集。&lt;/p&gt;

&lt;p&gt;一个可能的做法是，将训练集随机等分成 n 份，每次验证时候从训练集中按照从前往后的顺序循环取出一份作为验证集。(1, 2, …, n, 1, 2, …)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;尽管交叉验证可以得到更加客观的模型正确性结果，但由于动态调整验证集耗费计算资源，在实际问题中，面对数量巨大的训练集，一般很少使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;iii-近似最近邻分类器-approximate-nearest-neighbor&quot;&gt;iii. 近似最近邻分类器 (Approximate Nearest Neighbor)&lt;/h4&gt;

&lt;h5 id=&quot;树方法&quot;&gt;树方法&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Kd-tree&lt;/p&gt;

    &lt;p&gt;划分空间维度，通过缩小检索范围加速检索速度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;annoy&lt;/p&gt;

    &lt;p&gt;以二叉树为数据结构的近似最近邻搜索库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;哈希方法&quot;&gt;哈希方法&lt;/h5&gt;

&lt;p&gt;通过哈希函数将空间内的向量以 0，1 的二进制值进行编码&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;局部敏感哈希 (Local Sensitive Hashing)&lt;/p&gt;

    &lt;p&gt;通过哈希函数将所有样本点映射到不同桶中，将对于全体样本的比对搜索化简为对某一特定桶的比对搜索&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;矢量量化方法&quot;&gt;矢量量化方法&lt;/h5&gt;

&lt;p&gt;将样本点分成若干类，每一类用其中心点表示。&lt;/p&gt;

&lt;h5 id=&quot;近邻图方法&quot;&gt;近邻图方法&lt;/h5&gt;

&lt;p&gt;建立图结构，图的顶点是样本点，边的权重为样本点之间的距离。利用图论算法在途中搜索得到最近邻&lt;/p&gt;

&lt;h4 id=&quot;iv-快速最近邻分类器-fast-nearest-neighbor&quot;&gt;iv. 快速最近邻分类器 (Fast Nearest Neighbor)&lt;/h4&gt;

&lt;h3 id=&quot;b-主成分分析法-principal-component-analysis&quot;&gt;b. 主成分分析法 (Principal Component Analysis)&lt;/h3&gt;

&lt;p&gt;与特征分析方法类似，主成分分析法[5]基于多元素特征值分析，是一种降维度的分析方法，将高维样本降维，只关注样本点的主要成分。&lt;/p&gt;

&lt;p&gt;主成分分析法的原则是在降低分析指标（维度）的同时保留样本点的基本信息，保障其差异性。&lt;/p&gt;

&lt;p&gt;坐标系的选择原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;体现样本点之间的差异&lt;/li&gt;
  &lt;li&gt;相互垂直&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;c-近邻成分分析法-neighborhood-component-analysis&quot;&gt;c. 近邻成分分析法 (Neighborhood Component Analysis)&lt;/h3&gt;

&lt;p&gt;邻近成分分析法属于受监督的机器学习方法，与 k-最近邻算法相类似，不同之处在于 NCA 会通过学习样本数数据确定适合的距离测度算法。&lt;/p&gt;

&lt;h3 id=&quot;d-随机投射-random-projection&quot;&gt;d. 随机投射 (Random Projection)&lt;/h3&gt;

&lt;p&gt;随即投射[6]的目的在于降低欧氏空间样本点的维度。通过随机生成的 $d\times k$​​ 矩阵将原有 $d$​​ 维数据投影到 $k$​​ 维空间内（注意：随机选择的矩阵各个行、列向量&lt;strong&gt;可以&lt;/strong&gt;不满足正交关系，但需要经过归一化处理）。Johnson 的论文中用数学方法论证了随机投射方法的可行性。&lt;/p&gt;

&lt;h3 id=&quot;e-线性分类器-linear-classification&quot;&gt;e. 线性分类器 (Linear Classification)&lt;/h3&gt;

&lt;p&gt;线性分类器通过线性函数将样本点分类，它主要由两部分构成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;评分函数&lt;/strong&gt; (score function)&lt;/p&gt;

    &lt;p&gt;评分函数反映了各个因素的重要程度&lt;/p&gt;

    &lt;p&gt;$f(x_i, W, b) = Wx_i + b$&lt;/p&gt;

    &lt;p&gt;上式中，$x_i$ 为输入的图片样例（矩阵形式），$W$​​​​​ 为权重函数，意味着图片的各个部分在图片分类问题中的重要程度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;损失函数&lt;/strong&gt; (loss function)&lt;/p&gt;

    &lt;p&gt;损失函数是用来度量模型效果的函数，损失越小意味着模型越准确。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线性分类器的目的在于寻找最佳的权重函数，使损失函数降到最低。&lt;/p&gt;

&lt;h3 id=&quot;f-人工神经网络-artificial-neural-network&quot;&gt;f. 人工神经网络 (Artificial Neural Network)&lt;/h3&gt;

&lt;p&gt;人工神经网络模仿动物神经网络，是一种常用的数学模型。神经网络包括输入层、隐藏层和输出层，其中，隐藏层可以有多层&lt;/p&gt;

&lt;h1 id=&quot;三参考文献&quot;&gt;（三）参考文献&lt;/h1&gt;

&lt;p&gt;[1] sigmoid 激活函数，https://en.wikipedia.org/wiki/Sigmoid_function&lt;/p&gt;

&lt;p&gt;[2] tanh 激活函数，https://en.wikipedia.org/wiki/Hyperbolic_functions&lt;/p&gt;

&lt;p&gt;[3] ReLU 激活函数，https://en.wikipedia.org/wiki/Rectifier_(neural_networks)&lt;/p&gt;

&lt;p&gt;[4]  Fix, Evelyn; Hodges, Joseph L. (1951). Discriminatory Analysis. Nonparametric Discrimination: Consistency Properties (PDF) (Report). USAF School of Aviation Medicine, Randolph Field, Texas.&lt;/p&gt;

&lt;p&gt;[5] Pearson, K. (1901). “On Lines and Planes of Closest Fit to Systems of Points in Space”. Philosophical Magazine. 2 (11): 559–572. doi:10.1080/14786440109462720.&lt;/p&gt;

&lt;p&gt;[6] Johnson, William B.; Lindenstrauss, Joram (1984). “Extensions of Lipschitz mappings into a Hilbert space”. Conference in Modern Analysis and Probability (New Haven, Conn., 1982). Contemporary Mathematics. 26. Providence, RI: American Mathematical Society. pp. 189–206. doi:10.1090/conm/026/737400. ISBN 9780821850305. MR 0737400&lt;/p&gt;</content><author><name>ericaaaaaaaa</name></author><category term="ArtificialIntelligence" /><category term="note" /><category term="artificial-intelligence" /><category term="computer-vision" /><summary type="html">计算机视觉</summary></entry></feed>