<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-01-28T18:46:02+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Erica’s Blog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>ericaaaaaaaa</name></author><entry><title type="html">Machine Learning</title><link href="http://localhost:4000/artificialintelligence/2022/01/28/MachineLearning.html" rel="alternate" type="text/html" title="Machine Learning" /><published>2022-01-28T00:00:00+08:00</published><updated>2022-01-28T00:00:00+08:00</updated><id>http://localhost:4000/artificialintelligence/2022/01/28/MachineLearning</id><content type="html" xml:base="http://localhost:4000/artificialintelligence/2022/01/28/MachineLearning.html"><![CDATA[<center><h1>Machine Learning</h1></center>

<blockquote>
  <p>Tutor: $\mathscr{Andrew Ng}$</p>

  <p>Author of the notebook: $\mathscr{ericaaaaaaaa}$</p>
</blockquote>

<div style="background-color: #D6EAF8;"><b><h4>Machine Learning</h4></b></div>
<div>A computer program is said to <i>learn</i> from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.</div>
<div>Category<ul><li>Supervised Learning</li><li>Unsupervised Learning</li></ul></div>

<div style="background-color: #D6EAF8;"><b><h4>Supervised Learning</h4></b></div>
<div>"right answers" given</div>

<div style="background-color: #D6EAF8;"><b><h4>Regression Problem</h4></b></div>
<div>Predict <b>continuous</b> valued output.</div>

<div style="background-color: #D6EAF8;"><b><h4>Classification Problem</h4></b></div>
<div>Predict <b>discrete</b> valued output.</div>

<div style="background-color: #D6EAF8;"><b><h4>Unsupervised Learning</h4></b></div>
<div>no "right answers" given</div>]]></content><author><name>ericaaaaaaaa</name></author><category term="ArtificialIntelligence" /><category term="note" /><category term="machine-learning" /><category term="artificial-intelligence" /><summary type="html"><![CDATA[Machine Learning]]></summary></entry><entry><title type="html">Algorithm</title><link href="http://localhost:4000/algorithms/2022/01/11/Algorithm.html" rel="alternate" type="text/html" title="Algorithm" /><published>2022-01-11T00:00:00+08:00</published><updated>2022-01-11T00:00:00+08:00</updated><id>http://localhost:4000/algorithms/2022/01/11/Algorithm</id><content type="html" xml:base="http://localhost:4000/algorithms/2022/01/11/Algorithm.html"><![CDATA[<h1 id="introduction">Introduction</h1>

<h2 id="definition">Definition</h2>

<h3 id="problem-instance">Problem Instance</h3>

<p>A problem instance is any valid input to the problem.</p>

<h3 id="algorithm">Algorithm</h3>

<p>An <strong>algorithm</strong> is a well defined <strong>computational procedure</strong> that transforms inputs into outputs, achieving the desired input-output relationship.</p>

<h3 id="correct-algorithm">Correct Algorithm</h3>

<p>A <strong>correct algorithm</strong> <strong>halts</strong> with the correct output for every input instance. We can then say that the algorithm <strong>solves</strong> the problem.</p>

<h2 id="analyzing-algorithms">Analyzing Algorithms</h2>

<h4 id="predict-resource-utilization">Predict Resource Utilization</h4>

<ul>
  <li>
    <p><strong>Memory</strong> (space complexity)</p>
  </li>
  <li>
    <p><strong>Running time</strong> (time complexity)</p>

    <ul>
      <li>depends on the speed of the computer</li>
      <li>depends on the implementation details</li>
      <li>depends on the input, especially on the size of the input</li>
    </ul>

    <p>Measure the running time as the number of <strong>primitive operations</strong> used by the algorithm. (mathematically elegant and machine-independent)</p>

    <p>Measure the running time as <strong>a function of the input size</strong>. Let <code class="language-plaintext highlighter-rouge">n</code> denote the input size and let <code class="language-plaintext highlighter-rouge">T(n)</code> denote the running time for input of size n.</p>
  </li>
</ul>

<h3 id="three-kinds-of-analysis">Three Kinds of Analysis</h3>

<h4 id="worst-case">Worst Case</h4>

<p>Commonly used</p>

<ul>
  <li>Running time guarantee</li>
  <li>Fair comparison</li>
</ul>

<h4 id="average-case">Average Case</h4>

<p>Used sometimes</p>

<ul>
  <li>Need to assume distribution</li>
  <li>Analysis is complicated</li>
</ul>

<h4 id="best-case">Best Case</h4>

<p>useless</p>

<h3 id="comparing-time-complexity">Comparing Time Complexity</h3>

<h4 id="o-notation-upper-bounds">$O$-notation (Upper bounds)</h4>

<p>$f(n)=O(g(n))$: There exists constant $c&gt;0$ and $n_0$ such that $f(n)\le c\cdot g(n)$ for $n\ge n_0$</p>

<h4 id="omega-notation-lower-bounds">$\Omega$-notation (Lower bounds)</h4>

<p>$f(n)=\Omega(g(n))$: There exists constant $c&gt;0$ and $n_0$ such that $f(n)\ge c\cdot g(n)$ for $n\ge n_0$</p>

<h4 id="theta-notation-tight-bounds">$\Theta$-notation (Tight bounds)</h4>

<p>$f(n)=\Theta(g(n))$: $f(n)=O(g(n))$ and $f(n)=\Omega(g(n))$</p>

<h4 id="examples">Examples</h4>

<ul>
  <li>$\sum_{i=1}^{n}i = \frac{n(n+1)}{2}$</li>
  <li>$\sum_{i=1}^{n}i^2 = \frac{n(n+1)(2n+1)}{6}$</li>
  <li>$\sum_{i=1}^{n}\frac{1}{n}=O(\log n)$ (Harmonic Series，调和级数)</li>
  <li>$\log(n!)=\log(n) + \log(n-1) + …+\log(1)=O(n\log n)$</li>
</ul>

<h3 id="递归分析主定理法">递归分析：主定理法</h3>

<p>$$
T(n) = 
\left{
\begin{array}{l}
\Theta(f(n)) &amp; if\ f(n)=\Omega(n^{\log_ba+\varepsilon})<br />
\Theta(n^{\log_ba}\log n) &amp; if\ f(n)=\Theta(n^{\log_b a}) <br />
\Theta(n^{\log_ba}) &amp; if\ f(n)=O(n^{\log_ba-\varepsilon})
\end{array}
\right.
$$</p>

<h1 id="divide-and-conquer-algorithms">Divide and Conquer Algorithms</h1>

<h2 id="step">Step</h2>

<p><strong>分而治之</strong></p>

<ol>
  <li><strong>分解</strong>原问题</li>
  <li><strong>解决</strong>子问题</li>
  <li><strong>合并</strong>问题解</li>
</ol>

<h2 id="merge-sort-归并排序">Merge Sort 归并排序</h2>

<p>归并排序：分解数组，递归求解，合并排序</p>

<h3 id="算法流程">算法流程</h3>

<ol>
  <li>将数组 A[1, n] 排序问题<strong>分解</strong>为 A[1, [n/2]] 和 A[[n/2]+1, n] 排序问题</li>
  <li><strong>递归解决</strong>子问题得到两个有序的子数组</li>
  <li>将两个有序子数组<strong>合并</strong>为一个有序数组</li>
</ol>

<h3 id="伪代码">伪代码</h3>

<p><img src="/assets/images/post/merge_sort.png" alt="" /></p>

<p><img src="/assets/images/post/merge.png" alt="" /></p>

<h3 id="复杂度分析">复杂度分析</h3>

<p>$T(n) = O(n\log n)$</p>

<h2 id="maximum-contiguous-subarray-problem-最大子数组">Maximum Contiguous Subarray Problem 最大子数组</h2>

<h3 id="伪代码-1">伪代码</h3>

<p><img src="/assets/images/post/MCS.png" alt="" /></p>

<p><img src="/assets/images/post/find_max.png" alt="" /></p>

<h3 id="复杂度">复杂度</h3>

<p>$f(n)=O(n\log n)$</p>

<h2 id="counting-inversions-逆序计数">Counting Inversions 逆序计数</h2>

<h3 id="问题介绍">问题介绍</h3>

<p>The total number of inversions in $\sum_{1\le i\le j\le n}$, namely
$$
X_{i, j} = 
\left{
\begin{array}{rcl}
1 &amp; A[i]&gt;A[j]<br />
0 &amp; A[i]\le A[j]
\end{array}
\right.
$$</p>

<h3 id="伪代码-2">伪代码</h3>

<p><img src="/assets/images/post/merge_count.png" alt="" /></p>

<p><img src="/assets/images/post/sort_count.png" alt="" /></p>

<h3 id="复杂度-1">复杂度</h3>

<p>$T(n)=n\log n$</p>

<h2 id="polynomial-multiplication-多项式乘法">Polynomial Multiplication 多项式乘法</h2>

<h3 id="description">Description</h3>

<p><img src="/assets/images/post/def.png" alt="" /></p>

<ul>
  <li><strong>Input</strong>: Assume that the coefficients a$_i$ and b$_i$ are stored in arrays A[0…n] and B[0…m]</li>
</ul>

<h3 id="伪代码-3">伪代码</h3>

<p><img src="/assets/images/post/poly_mult1.png" alt="" /></p>

<p><img src="/assets/images/post/poly_mult2.png" alt="" /></p>

<h2 id="quicksort-and-partition-快速排序与划分">QuickSort and Partition 快速排序与划分</h2>

<h3 id="算法思路">算法思路</h3>

<ol>
  <li>选取固定位置主元 x （如尾元素）</li>
  <li>维护两个部分的右端点变量 i, j</li>
  <li>考察数组 A[j]，只和主元比较
    <ul>
      <li>若 A[j] ≤ x，则交换 A[j] 和 A[i+1]，i, j 右移</li>
      <li>若 A[j] &gt; x，则 j 右移</li>
    </ul>
  </li>
  <li>把主元放在中间作分界线</li>
</ol>

<p><img src="/assets/images/post/t.png" alt="" /></p>

<p><img src="/assets/images/post/p.png" alt="" /></p>

<h3 id="伪代码-4">伪代码</h3>

<p><img src="/assets/images/post/partition.png" alt="" /></p>

<p><img src="/assets/images/post/quick_sort.png" alt="" /></p>

<h3 id="复杂度-2">复杂度</h3>

<ul>
  <li>最好情况：$O(n\log n)$</li>
  <li>最坏情况：$O(n^2)$</li>
</ul>

<h3 id="优化随机选择主元">优化——随机选择主元</h3>

<p><img src="/assets/images/post/random_partition.png" alt="" /></p>

<h4 id="期望时间复杂度">期望时间复杂度</h4>

<p>$O(n\log n)$</p>

<h2 id="randomized-selection-随机化选择">Randomized Selection 随机化选择</h2>

<h3 id="次序选择问题">次序选择问题</h3>

<h4 id="形式化定义">形式化定义</h4>

<p><img src="/assets/images/post/k_min.png" alt="" /></p>

<h4 id="算法思想">算法思想</h4>

<ul>
  <li>选取固定位置主元，小于主元的元素个数 q-p
    <ul>
      <li>情况 1：k = q - p + 1，A[q] 为数组第 k 小元素</li>
      <li>情况 2：k &lt; q - p + 1，在 A[p .. q - 1] 中寻找第 k 小元素</li>
      <li>情况 3：k &gt; q - p + 1，在 A[q + 1 .. r] 中寻找第 k - (q - p + 1) 小元素</li>
    </ul>
  </li>
</ul>

<h4 id="伪代码-5">伪代码</h4>

<p><img src="/assets/images/post/partition.png" alt="" /></p>

<p><img src="/assets/images/post/selection.png" alt="" /></p>

<h4 id="复杂度-3">复杂度</h4>

<ul>
  <li>最好情况：$T(n) = O(n)$</li>
  <li>最差情况：$T(n) = O(n^2)$</li>
</ul>

<h4 id="优化算法随机选择主元">优化算法——随机选择主元</h4>

<p><img src="/assets/images/post/rp.png" alt="" /></p>

<p><img src="/assets/images/post/rs.png" alt="" /></p>

<p>期望时间复杂度：$O(n)$</p>

<h2 id="supplement-topic-of-sorting-排序问题补充主题">Supplement Topic of Sorting 排序问题补充主题</h2>

<h3 id="heapsort-堆排序">Heapsort 堆排序</h3>

<h4 id="heap">Heap</h4>

<h5 id="definition-1">Definition</h5>

<p>Heaps are “almost complete binary trees”</p>

<ul>
  <li>All levels are full except possibly the lowest level</li>
  <li>If the lowest level is not full, then nodes must packed to the left</li>
  <li>The values of the node is at least the value of its parent. <code class="language-plaintext highlighter-rouge">A[Parent(i)] &lt;= A[i]</code></li>
</ul>

<h5 id="operation">Operation</h5>

<ul>
  <li><strong>Insert</strong> in $O(\log n)$ time</li>
  <li><strong>Extract-Min</strong> in $O(\log n)$ time</li>
</ul>

<h5 id="properties">Properties</h5>

<ul>
  <li>A heap of height h has between $2^h$ to $2^{h+1}-1$ nodes. Thus, an n-element heap has height $\Theta(\log n)$</li>
  <li>The structure is so regular, it can be represented in an array and no links are necessary</li>
</ul>

<h5 id="array-implementation-of-heap">Array Implementation of Heap</h5>

<ul>
  <li>The root is in array position 1</li>
  <li>For any element in array position i
    <ul>
      <li>The left child is in position 2i</li>
      <li>The right child is in position 2i+1</li>
      <li>The parent is in position [i/2]</li>
    </ul>
  </li>
</ul>

<h4 id="heapsort">Heapsort</h4>

<ul>
  <li>Build a binary heap of n elements
    <ul>
      <li>the minimum element is at the top of the heap</li>
      <li>insert n elements one by one</li>
    </ul>
  </li>
  <li>Perform n Extract-Min operations
    <ul>
      <li>the elements are extracted in sorted order</li>
      <li>each Extract-Min operation takes $O(\log n)$ time</li>
    </ul>
  </li>
  <li>Total time complexity: $O(n\log n)$</li>
</ul>

<h3 id="lower-bound-for-sorting-基于比较的排序下界">Lower Bound for Sorting 基于比较的排序下界</h3>

<p>Any comparison-based sorting algorithm requires $\Omega(n\log n)$ comparisons.</p>

<h4 id="counting-sort">Counting-Sort</h4>

<p><img src="/assets/images/post/counting_sort.png" alt="" /></p>

<h3 id="sorting-in-linear-time-线性时间排序">Sorting in Linear Time 线性时间排序</h3>

<h1 id="dynamic-programming-algorithms">Dynamic Programming Algorithms</h1>

<h3 id="动态规划算法">动态规划算法</h3>

<ul>
  <li>
    <p><strong>问题结构分析</strong></p>

    <p>给出问题表示，明确原始问题</p>
  </li>
  <li>
    <p><strong>递推关系建立</strong></p>

    <p>分析最优结构，构造递推公式</p>
  </li>
  <li>
    <p><strong>自底向上计算</strong></p>

    <p>确定计算顺序，依次求解问题</p>
  </li>
  <li>
    <p><strong>最优方案追踪</strong></p>

    <p>记录决策过程，输出最优方案</p>
  </li>
</ul>

<h3 id="0-1-knapsack-0-1-背包问题">0-1 Knapsack 0-1 背包问题</h3>

<h4 id="输入">输入</h4>

<ul>
  <li>n 个商品组成集合 0，每个商品有两个属性 $v_i$ 和 $p_i$，分别表示体积和价格</li>
  <li>背包容量为 $C$</li>
</ul>

<h4 id="输出">输出</h4>

<p>求解一个商品子集 $S\subseteq 0$，</p>

<ul>
  <li><strong>优化目标</strong>：令 $\max \sum_{i\in S}p_i$</li>
  <li><strong>约束条件</strong>：$\sum_{i\in S}v_i\le C$</li>
</ul>

<h4 id="递归函数">递归函数</h4>

<p>$$
KnapsackSR(h, i, c)=\\ \max{KnapsackSR(h, i-1, c-v_i)+p_i, KnapsackSR(h, i-1, c)}
$$</p>

<h4 id="算法复杂度">算法复杂度</h4>

<p><img src="/assets/images/post/0-1knap.png" alt="" /></p>

<h4 id="计算顺序">计算顺序</h4>

<p><img src="/assets/images/post/seq.png" alt="" /></p>

<p><img src="/assets/images/post/rec.png" alt="" /></p>

<h4 id="伪代码-6">伪代码</h4>

<p><img src="/assets/images/post/knap.png" alt="" /></p>

<p><img src="/assets/images/post/knapdp.png" alt="" /></p>

<p><img src="/assets/images/post/knapdp1.png" alt="" /></p>

<h4 id="时间复杂度">时间复杂度</h4>

<p>$O(n\cdot C)$</p>

<h3 id="maximum-contiguous-subarray-ii-最大连续数组-ii">Maximum Contiguous Subarray II 最大连续数组 II</h3>

<h4 id="问题定义">问题定义</h4>

<p><img src="/assets/images/post/qq1.png" alt="" /></p>

<h4 id="问题结构分析">问题结构分析</h4>

<p>$D[i]$：以 $X[i]$ 开头的最大子数组和</p>

<p>原始问题：$S_{max}=\max_{1\le i\le n}{D[i]}$</p>

<h4 id="递推关系建立">递推关系建立</h4>

<p>$$
D[i] = 
\left{
\begin{array}{l}
X[i] + D[i+1] &amp; if\ D[i+1] &gt; 0<br />
X[i] &amp; if\ D[i+1] \le 0
\end{array}
\right.
$$</p>

<p>构造追踪数组 $Rec[1..n]$</p>

<h4 id="伪代码-7">伪代码</h4>

<p><img src="/assets/images/post/mcsdp.png" alt="" /></p>

<p><img src="/assets/images/post/mcsdp1.png" alt="" /></p>

<h4 id="时间复杂度-1">时间复杂度</h4>

<p>$T(n) = O(n)$</p>

<h3 id="longest-common-subsequences-最长公共子序列">Longest Common Subsequences 最长公共子序列</h3>

<h4 id="问题描述">问题描述</h4>

<p><img src="/assets/images/post/lcs.png" alt="" /></p>

<h4 id="问题表示">问题表示</h4>

<p>$C[i, j]$：$X[1..i]$ 和 $Y[1..j]$ 的最长公共子序列长度</p>

<h4 id="递推关系建立-1">递推关系建立</h4>

<p>$$
C[i,j]=
\left{
\begin{array}{l}
\max{C[i-1,j], C[i,j-1]} &amp; x_i\not= y_j<br />
C[i-1,j-1]+1 &amp; x_i=y_j
\end{array}
\right.
$$</p>

<p><img src="/assets/images/post/cls2.png" alt="" /></p>

<p><img src="/assets/images/post/rec1.png" alt="" /></p>

<h4 id="伪代码-8">伪代码</h4>

<p><img src="/assets/images/post/lcs1.png" alt="" /></p>

<p><img src="/assets/images/post/lcs2.png" alt="" /></p>

<p><img src="/assets/images/post/plcs.png" alt="" /></p>

<h4 id="时间复杂度-2">时间复杂度</h4>

<p>$O(n\cdot m)$</p>

<h3 id="longest-common-substrings-最长公共子串">Longest Common Substrings 最长公共子串</h3>

<h4 id="问题描述-1">问题描述</h4>

<p><img src="/assets/images/post/lss.png" alt="" /></p>

<h4 id="问题表示-1">问题表示</h4>

<p>$C[i,j]$：在 $X[1..i]$ 和 $Y[1..j]$ 中，以 $x_i$ 和 $y_j$ 结尾的最长公共子串 $Z[1..l]$ 的长度</p>

<h4 id="递推关系建立-2">递推关系建立</h4>

<p>$$
C[i,j]=
\left{
\begin{array}{l}
0 &amp; x_i\not=y_j<br />
C[i-1,j-1]+1&amp;x_i=y_j
\end{array}
\right.
$$</p>

<p><img src="/assets/images/post/sll1.png" alt="" /></p>

<h4 id="伪代码-9">伪代码</h4>

<p><img src="/assets/images/post/sll2.png" alt="" /></p>

<p><img src="/assets/images/post/sll3.png" alt="" /></p>

<p><img src="/assets/images/post/sll4.png" alt="" /></p>

<h4 id="时间复杂度-3">时间复杂度</h4>

<p>$O(n\cdot m)$</p>

<h3 id="minimum-edit-distance-最小编辑距离">Minimum Edit Distance 最小编辑距离</h3>

<h4 id="问题描述-2">问题描述</h4>

<p>编辑操作</p>

<ul>
  <li>删除</li>
  <li>插入</li>
  <li>替换</li>
</ul>

<p><img src="/assets/images/post/med1.png" alt="" /></p>

<h4 id="问题表示-2">问题表示</h4>

<p>$D[i,j]$：字符串 $s[1..i]$ 变成 $t[1..j]$ 的最小编辑距离
$$
D[i,j]=\min
\left{
\begin{array}{l}
D[i-1,j]+1 &amp; 删除<br />
D[i,j-1]+1 &amp; 插入<br />
D[i-1,j-1]+
\left{
\begin{array}{l}
0 &amp; if\ s[i] = t[j]<br />
1 &amp; if\ s[i]\not= t[j]
\end{array}
\right.
\end{array}
\right.
$$</p>

<h4 id="递推关系建立-3">递推关系建立</h4>

<p><img src="/assets/images/post/med2.png" alt="" /></p>

<h4 id="伪代码-10">伪代码</h4>

<p><img src="/assets/images/post/med3.png" alt="" /></p>

<p><img src="/assets/images/post/med4.png" alt="" /></p>

<p><img src="/assets/images/post/med5.png" alt="" /></p>

<h4 id="时间复杂度-4">时间复杂度</h4>

<p>$O(mn)$</p>

<h3 id="rod-cutting-钢条切割">Rod-Cutting 钢条切割</h3>

<h4 id="问题描述-3">问题描述</h4>

<p><img src="/assets/images/post/rc1.png" alt="" /></p>

<h4 id="问题表示-3">问题表示</h4>

<p>$C[j]$：切割长度为 $j$ 的钢条可获得的最大收益</p>

<p>$rec[j]$：记录长度为 $j$ 钢条的最优切割方案</p>

<h4 id="递归结构建立">递归结构建立</h4>

<p>$$
C[j] = \max_{1\le i\le j-1}{p[i] + C[j-i],p[j]}
$$</p>

<h4 id="伪代码-11">伪代码</h4>

<p><img src="/assets/images/post/rc2.png" alt="" /></p>

<p><img src="/assets/images/post/rc3.png" alt="" /></p>

<h4 id="算法复杂度-1">算法复杂度</h4>

<p>$O(n^2)$</p>

<h3 id="chain-matrix-multiplication-矩阵链乘法">Chain Matrix Multiplication 矩阵链乘法</h3>

<h4 id="问题定义-1">问题定义</h4>

<p><img src="/assets/images/post/mm1.png" alt="" /></p>

<h4 id="问题描述-4">问题描述</h4>

<p>$D[i,j]$：计算矩阵链 $U_{i..j}$ 所需标量乘法的<strong>最小次数</strong></p>

<h4 id="递归表达式建立">递归表达式建立</h4>

<p>$$
D[i,j]=\min_{1\le k&lt;j}(D[i,k]+D[k+1,j+p_{i-1}p_kp_j])
$$</p>

<p><img src="/assets/images/post/mm2.png" alt="" /></p>

<p><img src="/assets/images/post/mm3.png" alt="" /></p>

<p><img src="/assets/images/post/m4.png" alt="" /></p>

<h4 id="伪代码-12">伪代码</h4>

<p><img src="/assets/images/post/mm4.png" alt="" /></p>

<p><img src="/assets/images/post/mm5.png" alt="" /></p>

<p><img src="/assets/images/post/mm6.png" alt="" /></p>

<h4 id="时间复杂度-5">时间复杂度</h4>

<p>$O(n^3)$</p>

<h1 id="greedy-algorithms">Greedy Algorithms</h1>

<h2 id="算法描述">算法描述</h2>

<ul>
  <li>
    <p><strong>提出贪心策略</strong></p>

    <p>观察问题特征，构造贪心选择</p>
  </li>
  <li>
    <p><strong>证明策略正确</strong></p>

    <p>假设最优方案，通过替换证明</p>
  </li>
</ul>

<h2 id="fractional-knapsack-部分背包问题">Fractional Knapsack 部分背包问题</h2>

<h3 id="问题定义-2">问题定义</h3>

<p><img src="/assets/images/post/fkp1.png" alt="" /></p>

<h3 id="问题描述-5">问题描述</h3>

<h3 id="伪代码-13">伪代码</h3>

<p><img src="/assets/images/post/fkp2.png" alt="" /></p>

<h3 id="算法复杂度-2">算法复杂度</h3>

<p>$O(n\log n)$</p>

<h2 id="huffman-coding-problem-赫夫曼编码">Huffman Coding Problem 赫夫曼编码</h2>

<h3 id="背景">背景</h3>

<ul>
  <li><strong>编码树</strong>
    <ul>
      <li>顶点到左结点的边标记为 0，到右节点的边标记 1，通过编码方案构造编码树</li>
      <li>每条根到叶子的路径对应的每个字符的二进制串</li>
    </ul>
  </li>
</ul>

<h3 id="问题定义-3">问题定义</h3>

<p><img src="/assets/images/post/hc1.png" alt="" /></p>

<h3 id="伪代码-14">伪代码</h3>

<p><img src="/assets/images/post/hc2.png" alt="" /></p>

<h3 id="算法复杂度-3">算法复杂度</h3>

<p>$O(n\log n)$</p>

<h2 id="activity-selection-problem-活动选择问题">Activity Selection Problem 活动选择问题</h2>

<h3 id="无权重">无权重</h3>

<h4 id="问题定义-4">问题定义</h4>

<p><img src="/assets/images/post/asp1.png" alt="" /></p>

<h4 id="算法思路-1">算法思路</h4>

<p>选择最早结束的活动，可以给后面的活动留更大的空间。</p>

<h4 id="伪代码-15">伪代码</h4>

<p><img src="/assets/images/post/asp2.png" alt="" /></p>

<h4 id="算法复杂度-4">算法复杂度</h4>

<p>$O(n\log n)$</p>

<h3 id="有权重">有权重</h3>

<h4 id="问题定义-5">问题定义</h4>

<p><img src="/assets/images/post/asp3.png" alt="" /></p>

<h4 id="问题分析">问题分析</h4>

<p>$D[i]$：集合 ${a_1,a_2,a_3,…,a_i}$ 中不冲突活动的最大权限和</p>

<h4 id="递推关系建立-4">递推关系建立</h4>

<p>$$
D[i] = \max{D[p[i]]+w_i,D[i-1] }<br />
Rec[i] = 
\left{
\begin{array}{l}
1 &amp; 选择活动 a_i<br />
0 &amp; 不选活动 a_i
\end{array}
\right.
$$</p>

<p><img src="/assets/images/post/asp4.png" alt="" /></p>

<h4 id="伪代码-16">伪代码</h4>

<p><img src="/assets/images/post/asp5.png" alt="" /></p>

<p><img src="/assets/images/post/asp6.png" alt="" /></p>

<p><img src="/assets/images/post/asp7.png" alt="" /></p>

<h4 id="算法复杂度-5">算法复杂度</h4>

<p>$O(n\log n)$</p>

<h1 id="graph-algorithms">Graph Algorithms</h1>

<h2 id="basic-concepts-in-graphs">Basic Concepts in Graphs</h2>

<h3 id="图的概念">图的概念</h3>

<h4 id="图的定义">图的定义</h4>

<p><strong>图</strong>可以表示为一个二元组 $G=&lt;V, E&gt;$，其中</p>

<ul>
  <li>
    <p>$V$ 表示非空顶点集，其元素称为顶点 (Vertex)</p>
  </li>
  <li>
    <p>$E$ 表示边集，其元素称为边 (Edge)</p>

    <p>$e=(u,v)$ 表示一条边，其中 $u\in V,v\in V,e\in E$</p>
  </li>
</ul>

<h4 id="相邻和关联">相邻和关联</h4>

<h5 id="相邻-adjacent">相邻 (Adjacent)</h5>

<p>边 $(u,v)$ 连接的顶点 $u$ 和 $v$ <strong>相邻</strong></p>

<h5 id="关联-incident">关联 (Incident)</h5>

<p>边 $(u,v)$ 和其连接的顶点 $u$ (或 $v$) 相互关联</p>

<h4 id="度">度</h4>

<h5 id="顶点的度-degree-of-a-vertex">顶点的度 (Degree of a Vertex)</h5>

<p>顶点 $v$ 的度 $deg(v)$ 是 $v$ 关联的边数</p>

<h5 id="图的度-degree-of-a-graph">图的度 (Degree of a Graph)</h5>

<p>图 $G=&lt;V,E&gt;$ 的度，是图各顶点的度之和，$deg(G)=\sum_{v\in V}deg(v)$</p>

<h4 id="握手定理-handshaking-lemma">握手定理 (Handshaking Lemma)</h4>

<ul>
  <li>无向图的度是边数的两倍</li>
</ul>

<h4 id="路径-path">路径 (Path)</h4>

<ul>
  <li>图中一个顶点序列 $&lt;v_0,v_1,…,v_k&gt;$ 称为 $v_0$ 到 $v_k$ 的<strong>路径</strong></li>
  <li>路径包含顶点 $v_0,v_1,…,v_k$ 和边 $(v_0,v_1),(v_1,v_2),…,(v_{k-1}, v_k)$</li>
  <li>存在路径 $&lt;v_0,v_1,…,v_k&gt;$，则 $v_0$ <strong>可达</strong> $v_k$</li>
  <li>如果 $v_0,v_1,…,v_k$ 互不相同，则该路径的<strong>简单</strong>的</li>
</ul>

<h4 id="环路-cycle">环路 (Cycle)</h4>

<ul>
  <li>如果路径 $&lt;v_0,v_1,…,v_k&gt;$ 中 $v_0=v_k$ 且至少包含一条边，则该路径构成<strong>环路</strong>。</li>
  <li>如果 $v_0,v_1,…,v_k$ 互不相同，则该环路的<strong>简单</strong>的</li>
  <li><strong>无环图</strong> (Acyclic Graph)：图中不存在环路</li>
</ul>

<h4 id="连通-connectivity">连通 (Connectivity)</h4>

<h5 id="连通">连通</h5>

<ul>
  <li>如果图的<strong>任意对顶点互相可达</strong>，则称该图是<strong>连通</strong>的，反之称为<strong>非连通</strong></li>
</ul>

<h5 id="连通分量-connected-components">连通分量 (Connected Components)</h5>

<ul>
  <li>根据是否连通将顶点进行分组，相互可达的顶点集称为<strong>连通分量</strong></li>
</ul>

<h4 id="子图-subgraph">子图 (Subgraph)</h4>

<h5 id="子图-subgraph-1">子图 (Subgraph)</h5>

<ul>
  <li>如果 $V’\subseteq V,E’\subseteq E$，则称图 $G’=&lt;V’,E’&gt;$ 是图 $G$ 的一个<strong>子图</strong>。</li>
</ul>

<h5 id="生成子图-spanning-subgraph">生成子图 (Spanning Subgraph)</h5>

<ul>
  <li>如果 $V’=V, E\subseteq E$，则称图 $G’=&lt;V’, E’&gt;$ 是图 $G$ 的一个<strong>生成子图</strong>。</li>
</ul>

<h4 id="树-tree">树 Tree</h4>

<h5 id="树-tree-1">树 (Tree)</h5>

<table>
  <tbody>
    <tr>
      <td>连通、无环图 $T=&lt;V_T,E_T&gt;$，树有 $</td>
      <td>V_T</td>
      <td>-1$ 条边</td>
    </tr>
  </tbody>
</table>

<h5 id="森林-forest">森林 (Forest)</h5>

<p>一至多棵树组成的无环图</p>

<h3 id="图的表示">图的表示</h3>

<h4 id="邻接链表">邻接链表</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>图 $G=&lt;V,E&gt;$，其邻接链表由 $</td>
          <td>V</td>
          <td>$ 条链表的数组构成</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>每个顶点有一条链表，包含所有与其相邻的顶点</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>空间大小 $O(</td>
          <td>V</td>
          <td>+</td>
          <td>E</td>
          <td>)$</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="邻接矩阵">邻接矩阵</h4>

<ul>
  <li>
    <p>图 $G=&lt;V,E&gt;$ 的邻接矩阵由 $|V|\times |V|$ 的二维数组 $A$ 构成，满足
$$
A_{ij}=
\left{
\begin{array}{l}
1 &amp; (i,j)\in E<br />
0 &amp; (i,j)\not\in E
\end{array}
\right.
$$</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>空间大小 $O(</td>
          <td>V</td>
          <td>^2)$，$O(1)$ 判断是否有边</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h2 id="breadth-first-search-bfs广度优先搜索">Breadth-First Search (BFS，广度优先搜索)</h2>

<h3 id="辅助数组">辅助数组</h3>

<p><img src="/assets/images/post/bfs1.png" alt="" /></p>

<h3 id="伪代码-17">伪代码</h3>

<p><img src="/assets/images/post/bfs2.png" alt="" /></p>

<p><img src="/assets/images/post/bfs3.png" alt="" /></p>

<h3 id="时间复杂度-6">时间复杂度</h3>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>V</td>
      <td>+</td>
      <td>E</td>
      <td>)$</td>
    </tr>
  </tbody>
</table>

<h2 id="depth-first-search-dfs深度优先搜索">Depth-First Search (DFS，深度优先搜索)</h2>

<h3 id="问题分析-1">问题分析</h3>

<p><img src="/assets/images/post/dfs1.png" alt="" /></p>

<h3 id="伪代码-18">伪代码</h3>

<p><img src="/assets/images/post/dfs2.png" alt="" /></p>

<p><img src="/assets/images/post/dfs3.png" alt="" /></p>

<h3 id="时间复杂度分析">时间复杂度分析</h3>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>V</td>
      <td>+</td>
      <td>E</td>
      <td>)$</td>
    </tr>
  </tbody>
</table>

<h3 id="深度优先树">深度优先树</h3>

<h4 id="深度优先树-1">深度优先树</h4>

<p>顶点以前驱为祖先形成的树</p>

<h4 id="树边">树边</h4>

<p>深度优先搜索树中的边</p>

<h4 id="后向边">后向边</h4>

<p>不是树边，但两顶点在深度优先树中是祖先后代关系</p>

<p><strong>对于无向图，非树边一定是后向边。</strong></p>

<p><strong>括号化定理</strong></p>

<ul>
  <li>点 $v$ 发现时刻和结束时刻构成区间 $[d[v], f[v]]$</li>
  <li>任意两点 $v,w$ 必须满足以下情况之一：
    <ul>
      <li>$[d[v],f[v]]$ 包含 $[d[w], f[w]]$，$w$ 是 $v$ 的后代</li>
      <li>$[d[w],f[w]]$ 包含 $[d[v],f[v]]$，$v$ 是 $w$ 的后代</li>
      <li>$[d[v],f[v]]$ 和 $[d[w],f[w]]$ 完全不重合 $v$ 和 $w$ 均不是对方的后代</li>
    </ul>
  </li>
</ul>

<p><strong>白色路径定理</strong></p>

<ul>
  <li>在深度优先树中，顶点 $v$ 是 $w$ 的祖先 $\Leftrightarrow$ 在 $v$ 被发现前，从 $v$ 到 $w$ 存在全为白色顶点构成的路径</li>
</ul>

<h4 id="前向边">前向边</h4>

<p>不再深度优先树种，从祖先指向后代的边</p>

<h4 id="横向边">横向边</h4>

<p>顶点不具有祖先后代关系的边</p>

<h2 id="cycle-detection-环路检测">Cycle Detection (环路检测)</h2>

<h3 id="问题定义-6">问题定义</h3>

<p><img src="/assets/images/post/cd1.png" alt="" /></p>

<h3 id="伪代码-19">伪代码</h3>

<p><img src="/assets/images/post/cd2.png" alt="" /></p>

<p><img src="/assets/images/post/cd3.png" alt="" /></p>

<h3 id="时间复杂度-7">时间复杂度</h3>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>V</td>
      <td>+</td>
      <td>E</td>
      <td>)$</td>
    </tr>
  </tbody>
</table>

<h2 id="topological-sort-拓扑排序">Topological Sort (拓扑排序)</h2>

<h3 id="问题定义-7">问题定义</h3>

<p><img src="/assets/images/post/tp1.png" alt="" /></p>

<h3 id="广度优先策略">广度优先策略</h3>

<h4 id="算法思想-1">算法思想</h4>

<ul>
  <li>完成入度为 0 点对应的事件</li>
  <li>删除完成事件，产生新的入度为 0 的点，继续完成</li>
</ul>

<h4 id="伪代码-20">伪代码</h4>

<p><img src="/assets/images/post/tp2.png" alt="" /></p>

<h4 id="事件复杂度">事件复杂度</h4>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>V</td>
      <td>+</td>
      <td>E</td>
      <td>)$</td>
    </tr>
  </tbody>
</table>

<h3 id="深度优先策略">深度优先策略</h3>

<h4 id="算法思想-2">算法思想</h4>

<p>DFS 搜索的完成时刻逆序即为拓扑排序顺序</p>

<h4 id="算法伪代码">算法伪代码</h4>

<p><img src="/assets/images/post/tp3.png" alt="" /></p>

<p><img src="/assets/images/post/tp4.png" alt="" /></p>

<h4 id="算法时间复杂度">算法时间复杂度</h4>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>V</td>
      <td>+</td>
      <td>E</td>
      <td>)$</td>
    </tr>
  </tbody>
</table>

<h2 id="strongly-connected-components-强连通分量">Strongly Connected Components (强连通分量)</h2>

<h3 id="问题定义-8">问题定义</h3>

<h4 id="强连通分量">强连通分量</h4>

<ul>
  <li>一个强连通分量是顶点的子集</li>
  <li>强连通分量种<strong>任意两点相互可达</strong></li>
  <li>满足<strong>最大性</strong>：加入新顶点，不保证相互可达</li>
</ul>

<p><img src="/assets/images/post/scc1.png" alt="" /></p>

<h4 id="gscc">$G^{SCC}$</h4>

<p>把强连通分量看作一个点得到的有向图</p>

<p><strong>$G^{SCC}$一定是有向无环图</strong></p>

<h4 id="scc_sink">$SCC_{Sink}$</h4>

<p>$G^{SCC}$ 中出度为 0 的点</p>

<ul>
  <li>$G^{SCC}$ 中存在至少一个 $SCC_{Sink}$</li>
  <li>删除 $SCC_{Sink}$，会产生新的 $SCC_{Sink}$</li>
</ul>

<h3 id="算法步骤">算法步骤</h3>

<ol>
  <li>把边反向，得到反向图 $G^R$</li>
  <li>在 $G^R$ 上执行 DFS，得到顶点完成时刻顺序 $L$</li>
  <li>在 $G$ 上按 $L$ 逆序执行 DFS，得到强连通分量</li>
</ol>

<h3 id="伪代码-21">伪代码</h3>

<p><img src="/assets/images/post/scc2.png" alt="" /></p>

<p><img src="/assets/images/post/scc3.png" alt="" /></p>

<h3 id="时间复杂度-8">时间复杂度</h3>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>V</td>
      <td>+</td>
      <td>E</td>
      <td>)$</td>
    </tr>
  </tbody>
</table>

<h2 id="minimum-spanning-trees-最小生成树">Minimum Spanning Trees (最小生成树)</h2>

<h3 id="问题背景">问题背景</h3>

<h4 id="子图-subgraph-2">子图 Subgraph</h4>

<p>如果 $V’\subseteq V$，$E’\subseteq E$，则称图 $G’=&lt;V’,E’&gt;$ 是图 $G$ 的一个子图</p>

<h4 id="生成子图-spanning-subgraph-1">生成子图 Spanning Subgraph</h4>

<p>如果 <strong>$\bold{V’= V}$</strong>，$E’\subseteq E$，则称图 $G’=&lt;V’,E’&gt;$ 是图 $G$ 的一个生成子图</p>

<h4 id="生成树-spanning-tree">生成树 Spanning Tree</h4>

<p>连通且无环的生成子图</p>

<h4 id="最小生成树">最小生成树</h4>

<p>权重最小的生成树</p>

<h4 id="安全边-safe-edge">安全边 Safe Edge</h4>

<ul>
  <li>$A$ 是某棵最小生成树 $T$ 边的子集，即 $A\subseteq T$</li>
  <li>$A\cup{(u,v)}$ 仍是 $T$ 边的一个子集，则称 $(u,v)$ 是 $A$ 的<strong>安全边</strong></li>
  <li>若每次向边集中新增安全边，可保证边集 $A$ 是最小生成树的子集</li>
</ul>

<h4 id="割-cut">割 Cut</h4>

<p>图 $G=&lt;V, E&gt;$ 是一个连通无向图，割 $(S, V-S)$ 将图 $G$ 的顶点集 $V$ 划分为两个部分</p>

<h4 id="横跨-cross">横跨 Cross</h4>

<p>给定割 $(S,V-S)$ 和边 $(u,v)$，$u\in S,v\in V-S$，称边 $(u,v)$ 横跨割 $(S,V-S)$</p>

<h4 id="轻边-light-edge">轻边 Light Edge</h4>

<p>横跨割的所有边中，权重最小的边称为横跨这个割的轻边</p>

<h4 id="不妨害-respect">不妨害 Respect</h4>

<p>如果一个边集 $A$ 中没有边横跨某割，则称该割不妨害边集 $A$</p>

<h4 id="安全边辨识定理">安全边辨识定理</h4>

<p><img src="/assets/images/post/safe.png" alt="" /></p>

<h3 id="问题定义-9">问题定义</h3>

<p><img src="/assets/images/post/st1.png" alt="" /></p>

<p><img src="/assets/images/post/com.png" alt="" /></p>

<h3 id="prim">Prim</h3>

<h4 id="算法思想-3">算法思想</h4>

<p><img src="/assets/images/post/prim.png" alt="" /></p>

<h4 id="辅助数组-1">辅助数组</h4>

<p><img src="/assets/images/post/prim2.png" alt="" /></p>

<h4 id="伪代码-22">伪代码</h4>

<p><img src="/assets/images/post/prim3.png" alt="" /></p>

<p><img src="/assets/images/post/prim4.png" alt="" /></p>

<h4 id="时间复杂度-9">时间复杂度</h4>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>V</td>
      <td>^2)$</td>
    </tr>
  </tbody>
</table>

<h3 id="优化-prim采用优先队列">优化 Prim–采用优先队列</h3>

<h4 id="伪代码-23">伪代码</h4>

<p><img src="/assets/images/post/prim5.png" alt="" /></p>

<p><img src="/assets/images/post/prim6.png" alt="" /></p>

<h4 id="时间复杂度-10">时间复杂度</h4>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>E</td>
      <td>\cdot \log{</td>
      <td>V</td>
      <td>})$</td>
    </tr>
  </tbody>
</table>

<h3 id="kruskal">Kruskal</h3>

<h4 id="算法思想-4">算法思想</h4>

<p><img src="/assets/images/post/k1.png" alt="" /></p>

<h4 id="伪代码-24">伪代码</h4>

<p><img src="/assets/images/post/k3.png" alt="" /></p>

<p><strong>高效判定和维护所选边的顶点是否在一棵子树</strong>——<strong>不相交集合</strong></p>

<p><img src="/assets/images/post/s1.png" alt="" /></p>

<p><img src="/assets/images/post/s2.png" alt="" /></p>

<p><img src="/assets/images/post/s3.png" alt="" /></p>

<h4 id="时间复杂度-11">时间复杂度</h4>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>E</td>
      <td>\log{</td>
      <td>V</td>
      <td>})$</td>
    </tr>
  </tbody>
</table>

<h2 id="single-source-shortest-path-单源最短路径">Single Source Shortest Path (单源最短路径)</h2>

<h3 id="问题定义-10">问题定义</h3>

<p><img src="/assets/images/post/ss1.png" alt="" /></p>

<h3 id="dijkstra">Dijkstra</h3>

<blockquote>
  <p>算法使用范围：边权为正的图</p>
</blockquote>

<h4 id="辅助数组-2">辅助数组</h4>

<p><img src="/assets/images/post/ss2.png" alt="" /></p>

<h4 id="算法思想-5">算法思想</h4>

<p><img src="/assets/images/post/ss3.png" alt="" /></p>

<p><img src="/assets/images/post/ss4.png" alt="" /></p>

<p><img src="/assets/images/post/ss5.png" alt="" /></p>

<h4 id="伪代码-25">伪代码</h4>

<p><img src="/assets/images/post/d1.png" alt="" /></p>

<p><img src="/assets/images/post/d2.png" alt="" /></p>

<h4 id="时间复杂度-12">时间复杂度</h4>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>V</td>
      <td>^2)$</td>
    </tr>
  </tbody>
</table>

<h3 id="用优先队列优化-dijkstra-算法">用优先队列优化 Dijkstra 算法</h3>

<h4 id="伪代码-26">伪代码</h4>

<p><img src="/assets/images/post/d3.png" alt="" /></p>

<p><img src="/assets/images/post/d4.png" alt="" /></p>

<h4 id="时间复杂度-13">时间复杂度</h4>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>E</td>
      <td>\cdot \log{</td>
      <td>V</td>
      <td>})$</td>
    </tr>
  </tbody>
</table>

<h3 id="bellman-ford">Bellman-Ford</h3>

<h4 id="问题背景-1">问题背景</h4>

<p>当图中存在<strong>负权边</strong>时，Dijkstra 算法不适用</p>

<h4 id="问题定义-11">问题定义</h4>

<p><img src="/assets/images/post/bf1.png" alt="" /></p>

<h4 id="算法思想-6">算法思想</h4>

<p><img src="/assets/images/post/bf2.png" alt="" /></p>

<h4 id="伪代码-27">伪代码</h4>

<p><img src="/assets/images/post/bf3.png" alt="" /></p>

<p><img src="/assets/images/post/bf4.png" alt="" /></p>

<h4 id="时间复杂度-14">时间复杂度</h4>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>E</td>
      <td>\cdot</td>
      <td>V</td>
      <td>)$</td>
    </tr>
  </tbody>
</table>

<h2 id="all-pairs-shortest-path-所有点对最短路径">All-Pairs Shortest Path (所有点对最短路径)</h2>

<h3 id="问题定义-12">问题定义</h3>

<p><img src="/assets/images/post/ap1.png" alt="" /></p>

<h3 id="问题分析-2">问题分析</h3>

<p>$D[k,i,j]$：可以从前 $k$ 个点选点经过时，$i$ 到 $j$ 的最短距离</p>

<h3 id="递推关系建立-5">递推关系建立</h3>

<p>$$
D[k,i,j]=\min
\left{
\begin{array}{l}
D[k-1,i,j]<br />
D[k-1,i,k]+D[k-1,k,j]
\end{array}
\right.
$$</p>

<h3 id="伪代码-28">伪代码</h3>

<p><img src="/assets/images/post/sp2.png" alt="" /></p>

<p><img src="/assets/images/post/ap3.png" alt="" /></p>

<h3 id="时间复杂度-15">时间复杂度</h3>

<table>
  <tbody>
    <tr>
      <td>$O(</td>
      <td>V</td>
      <td>^3)$</td>
    </tr>
  </tbody>
</table>

<h2 id="summary">Summary</h2>

<p><img src="/assets/images/post/short.png" alt="" /></p>

<h1 id="dealing-with-hard-problems">Dealing with Hard Problems</h1>

<h2 id="definition-2">Definition</h2>

<h3 id="input-size">Input Size</h3>

<p>The <strong>input size</strong> of a problem is the <strong>minimum number</strong> of bits ({0, 1}) needed to encode the input of the problem.</p>

<h3 id="decision-problem">Decision Problem</h3>

<p>A <strong>decision problem</strong> is a question that has two possible answers: <strong>yes</strong> and <strong>no</strong>.</p>

<blockquote>
  <p>If $L$ is the problem and $x$ is the input, we often write $x\in L$ to denote a <strong>yes</strong> and $x\not\in L$ to denote a <strong>no</strong> answer.</p>
</blockquote>

<h3 id="optimization-problem">Optimization Problem</h3>

<p>An <strong>optimization problem</strong> requires an answer that is an optimal configuration.</p>

<blockquote>
  <p>An optimization problem usually has a corresponding decision problem.</p>

  <p>For almost all optimization problems there exists a corresponding simpler decision problem.</p>

  <p>Thus if we prove that a given problem is hard to solve efficiently, then it is obvious that the optimization problem must be (at least as) hard.</p>
</blockquote>

<h3 id="yes--no-input">Yes / No Input</h3>

<p>An instance of a decision problem is called a <strong>yes-input</strong> (respectively no-input) if the answer to the instance is <strong>yes</strong> (respectively no).</p>

<h3 id="polynomial-time">Polynomial-time</h3>

<p>An algorithm is <strong>polynomial-time</strong> if its running time is $O(n^k)$, where $k$ is a constant independent of n, and n is the <strong>input-size</strong> of the problem that the algorithm solves.</p>

<blockquote>
  <p>Whether you use $n$ or $n^\alpha$ (for fixed a &gt; 0) as the input size, it will not affect the conclusion of whether an algorithm is polynomial time.</p>

  <p>Polynomial-time algorithm is “practical” and exponential-time algorithm is not.</p>
</blockquote>

<h3 id="p">P</h3>

<p>The class <strong>P</strong> consists of all <strong>decision problems</strong> that are solvable in <strong>polynomial time</strong>. That is, there exists an algorithm that will <strong>decide</strong> in polynomial time if any given input is a yes-input or a no-input.</p>

<h3 id="certificate">Certificate</h3>

<p>A <strong>certificate</strong> is a specific object corresponding to a <strong>yes-input</strong>, such that it can be used to show that the input is <strong>indeed</strong> a yes-input.</p>

<h3 id="np">NP</h3>

<p>The class <strong>NP</strong> consists of all <strong>decision problems</strong> such that, for each yes-input, there exists a <strong>certificate</strong> which allows one to verify in <strong>polynomial time</strong> that the input is indeed a yes input.</p>

<h3 id="polynomial-time-reducible">Polynomial-time reducible</h3>

<ul>
  <li>
    <p>Let $L_1$ and $L_2$ be two decision problems.</p>
  </li>
  <li>
    <p>A <strong>polynomial-time reduction</strong> from $L_1$ to $L_2$ is a transformation $f$ with the following two properties:</p>

    <ol>
      <li>$f$ transforms an input x for $L_1$ into an input $f(x)$ for $L_2$ such that: a yes-input of $L_1$ maps to a yes-input of $L_2$, and a no-input of $L_1$ maps to a no-input of $L_2$.</li>
      <li>$f(x)$ is computable in <strong>polynomial time</strong> (in size (x))</li>
    </ol>

    <p>If such $f$ exists, we say that $L_1$ is <strong>polynomial-time reducible</strong> to $L_2$, and write $L_1\le pL_2$</p>
  </li>
</ul>

<blockquote>
  <p>If $L_2$ is polynomial-time algorithm, so is $L_1$</p>
</blockquote>

<h3 id="np-complete-npc">NP-Complete (NPC)</h3>

<p>The class <strong>NPC</strong> of <strong>NP-Complete</strong> problems consists of all decision problems $L$ such that</p>

<ul>
  <li>$L\in NP$</li>
  <li>for every $L’\in NP$, $L’\le pL$</li>
</ul>

<p>Intuitively, NPC consists of all the hardest problems in NP.</p>

<h3 id="np-hard">NP-Hard</h3>

<p>A problem $L$ is <strong>NP-Hard</strong> if problem in NPC can be <strong>polynomially reduced</strong> to it. (but $L$ does <strong>not</strong> need to be in NP)</p>

<h2 id="theorem">Theorem</h2>

<ol>
  <li>If $L_1\le p L_2$ and $L_2\in P$, then $L_1\in P$</li>
  <li>If $L_1\le p L_2$ and $L_2\le p L_3$, then $L_1\le p L_3$</li>
  <li>If <strong>there is</strong> a polynomial-time algorithm for $L\in NPC$, then there is a polynomial-time algorithm for <strong>every</strong> $L’\in NP$</li>
  <li>If <strong>there is no</strong> polynomial-time algorithm for $L\in NPC$, then there is  no polynomial-time algorithm for <strong>every</strong> $L’\in NPC$</li>
</ol>

<h2 id="example">Example</h2>

<h3 id="p-1">P</h3>

<ul>
  <li>判断给定图是否为树</li>
  <li>DFS, BFS</li>
  <li>DMST，最小生成树决策类</li>
  <li>2-SAT</li>
</ul>

<h3 id="np-1">NP</h3>

<ul>
  <li>D-SubsetSum</li>
  <li>DVC (Decision Vertex Cover)</li>
  <li>SAT (Satisfiability)</li>
  <li>3-SAT</li>
  <li>DMST</li>
  <li>DKnapsack</li>
</ul>

<h3 id="np-complete">NP-Complete</h3>

<p>Knapsack</p>

<p>NPC</p>

<p>DCLIQUE</p>

<p>Decision Vertex Cover</p>

<p>Decision Independent Set</p>

<h2 id="question">Question</h2>

<table>
  <thead>
    <tr>
      <th>Question</th>
      <th>Answer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$P\subseteq NP $</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>$NP\subseteq P$</td>
      <td>unknown</td>
    </tr>
    <tr>
      <td>$NPC\subseteq NP $</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>$P=NP $</td>
      <td>unknown</td>
    </tr>
  </tbody>
</table>]]></content><author><name>ericaaaaaaaa</name></author><category term="Algorithms" /><category term="note" /><category term="algorithm" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Database</title><link href="http://localhost:4000/data/2022/01/07/Database.html" rel="alternate" type="text/html" title="Database" /><published>2022-01-07T00:00:00+08:00</published><updated>2022-01-07T00:00:00+08:00</updated><id>http://localhost:4000/data/2022/01/07/Database</id><content type="html" xml:base="http://localhost:4000/data/2022/01/07/Database.html"><![CDATA[<center><b><font size="6">数据库系统原理</font></b></center>

<p>[toc]</p>

<h1 id="第一篇-基础篇">第一篇 基础篇</h1>

<h2 id="第-1-章-绪论">第 1 章 绪论</h2>

<h3 id="11-数据库系统概述">1.1 数据库系统概述</h3>

<h4 id="111-数据库的四个基本概念">1.1.1 数据库的四个基本概念</h4>

<h5 id="数据-data">数据 (data)</h5>

<h6 id="数据">数据</h6>

<p><strong>数据</strong>是描述现实世界各种事物的可以识别的符号。数据的含义称为数据的语义，数据与其语义是不可分的。</p>

<h6 id="信息">信息</h6>

<p><strong>信息</strong>是一种已经被加工为特定形式的数据，这些数据对现在与将来的决策有明显价值。</p>

<p>信息是各种数据所包括的意义；数据是信息的载体，是信息的具体表现形式。</p>

<h6 id="数据处理">数据处理</h6>

<p>从大量原始数据中抽取和推导出有价值信息的加工过程称为<strong>数据处理</strong>，包括：数据收集、组织、存储、加工、分类、检索、输出、传输等操作。</p>

<h6 id="数据管理">数据管理</h6>

<p>数据处理一般性的基本操作，如数据分类、组织、存储、检索、维护等成为数据管理，并研究专门的技术——<strong>数据管理技术</strong>。</p>

<h5 id="数据库-database-db">数据库 (DataBase, DB)</h5>

<h6 id="数据库">数据库</h6>

<p>数据库是<strong>长期存储</strong>在计算机内的，<strong>有组织</strong>的，<strong>可共享</strong>的大量数据的集合。</p>

<p>数据库按照一定的数据模型组织，描述和储存，具有较小的<strong>冗余度</strong>(redundancy)、较高的<strong>数据独立性</strong>(data independency) 和<strong>易扩展性</strong>(scalability)，并可为各种用户<strong>共享</strong>。</p>

<h6 id="数据库技术">数据库技术</h6>

<ul>
  <li>是一种数据管理技术</li>
  <li>按照某种数据结构对数据进行组织后，存储在计算机的二级存储中，并可以提供数据共享工作。</li>
</ul>

<h6 id="数据库系统">数据库系统</h6>

<p><strong>数据库系统</strong>是基于数据库管理系统建立的具有特定数据处理功能的系统。</p>

<h5 id="数据库管理系统-database-management-system-dbms">数据库管理系统 (DataBase Management System, DBMS)</h5>

<p>数据库管理系统是位于用户和操作系统之间的一层数据库管理软件。</p>

<p>特点：</p>

<ul>
  <li>数据的最小存取单位是数据项</li>
</ul>

<p>它的功能有：</p>

<ul>
  <li>数据定义功能
    <ul>
      <li>提供数据定义语言 (Data Definition Language, DDL)、</li>
    </ul>
  </li>
  <li>
    <p>数据组织、存储和管理</p>
  </li>
  <li>数据操纵功能
    <ul>
      <li>提供数据操纵语言 (Data Manipulation Language, DML)</li>
    </ul>
  </li>
  <li>
    <p>数据库的事务管理和运行管理</p>
  </li>
  <li>
    <p>数据库的建立和维护</p>
  </li>
  <li>
    <p>统一的数据控制功能</p>

    <ul>
      <li>
        <p>数据的安全性控制</p>

        <ul>
          <li>保护数据以防止不合法的使用所造成的数据的泄密和破坏</li>
        </ul>
      </li>
      <li>
        <p>数据的完整性控制</p>

        <p>指数据的正确性与相容性</p>
      </li>
      <li>
        <p>数据的并发控制</p>

        <ul>
          <li>对多用户的并发操作进行控制，协调，保护数据的完整性</li>
        </ul>
      </li>
      <li>
        <p>数据库恢复</p>

        <ul>
          <li>将数据库从错误状态恢复到某一已知的正确状态</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>其他功能</li>
</ul>

<h5 id="数据库系统-database-system-dbs">数据库系统 (DataBase System, DBS)</h5>

<p>数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator, DBA）组成的存储、管理、处理和维护数据的系统。</p>

<h4 id="112-数据管理技术的产生和发展">1.1.2 数据管理技术的产生和发展</h4>

<table>
  <thead>
    <tr>
      <th>阶段</th>
      <th>数据管理者</th>
      <th>数据保存</th>
      <th>数据共享程度</th>
      <th>数据独立性</th>
      <th>数据结构化</th>
      <th>数据控制能力</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>人工管理阶段</td>
      <td>用户（程序员）</td>
      <td>不保存</td>
      <td>无共享，冗余度极大</td>
      <td>不独立，完全依赖于程序</td>
      <td>无结构</td>
      <td>应用程序自己控制</td>
    </tr>
    <tr>
      <td>文件系统阶段</td>
      <td>文件系统</td>
      <td>可以长期保存</td>
      <td>共享性差，冗余度大</td>
      <td>独立性差</td>
      <td>记录内有结构，整体无结构</td>
      <td> </td>
    </tr>
    <tr>
      <td>数据库系统阶段</td>
      <td>数据库管理系统</td>
      <td>可以长期大量保存</td>
      <td>共享性高，冗余度小</td>
      <td>具有高度的物理独立性和一定的逻辑独立性</td>
      <td>整体结构化，由数据模型描述</td>
      <td>由数据库管理系统提供数据安全性、完整性、并发控制和恢复能力</td>
    </tr>
  </tbody>
</table>

<h4 id="113-数据库系统的特点">1.1.3 数据库系统的特点</h4>

<ol>
  <li>
    <p>数据结构化</p>

    <blockquote>
      <p>数据库的结构化是数据库的<em>主要特征</em>之一，也是<em>数据库和文件系统的</em><strong><em>本质区别</em></strong>。</p>
    </blockquote>

    <p>数据内部结构化，整体结构化，<strong>数据之间有联系</strong></p>
  </li>
  <li>
    <p>数据共享性高，冗余度低且易扩充</p>

    <p>数据共享可以大大减少数据冗余，节约存储空间，能避免数据之间的不相容性与不一致性，使得数据库系统弹性大，易扩充。</p>
  </li>
  <li>
    <p>数据独立性高</p>

    <blockquote>
      <p>减少应用程序的维护和修改</p>
    </blockquote>

    <ul>
      <li><strong>物理独立性</strong>是指用户的应用程序与数据库中数据的物理存储是相互独立的。（数据的存储结构（物理结构）改变时，数据的逻辑结构可以不变，从而应用程序也不必改变）</li>
      <li><strong>逻辑独立性</strong>是指用户的应用程序与数据库的逻辑结构是相互独立的（数据的逻辑结构改版时，应用程序可以不变）</li>
    </ul>
  </li>
  <li>
    <p>数据由数据库管理系统统一管理和控制</p>
    <ol>
      <li>
        <p>数据的安全性 (security) 保护</p>

        <p>数据的安全性是指保护数据以放置不合法使用造成的数据泄密和破坏</p>
      </li>
      <li>
        <p>数据的完整性 (integrity) 检查</p>

        <p>数据的完整性是指数据的<strong>正确性</strong>（和客观世界相一致）、<strong>有效性</strong>和<strong>相容性</strong>（同一个数据在不同位置内容一致）</p>
      </li>
      <li>
        <p>并发 (concurrency) 控制</p>

        <p>对多个用户的并发操作进行控制，协调，保护数据的完整性</p>
      </li>
      <li>
        <p>数据库恢复 (recovery)</p>

        <p>将数据库从错误状态恢复到某一已知的正确状态</p>
      </li>
      <li>
        <p>数据的最小存取单位是数据项</p>

        <p>既可以存取一个或一组记录，也可以存取数据库中某个或某一组数据项</p>
      </li>
    </ol>
  </li>
</ol>

<h3 id="12-数据模型">1.2 数据模型</h3>

<p>数据模型 (data model) 是对现实世界数据特征的抽象，是数据库的核心和基础。</p>

<p>将<em>现实世界</em>抽象为<em>信息世界</em>（概念模型），再将信息世界转换为<em>机器世界</em>（数据模型）。</p>

<h4 id="概念模型信息模型">概念模型（信息模型）</h4>

<p>用于信息世界建模，是现实世界到信息世界的抽象描述用户和数据库设计人员进行交流的语言。</p>

<ol>
  <li>
    <p>信息世界中的基本概念</p>

    <ol>
      <li>
        <p><strong>实体</strong> (entity)</p>

        <p>客观存在并可相互区别的事物称为实体。</p>
      </li>
      <li>
        <p><strong>属性</strong> (attribute)</p>

        <p>实体所具有的某一特性。</p>
      </li>
      <li>
        <p><strong>码</strong> (key)</p>

        <p>唯一标识实体的属性集。</p>
      </li>
      <li>
        <p><strong>实体型</strong> (entity type)</p>

        <p>用实体名及其属性名集合来抽象刻画同类实体，称为实体型</p>
      </li>
      <li>
        <p><strong>实体集</strong> (entity set)</p>

        <p>同一类型的实体的集合。</p>
      </li>
      <li>
        <p><strong>联系</strong> (relationship)</p>

        <p>实体型之间的联系，是实体之间的相互关联</p>
        <ul>
          <li>名称</li>
          <li><strong>类型</strong>
            <ul>
              <li>一对一 (1 : 1)</li>
              <li>一对多 (1 : n)</li>
              <li>多对多 (m : n)</li>
            </ul>
          </li>
          <li>（属性）</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>概念模型是一种表示方法，实体–联系方法 (E-R 法)</p>

    <blockquote>
      <p>E-R 法(Entity-Relation Approach)：用 E-R 图描述现实世界的信息，这种信息结构称为概念结构</p>
      <ul>
        <li>用 E-R 图描述现实世界</li>
        <li>将 E-R 图转换成相应的数据模型</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p><strong>E-R 图</strong></p>

    <ul>
      <li>组成
        <ul>
          <li><strong>实体</strong>：用<strong>长方形</strong>表示实体型，再框内写上实体名</li>
          <li><strong>属性</strong>：用<strong>椭圆形</strong>表示实体的属性，并用无向边吧实体与其属性连接起来
            <ul>
              <li>在无向边上打 ‘=’ 表示属性为实体的码</li>
              <li>在连接多条无向边的弧线上打 ‘=’ 表示这些属性共同组成实体的码</li>
            </ul>
          </li>
          <li><strong>联系</strong>：用<strong>菱形</strong>表示实体间的联系，菱形框内写上联系名。用无向边把菱形分别与有关实体相连，在边上标明连接的类型</li>
        </ul>
      </li>
      <li>实体之间联系的语义补充
        <ul>
          <li>存在依赖</li>
          <li>标识依赖</li>
          <li>实体的子类</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h4 id="数据模型层次网状关系模型">数据模型（层次、网状、关系模型）</h4>

<p>用于机器世界，按计算机系统的观点对数据进行建模。</p>

<h5 id="数据模型的三要素">数据模型的<strong>三要素</strong></h5>

<ol>
  <li>
    <p><strong>数据结构</strong></p>

    <ul>
      <li>描述数据库的组成对象以及对象之间的联系
        <ul>
          <li>描述<strong>对象</strong>的类型、内容、性质的概念，如关系模型中的域，属性等</li>
          <li>描述<strong>对象之间联系</strong>的概念，如关系模型中的关系</li>
        </ul>
      </li>
      <li>是数据模型<strong>静态特性</strong>的描述</li>
      <li>是刻画<em>数据模型</em>最重要的方面</li>
    </ul>
  </li>
  <li>
    <p><strong>数据操作</strong></p>

    <ul>
      <li>对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。
     * 是数据模型<strong>动态特性</strong>的描述</li>
      <li>类型：检索、更新（插、删、改）</li>
    </ul>
  </li>
  <li>
    <p><strong>数据的完整性约束条件</strong></p>

    <p>数据的完整性约束条件是一组完整性规则</p>

    <blockquote>
      <p><strong>完整性规则</strong>：给定的数据模型中数据及其联系所有的制约和依存规则，用以保证数据的正确、相容。
完整性约束条件包括：</p>
      <ul>
        <li>符合这种数据模型所必须遵守的基本的通用的完整性约束条件</li>
        <li>针对具体数据的特定语义约束条件</li>
      </ul>
    </blockquote>
  </li>
</ol>

<h5 id="数据模型的分类">数据模型的<strong>分类</strong></h5>

<ol>
  <li>
    <p><strong>层次模型</strong></p>

    <blockquote>
      <p>用<strong>树结构</strong>表示数据之间的联系，节点代表实体型，连线表示两实体型间的一对多联系。</p>
    </blockquote>

    <ul>
      <li>优点
        <ul>
          <li>结构简单</li>
          <li>易于实现</li>
        </ul>
      </li>
      <li>缺点
        <ul>
          <li>支持联系种类少（只能直接表示二元一对多练习）</li>
          <li>数据操纵不便，子结点存取只能通过父节点来进行</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>网状模型</strong></p>

    <blockquote>
      <p>用<strong>图结构</strong>表示数据之间的联系，节点代表实体型，连线表示两实体型间的一对多联系。</p>
    </blockquote>

    <ul>
      <li>特点
        <ul>
          <li>表达联系种类丰富</li>
          <li>结构复杂</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>关系模型</strong></p>

    <blockquote>
      <p>用<strong>二维表</strong>表示数据之间的联系</p>
    </blockquote>

    <ul>
      <li>特点
        <ul>
          <li>用关系描述实体及实体间的联系（这种描述一致性使数据结构大大简化，概念简单）</li>
          <li>可直接表示多对多联系</li>
          <li>关系必须是规范化关系，即每个分量是不可分的数据项。或不许再表中套表</li>
          <li>建立在数学概念基础上，理论基础强</li>
        </ul>
      </li>
      <li>
        <p>语义约束</p>

        <ul>
          <li>
            <p>实体完整性 （Entity Integrity）</p>

            <ul>
              <li>
                <p>要有属性或属性组合作为主码，主码值不可位空或部分为空。或定义为若属性 A 是关系 R 的主属性，则属性 A 不能取空值。</p>

                <blockquote>
                  <p>空值的含义是：不知道或不存在的值</p>
                </blockquote>
              </li>
            </ul>
          </li>
          <li>
            <p>参照完整性 （Referential Integrity）</p>

            <ul>
              <li>外部码</li>
              <li>参照完整性</li>
            </ul>
          </li>
          <li>
            <p>用户定义完整性</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="13-数据库系统的结构">1.3 数据库系统的结构</h3>

<p>三级模式、两级映像</p>

<h4 id="数据库的两级映像">数据库的两级映像</h4>

<ul>
  <li>数据的存储结构与逻辑结构之间的映像——实现数据的<strong>物理独立性</strong></li>
  <li>数据的全局逻辑结构与某类应用所涉及的局部逻辑结构的映像——实现数据的<strong>逻辑独立性</strong></li>
</ul>

<h4 id="数据库系统的三级模式结构">数据库系统的三级模式结构</h4>

<p><img src="/assets/images/post/mode.png" alt="" /></p>

<ol>
  <li>
    <p><strong>模式</strong> (schema)</p>

    <p>模式也称为逻辑模式，是数据库中<em>全体数据的逻辑结构和特性的描述</em>。是所有用户的公共数据视图。</p>

    <p>三级模式的核心。</p>

    <p>模式描述语言（Data Description Language, DDL）</p>
  </li>
  <li>
    <p><strong>外模式</strong> (external schema)</p>

    <p>也称为子模式或用户模式。是个别用户的数据视图，即<em>与某一应用有关的数据的逻辑表示</em>。</p>

    <p>外模式 DDL</p>
  </li>
  <li>
    <p><strong>内模式</strong> (internal schema)</p>

    <p>也称为存储模式，是数据在数据库系统内部的表示，即对<em>数据的物理结构和存储方式的描述</em>。</p>

    <p>内模式 DDL</p>
  </li>
</ol>

<ul>
  <li>优点
    <ul>
      <li>保证数据的独立性:
        <ul>
          <li>模式与内模式分开–数据物理独立性</li>
          <li>模式与外模式分开–数据逻辑独立性</li>
        </ul>
      </li>
      <li>简化用户接口, 方便用户使用</li>
      <li>有利于数据共享</li>
      <li>有利于数据的安全保密</li>
    </ul>
  </li>
  <li>缺点</li>
</ul>

<h3 id="14-数据库系统的组成">1.4 数据库系统的组成</h3>

<h4 id="dbms-的主要功能">DBMS 的主要功能</h4>

<ul>
  <li>数据库定义功能
    <ul>
      <li>利用 DDL 语言描述外模式, 模式, 内模式(源模式)</li>
      <li>模式翻译程序把内模式翻译哼目标模式</li>
    </ul>
  </li>
  <li>数据存取功能
    <ul>
      <li>提供 DML(Data Manipulation Language) 语言对数据库进行检索, 插入, 修改, 删除</li>
    </ul>
  </li>
  <li>数据库运行管理
    <ul>
      <li>并发控制, 存取控制, 完整性约束检查, 日志管理……</li>
    </ul>
  </li>
  <li>数据组织, 存储和管理</li>
  <li>数据库的建立和维护</li>
</ul>

<h4 id="dbms-的组成">DBMS 的组成</h4>

<ul>
  <li>语言编译处理程序</li>
  <li>系统运行控制程序</li>
  <li>系统建立和维护程序</li>
  <li>数据字典</li>
</ul>

<h4 id="dba">DBA</h4>

<ul>
  <li>建库</li>
  <li>用库</li>
  <li>改进</li>
</ul>

<h2 id="第二章-关系数据库">第二章 关系数据库</h2>

<h3 id="21-关系数据结构及形式化定义">2.1 关系数据结构及形式化定义</h3>

<h4 id="211-关系">2.1.1 关系</h4>

<ol>
  <li>
    <p><strong>域</strong>(domain)</p>

    <p>域是一组具有相同数据类型的值的集合.</p>
  </li>
  <li>
    <p><strong>笛卡尔积</strong>(cartesian product)</p>

    <table>
      <tbody>
        <tr>
          <td>$D_1\times D_2\times … \times D_n={(d_1, d_2, …, d_n)</td>
          <td>d_i\in D_i, i = 1,2,..,n}$</td>
        </tr>
      </tbody>
    </table>

    <ol>
      <li><strong>元组</strong>(n-tuple)
$(d_1, d_2, …, d_n)$ n 元组</li>
      <li><strong>分量</strong>(component)
元组的每一个值 $d_i$</li>
      <li>
        <p><strong>基数</strong>(cardinal number)
一个域允许的不同取值个数称为这个域的基数</p>

        <p>笛卡尔积的基数 = $\prod_{i=1}^{n}m_i$</p>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>关系</strong>(relation)</p>
    <ul>
      <li><strong>关系</strong>
 $D_1\times D_2\times … \times D_n$ 的子集叫做在域 $D_1, D_2, …, D_n$ 上的关系, 用 $R(D_1, D_2,…, D_n)$ 表示, n 是关系的<strong>目(度, degree)</strong>
        <ul>
          <li>单元关系(unary relation)</li>
          <li>二元关系(binary relation)</li>
          <li>属性(attribute): 关系二维表每个列附加的名称</li>
          <li>候选码(candidate key): 能唯一标识一个元组的属性<strong>组</strong></li>
          <li>主码(primary key): 在候选码中选择一个为主码</li>
          <li>主属性(prime attribute): 候选码的各个属性</li>
          <li>非主属性(non-prime attribute)
    * <strong>基本关系的性质</strong></li>
        </ul>
      </li>
      <li>列的同质(Homogeneous)的，即每一列中的分量来自同一域，是同一类型的数据。</li>
      <li>不同列可出自同一域, 每列必须有不同的属性名</li>
      <li>列的顺序无所谓, 即列的次序可以呼唤</li>
      <li>任意两个元组不能完全相同</li>
      <li>行的顺序无所谓, 即行的次序可以呼唤</li>
      <li>每一分量必须是不可再分的数据, 满足这一条件的关系称作满足第一范式 (1NF, Normal Form) 的</li>
    </ul>
  </li>
</ol>

<h4 id="关系模式">关系模式</h4>

<p>关系的描述称为<strong>关系模式</strong>(relation schema), 它可以形式化表示为: $R(U, D, DOM, F, I)$</p>
<ul>
  <li>R–关系名</li>
  <li>U–组成该关系的属性名集合</li>
  <li>D–U 中属性来自的域</li>
  <li>DOM–属性向域的映像集合</li>
  <li>F–属性间数据的依赖关系集合</li>
  <li>I–完整性约束集合</li>
</ul>

<h3 id="22-关系操作">2.2 关系操作</h3>

<h3 id="23-关系的完整性">2.3 关系的完整性</h3>

<h4 id="231-实体完整性">2.3.1 实体完整性</h4>

<ul>
  <li>要有属性或属性组合作为主码, 主码值不可为空或部分为空。或定义为若属性A是关系R的主属性，则属性 A 不能取空值。</li>
  <li>空值的含义是：不知道或不存在的值。</li>
</ul>

<h4 id="232-参照完整性">2.3.2 参照完整性</h4>

<ul>
  <li>外部码
    <ul>
      <li>设 F 是基本关系 R 的一个或一组属性，但不是 R 的码。如果 F 与基本关系 S 的主码 Ks 相对应，则称 F 是关系 R 的外部码（Foreign Key），并称 R 为参照关系（Referencing Relation），S 为被参照关系（Referenced Relation）或目标关系（Target Relation）。R 和 S 不一定是不同的关系。</li>
      <li>目标关系 S 的主码 Ks 和参照关系的外部码 F 必须定义在一个域上。</li>
    </ul>
  </li>
  <li>参照完整性
    <ul>
      <li>如果关系R的外部码 Fk 与关系 S 的主码 Pk 相对应，则R中的每一个元组的 Fk 值或者等于 S 中某个元组的 Pk 值，或者为空值。</li>
    </ul>
  </li>
</ul>

<h4 id="233-用户定义完整性">2.3.3 用户定义完整性</h4>

<p>用户定义完整性反映了某一具体应用所涉及的数据必须满足的语义要求。</p>

<h2 id="24-关系代数">2.4 关系代数</h2>

<ul>
  <li>从数学角度，<strong>基本</strong>关系代数运算有 5 种：<strong>并、差、乘、选择、投影</strong></li>
  <li>从数据库角度，<strong>核心</strong>的关系代数运算为：<strong>选择、投影、连接（或自然连接）</strong></li>
</ul>

<h3 id="关系模型的数据操作">关系模型的数据操作</h3>

<p>关系数据操作的基础是”关系运算“。关系运算的方式有两种：代数方式，逻辑方式。</p>

<p><img src="/assets/images/post/type.png" alt="" /></p>

<h3 id="关系代数">关系代数</h3>

<p>关系代数是一种抽象的查询语言 ，它用对关系的运算来表达查询。</p>

<ul>
  <li>
    <p>运算对象</p>

    <ul>
      <li>关系</li>
    </ul>
  </li>
  <li>
    <p>运算结果</p>

    <ul>
      <li>关系</li>
    </ul>
  </li>
  <li>
    <p>运算符</p>

    <ul>
      <li>集合运算符
        <ul>
          <li>$\cup$ 并</li>
          <li>$\cap$ 交</li>
          <li>-   差</li>
          <li>$\times$ 笛卡尔积</li>
        </ul>
      </li>
      <li>专门关系运算符
        <ul>
          <li>$\sigma$ 选择</li>
          <li>$\prod$ 投影</li>
          <li>$\Join$ 连接</li>
          <li>$\div$  除</li>
        </ul>
      </li>
    </ul>

    <h3 id="241-传统的集合运算">2.4.1 传统的集合运算</h3>

    <p>传统的集合运算是<strong>二目运算</strong></p>

    <ol>
      <li>
        <p><strong>并</strong> (union)</p>

        <table>
          <tbody>
            <tr>
              <td>$R\cup S={t</td>
              <td>t\in R\vee t\in S}$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <p><strong>差</strong> (except)</p>

        <table>
          <tbody>
            <tr>
              <td>$R-S={t</td>
              <td>t\in R\wedge t\not\in S}$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <p><strong>交</strong> (intersection)</p>

        <p>$R\cap S={t\in R\wedge t\in S}$</p>
      </li>
      <li>
        <p><strong>笛卡尔积</strong> (cartesian product)</p>

        <table>
          <tbody>
            <tr>
              <td>$R\times S={t_r t_s</td>
              <td>t_r\in R\wedge t_s\in S}$</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ol>
  </li>
</ul>

<h3 id="242-专门的关系运算">2.4.2 专门的关系运算</h3>

<blockquote>
  <p>引入记号</p>

  <ol>
    <li><strong>关系模式</strong> $R(A_1, A_2, …,A_n)$，它的一个<strong>关系</strong>为 $R$，$t\in R$ 表示 $t$ 是 $R$ 的一个<strong>元组</strong>。$t[A_i]$ 则表示元组 $t$ 中相应于属性 $A_i$ 的一个分量。</li>
    <li>若 $A={A_{i1},A_{i2},…,A_{ik}}$，其中 $A_{i1},A_{i2},…,A_{ik}$ 是 $A_1, A_2, …,A_n$  中的一部分，则称 $A$ 为<strong>属性列</strong>或<strong>属性组</strong>。$t[A]=(t[A_{i1}],t[A_{i2}],…,t[A_{ik}])$ 表示元组 $t$ 在属性列 $A$ 上诸分量的集合，$\overline{A}$ 则表示 ${A_{1},A_{2},…,A_{n}}$ 中去掉 ${A_{i1},A_{i2},…,A_{ik}}$ 后剩余的属性组。</li>
    <li>$R$ 为 $n$ 目关系，$S$ 为 $m$ 目关系，$t_r\in R$，$t_s\in S$，$t_rt_s$ 称为元组的<strong>连接</strong> (concatenation)  或元组的<strong>串接</strong>。它是一个 $n+m$ 列数组。</li>
    <li>
      <table>
        <tbody>
          <tr>
            <td>给定一个关系 $R(X,Z)$，$X$ 和 $Z$ 为属性组，当 $t[X=x]$ 时，$x$ 在 $R$ 中的象集 (images set) 定义为：$Z_x={t[Z]</td>
            <td>t\in R,t[X]=x}$，它表示 $R$ 中属性组 $X$ 上值为 $x$ 的诸元组在 $Z$ 上分量的集合。</td>
          </tr>
        </tbody>
      </table>
    </li>
  </ol>
</blockquote>

<ol>
  <li>
    <p><strong>选择</strong> (selection)</p>

    <p>选择又称为<strong>限制</strong> (restriction)。</p>

    <p>$\sigma_F(R)={t\in R\wedge F(t)=’真’}$</p>
  </li>
  <li>
    <p><strong>投影</strong> (projection)</p>

    <p>关系 $R$ 上的投影是从 $R$ 中选择出若干属性列组成新的关系</p>

    <table>
      <tbody>
        <tr>
          <td>$\prod_Z(R)={t[A]</td>
          <td>t\in R}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p><strong>连接</strong> (join)</p>

    <p>连接也称为 $\theta$ 连接。它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组</p>

    <table>
      <tbody>
        <tr>
          <td>$R\underset{A\theta B}{\Join}S={t_rt_s</td>
          <td>t_r\in R\wedge t_s\in S\wedge t_r[A]\theta t_s[B]}$</td>
        </tr>
      </tbody>
    </table>

    <p>其中，$A$ 和 $B$ 分别为 $R$ 和 $S$ 上列数相等且可比的属性组，$\theta$ 是比较运算符。连接运算从 $R$ 和 $S$ 的笛卡尔积 $R\times S$ 中选取 $R$ 关系在 $A$ 属性组上与 $S$ 关系在 $B$ 属性组上的值满足比较关系 $\theta$ 的元组</p>

    <ul>
      <li>
        <p><strong>等值连接</strong></p>

        <p>$\theta$ 为 “=” 的连接运算称为等值连接。</p>
      </li>
      <li>
        <p><strong>自然连接</strong></p>

        <p>自然连接要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉</p>

        <p>在自然连接中被舍弃的元组称为<strong>悬浮元组</strong> (dangling tuple)</p>
      </li>
      <li>
        <p><strong>外连接</strong> (outer join)</p>

        <p>把悬浮元组也保存在结果关系中，而在其它属性上填空值 (NULL)</p>

        <ul>
          <li>
            <p><strong>左外连接</strong> (left outer join)</p>

            <p>只保留左边关系 $R$ 中的悬浮元组</p>
          </li>
          <li>
            <p><strong>右外连接</strong> (right outer join)</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>除运算</strong> (division)</p>

    <p>设关系 $R$ 除以关系 $S$ 的结果为关系 $T$，则 $T$ 包含<em>所有在 $R$ 但不在 $S$ 中的属性及其值</em>，且 $T$ 中的元组与 $S$ 中的元组的所有组合都在 $R$ 中</p>

    <table>
      <tbody>
        <tr>
          <td>$R\div S={t_r[X]</td>
          <td>t_r\in R\wedge \prod_Y(S)\subseteq Y_x}$，其中 $Y_x$ 是 $x$ 在 $R$ 中的象集</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h3 id="关系运算的安全性约束">关系运算的安全性约束</h3>

<ul>
  <li>关系运算种把不产生无限关系和无穷验证的运算称为<strong>安全运算</strong>；其运算表达式称为<strong>安全表达式</strong>，对其所采用的限制称为<strong>安全约束</strong>。</li>
  <li>关系代数是安全运算，关系演算则不一定是，所以对关系演算要进行安全约束
    <ul>
      <li>在关系演算中，通常采用的安全约束方法是对 $\Phi$ 定义一个有限的符号集 DOM($\Phi$)，使 $\Phi$ 的运算结果及中间结果所产生的关系及其元组的各个分量都必须属于 DOM($\Phi$)</li>
      <li>设 $\Phi$ 是一个元组关系演算公式，为 DOM($\Phi$) 是由如下两类符号构成的集合
        <ul>
          <li>$\Phi$ 中的所有常量</li>
          <li>$\Phi$ 中出现的所有元组的所有分量值</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="25-关系演算">2.5 关系演算</h2>

<h3 id="251-元组关系演算">2.5.1 元组关系演算</h3>

<p>元组关系演算的基本结构是元组演算表达式。</p>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>形式定义：${t</td>
          <td>\Phi(t)}$</td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li>$t$ 为<strong>元组变量</strong>，如果元组变量前有“全称” ($\forall$) 或“存在” ($\exists$) 量词，则称其为<strong>约束元组变量</strong>，否则称为<strong>自由元组变量</strong></li>
      <li>$\Phi(t)$ 是<strong>元组关系演算公式</strong></li>
    </ul>
  </li>
  <li>递归定义
    <ul>
      <li>原子命题函数是公式，称为原子公式。原子公式有三类：
        <ul>
          <li>$R(t)$。$t$ 是关系 $R$ 中的一个元组</li>
          <li>$t[i]\theta u[j]$</li>
          <li>$t[i]\theta c$ 或 $c\theta t[i]$，$c$ 为常量</li>
        </ul>
      </li>
      <li>如果 $\Phi_1$，$\Phi_2$ 是公式，则 $\Phi_1\vee\Phi_2,\ \Phi_1\wedge\Phi_2,\ \neg\Phi$ 也是公式</li>
      <li>如果 $\Phi$ 是公式，则 $\exists t(\Phi)$ 和 $\forall t(\Phi)$ 也是公式</li>
    </ul>
  </li>
  <li>优先级
    <ul>
      <li>括号 &gt; 算术比较运算符 &gt; 量词 ($\exists$ &gt; $\forall$) &gt; 逻辑运算符 ($\neg$ &gt; $\wedge$ &gt; $\vee$)</li>
    </ul>
  </li>
</ul>

<h3 id="252-域关系演算">2.5.2 域关系演算</h3>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>形式定义：${(x_1x_2…x_k)</td>
          <td>\Phi(x_1,x_2,…,x_k)}$</td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li>$x_i$ 表示域变量，如果域变量前有“全称” ($\forall$) 或“存在” ($\exists$) 量词，则称其为<strong>约束域变量</strong>，否则称为<strong>自由域变量</strong></li>
      <li>$\Phi$ 是<strong>域关系演算公式</strong></li>
    </ul>
  </li>
  <li>递归定义
    <ul>
      <li>原子命题函数是公式，称为原子公式。原子公式有三类：
        <ul>
          <li>$R(x_1,x_2,…,x_k)$。$(x_1,x_2,…,x_k)$ 是关系 $R$ 中的一个元组，$x_i$ 是域变量或常量</li>
          <li>$x_i\theta y_j$</li>
          <li>$x_i\theta c$ 或 $c\theta x_i$，$c$ 为常量</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="第三章-关系数据库标准语言-sql">第三章 关系数据库标准语言 SQL</h1>

<h2 id="sql-的特点">SQL 的特点</h2>

<ul>
  <li>综合统一</li>
  <li>高度非过程化</li>
  <li>面向集合的操作方式</li>
  <li>以同一种语法结构提供两种使用方式</li>
  <li>语言简洁，易学易用</li>
</ul>

<h2 id="sql-语言的基本概念">SQL 语言的基本概念</h2>

<h3 id="数据库数据语言">数据库数据语言</h3>

<p>分类：<strong>数据定义（描述）语言</strong>(DDL, Data Definition or Description Language)、<strong>数据操纵语言</strong>(Data Manipulation Language, DML)、<strong>数据控制语言</strong>(Data Control Language, DCL)</p>

<h4 id="数据定义语言">数据定义语言</h4>

<p>包括模式 DDL，外模式 DDL，内模式 DDL</p>

<h4 id="数据操纵语言">数据操纵语言</h4>

<p>检索、插入、修改、删除</p>

<h4 id="数据控制语言">数据控制语言</h4>

<p>完成数据库的安全性控制、完整性控制、并发控制等</p>

<h3 id="关系数据语言的特点">关系数据语言的特点</h3>

<ul>
  <li>
    <p><strong>一体化</strong></p>

    <p>将数据的定义、查询、更新、控制等功能融为一体，只给用户提供一种称之为”查询语言“的语言。便于用户学习与使用。</p>
  </li>
  <li>
    <p><strong>非过程化</strong></p>

    <p>用户只需提出”干什么“，而”怎样干“由 DBMS 解决。所以语言操作简单、易学、易用</p>
  </li>
  <li>
    <p><strong>面向集合的存取方式</strong></p>

    <p>操作对象是一个或多个关系，操作的结果也是一个新关系</p>
  </li>
  <li>
    <p><strong>既可独立使用又可与诸语言嵌套使用</strong></p>
  </li>
</ul>

<h3 id="关系数据库语言优越性的根源">关系数据库语言优越性的根源</h3>

<ul>
  <li>
    <p>关系模型采用了最简单、最规范化的数据结构，这使 DML 大大简化</p>
  </li>
  <li>
    <p>关系数据语言是建立在关系运算的数学基础上，可实现关系的垂直方向和水平方向的任意分割和组装操作，使得关系语言可随机地构造出用户需要的各种各样的新关系。</p>
  </li>
  <li>
    <p>关系语言的核心是<strong>查询</strong>，所以又称为<strong>查询语言</strong>。</p>
  </li>
  <li>
    <p><strong>关系运算</strong>是涉及关系数据语言的基础，关系运算的分类也决定了关系语言的分类。</p>

    <p><img src="/assets/images/post/class.png" alt="" /></p>
  </li>
</ul>

<h3 id="基本表与导出表">基本表与导出表</h3>

<ul>
  <li><strong>基本表</strong>：是实际存在的，每个表在存储中可用一个存储文件来表示。</li>
  <li><strong>导出表</strong>：是从基本表导出的表，有视图（View）和快照（Snapshot）
    <ul>
      <li><strong>视图</strong>
        <ul>
          <li>是一个<em>虚表</em>，即视图所对应的数据不实际存储在数据库中，只在数据库的数据字典中存储视图的定义</li>
          <li>视图一经定义就可以和基本表一样进行查询等操作，也可以用来定义新的视图</li>
          <li><code class="language-plaintext highlighter-rouge">Create View xxx As xxx</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="sql-数据查询功能">SQL 数据查询功能</h3>

<h3 id="查询的基本结构">查询的基本结构</h3>

<p>查询的基本结构是 <strong><code class="language-plaintext highlighter-rouge">SELECT-FROM-WHERE</code></strong> 组成的查询块</p>

<pre><code class="language-mysql">SELECT 目标列
FROM 基本块（或视图）
WHERE 检索条件
ORDER BY 列名 ASC 或 DESC
</code></pre>

<ul>
  <li>查询的结果仍是一个表</li>
  <li>查询块执行的过程是在表的水平方向上按“检索条件”选取元组，又在垂直方向上按 SELECT 指定的列进行投影。</li>
  <li>查询块可进行关系函数中投影、选取、连接等操作的组合</li>
</ul>

<h3 id="查询语句实现细节">查询语句实现细节</h3>

<h4 id="select-目标列">SELECT 目标列</h4>

<ul>
  <li>若在目标列前添加 DISTINCT，则表示要删除 SELECT 结果中的重复行</li>
</ul>

<h4 id="from-基本块或视图">FROM 基本块（或视图）</h4>

<ul>
  <li>连表检索
    <ul>
      <li>各个数据表之间用逗号相连</li>
      <li>连表时后面的检索条件中需要有连表条件</li>
      <li>如果连接的表中有属性名相同，要用表名作前缀加以区分（<code class="language-plaintext highlighter-rouge">S.A, R.A</code>）。</li>
      <li>若需要对表<em>自身</em>进行连接，则可以通过定义别名，将一个表看作两个表进行连接(<code class="language-plaintext highlighter-rouge">FROM S X, S Y</code>)</li>
      <li><strong>外连接</strong>：在连接谓词的某一边加（* 或 +），则逻辑上为 * 所在边的表增加了一个空行。它可以与另一个表中所有不满足连接条件的元组进行连接，使这些元组能够输出。</li>
    </ul>
  </li>
</ul>

<h4 id="where-检索条件">WHERE 检索条件</h4>

<ul>
  <li>
    <p>检索条件可以包含如下运算符：</p>

    <ul>
      <li>比较运算符（=, &lt;, &gt;, &lt;=, &gt;=, !=）</li>
      <li>布尔运算符（AND, OR, NOT）</li>
      <li>括号</li>
    </ul>
  </li>
  <li>
    <p><strong>子查询（嵌套查询）</strong></p>

    <ul>
      <li>WHERE 子句中可以包含另一个查询块，该查询块称为<strong>子查询</strong>或<strong>嵌套查询</strong>，包含子查询的语句称为<strong>外部查询</strong>。</li>
      <li>分类
        <ul>
          <li><strong>普通子查询</strong>：与外部查询无关，可单独执行得一组值</li>
          <li><strong>相关子查询</strong>：把外查询的列值作为检索条件的条件值</li>
        </ul>
      </li>
      <li>如果子查询返回单值，可以直接用比较运算符 =, &lt;, &gt;, &lt;=, &gt;= 等连接子查询</li>
      <li>如果子查询返回一组值，则必须在比较运算符和子查询之间插入 <code class="language-plaintext highlighter-rouge">ANY</code>, <code class="language-plaintext highlighter-rouge">ALL</code> 等操作符。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">IN</code></strong> 可以代替 <code class="language-plaintext highlighter-rouge">=ANY</code>，<code class="language-plaintext highlighter-rouge">NOT IN</code> 可以代替 <code class="language-plaintext highlighter-rouge">!= ALL</code></li>
      <li><strong><code class="language-plaintext highlighter-rouge">EXIST</code></strong> 表示存在量词 $\exist$</li>
      <li><code class="language-plaintext highlighter-rouge">NOT EXIST</code> 表示不存在</li>
      <li>将全程谓词表示为等价的存在谓词 $(\forall x)P=\neg(\exist x(\neg P))$</li>
      <li>将蕴含关系表示为等价的存在谓词 $p\rightarrow q=\neg p\vee q$</li>
    </ul>
  </li>
  <li>
    <p>并、差、交检索</p>

    <ul>
      <li>并 <strong><code class="language-plaintext highlighter-rouge">UNION</code></strong></li>
      <li>差 <strong>MINUS</strong></li>
      <li>交 <strong>INTERSECT</strong></li>
    </ul>

    <blockquote>
      <p>并、差、交检索的操作对象必须是<strong>相容</strong>的，是<strong>同类</strong>关系。即必须拥有相同数量与域的属性列。</p>
    </blockquote>
  </li>
</ul>

<h4 id="order-by-列名-asc-或-desc">ORDER BY 列名 ASC 或 DESC</h4>

<ul>
  <li>该语句可省略</li>
  <li>可以将结果按照指定列排序</li>
  <li>ASC 为升序，DESC 为降序，缺省则默认为升序</li>
</ul>

<h4 id="库函数">库函数</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">COUNT()</code></strong> 按列值计个数，<strong><code class="language-plaintext highlighter-rouge">COUNT(*)</code></strong> 对行记数</li>
  <li><strong><code class="language-plaintext highlighter-rouge">SUM()</code></strong> 对数值列求总和</li>
  <li><strong><code class="language-plaintext highlighter-rouge">AVG()</code></strong> 求数值列的平均值</li>
  <li><strong><code class="language-plaintext highlighter-rouge">MAX()</code></strong> 在列中找出最大值</li>
  <li><strong><code class="language-plaintext highlighter-rouge">MIN()</code></strong> 在列中找出最小值</li>
</ul>

<p>只能在 <code class="language-plaintext highlighter-rouge">SELECT</code> 子句以及 <code class="language-plaintext highlighter-rouge">HAVING</code> 子句中出现。</p>

<h4 id="分组检索">分组检索</h4>

<p>按属性列（列组）将关系的元组分组，每组在这些分组属性列（列祖）上具有相同值，对每一组执行 <code class="language-plaintext highlighter-rouge">SELECT</code> 操作。</p>

<p><strong>分组子句</strong></p>

<pre><code class="language-mysql">GROUP BY 列名
[HAVING 条件表达式] # 分组条件
</code></pre>

<h4 id="算数表达式值的检索">算数表达式值的检索</h4>

<p>SELECT 子句中，可包括由属性列、常数、库函数、算数运算符 + - * / 等组成的算数表达式</p>

<p>检索结果数据项名可用表达式表示或用“别名”表示</p>

<h4 id="部分匹配查询">部分匹配查询</h4>

<p>使用谓词 <strong><code class="language-plaintext highlighter-rouge">LIKE</code></strong> 或 <strong><code class="language-plaintext highlighter-rouge">NOT LIKE</code></strong>，一般形式：<code class="language-plaintext highlighter-rouge">&lt;列名&gt; LIKE/NOT LIKE &lt;字符串常量&gt;</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;列名&gt;</code> 必须为字符型或变长字符型</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;字符串常量&gt;</code>可包含两个特殊符号 <code class="language-plaintext highlighter-rouge">%</code> 和 <code class="language-plaintext highlighter-rouge">_</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">%</code>：代表任意序列的 0 个或多个字符</li>
      <li><code class="language-plaintext highlighter-rouge">_</code>：代表任意单个字符</li>
    </ul>
  </li>
</ul>

<h3 id="sql-数据定义功能">SQL 数据定义功能</h3>

<table>
  <thead>
    <tr>
      <th>操作对象</th>
      <th>创建</th>
      <th>删除</th>
      <th>修改</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>基本表</td>
      <td><code class="language-plaintext highlighter-rouge">Create Table</code></td>
      <td><code class="language-plaintext highlighter-rouge">Drop Table</code></td>
      <td><code class="language-plaintext highlighter-rouge">Alter Table</code></td>
    </tr>
    <tr>
      <td>视图</td>
      <td><code class="language-plaintext highlighter-rouge">Create View</code></td>
      <td><code class="language-plaintext highlighter-rouge">Drop View</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>索引</td>
      <td><code class="language-plaintext highlighter-rouge">Create Index</code></td>
      <td><code class="language-plaintext highlighter-rouge">Drop Index</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="定义基本表">定义基本表</h4>

<pre><code class="language-mysql">Create Table &lt;表名&gt;
(
    &lt;列名&gt; &lt;数据类型&gt; [&lt;列级完整性约束&gt;]
    [{,&lt;列名&gt; &lt;数据类型&gt; [&lt;列级完整性约束&gt;]}]
    [{, [&lt;表级完整性约束&gt;]}]
);
</code></pre>

<ul>
  <li>完整性约束
    <ul>
      <li>NULL / NOT NULL</li>
      <li>UNIQUE</li>
      <li>PRIMARY KEY</li>
      <li>FOREIGN KEY</li>
      <li>CHECK</li>
    </ul>
  </li>
</ul>

<h4 id="修改基本表">修改基本表</h4>

<pre><code class="language-mysql">Alter Table &lt;表名&gt;
[Add &lt;新列名&gt; &lt;数据类型&gt; [&lt;完整性约束&gt;]]
[Drop &lt;完整性约束名&gt;]
[Modify &lt;列名&gt; &lt;数据类型&gt;]
</code></pre>

<h4 id="删除基本表">删除基本表</h4>

<pre><code class="language-mysql">Drop Table &lt;表名&gt;
</code></pre>

<h3 id="sql-数据类型">SQL 数据类型</h3>

<table>
  <thead>
    <tr>
      <th>数据类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>char(n)</td>
      <td>固定长度的字符串</td>
    </tr>
    <tr>
      <td>varchar(n)</td>
      <td>可变长字符串</td>
    </tr>
    <tr>
      <td>int</td>
      <td>整数</td>
    </tr>
    <tr>
      <td>smallint</td>
      <td>小整数类型</td>
    </tr>
    <tr>
      <td>numeric(p, q)</td>
      <td>定点数共 p 位，小数点右边 q 位</td>
    </tr>
    <tr>
      <td>Real, double precision</td>
      <td>浮点数域双精度浮点数，精度域机器有关</td>
    </tr>
    <tr>
      <td>Float</td>
      <td>n 位的精度浮点数</td>
    </tr>
    <tr>
      <td>date</td>
      <td>日期（年、月、日）</td>
    </tr>
    <tr>
      <td>time</td>
      <td>时间（小时、分、秒）</td>
    </tr>
    <tr>
      <td>interval</td>
      <td>两个 date 或 time 类型数据之间的差</td>
    </tr>
  </tbody>
</table>

<h3 id="索引操作">索引操作</h3>

<h4 id="定义索引">定义索引</h4>

<pre><code class="language-mysql">Create [Unique] [Cluster] Index &lt;索引名&gt;
On &lt;表名&gt; (&lt;列名&gt; [次序] [, &lt;列名&gt; [次序]]);
</code></pre>

<h4 id="删除索引">删除索引</h4>

<pre><code class="language-mysql">Drop Index &lt;索引名&gt;
</code></pre>

<h3 id="视图操作">视图操作</h3>

<h4 id="视图的作用">视图的作用</h4>

<ul>
  <li>能够简化用户操作</li>
  <li>使用户能够以多种角度看待同一数据</li>
  <li>提供了一定程度的逻辑独立性</li>
  <li>能够对数据图个安全保护</li>
</ul>

<h4 id="定义视图">定义视图</h4>

<pre><code class="language-mysql">Create View &lt;视图名&gt;
[(&lt;列名&gt; [, &lt;列名&gt;] ...)]
As &lt;子查询&gt;
[With Check Option]
</code></pre>

<h4 id="删除视图">删除视图</h4>

<pre><code class="language-mysql">Drop View &lt;视图名&gt;
</code></pre>

<h4 id="查询视图">查询视图</h4>

<h5 id="视图消解-view-resolution">视图消解 (View Resolution)</h5>

<p>DBMS 执行对视图的查询时，从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正的查询。这一转换的过程称为<strong>视图消解</strong>。</p>

<h3 id="sql-数据更新">SQL 数据更新</h3>

<h4 id="插入数据insert-语句">插入数据——Insert 语句</h4>

<ul>
  <li>
    <p>插入单个元组</p>

    <pre><code class="language-mysql">Insert Into &lt;表明&gt; [(&lt;属性列&gt; [{, &lt;属性列&gt;}])]
Values (&lt;值&gt; [{, &lt;值&gt;}])
</code></pre>
  </li>
  <li>
    <p>插入子查询结果</p>

    <pre><code class="language-mysql">Insert Into &lt;表名&gt; [(&lt;属性列&gt; [{, &lt;属性列&gt;}])]
&lt;子查询&gt;
</code></pre>
  </li>
</ul>

<h4 id="修改数据update-语句">修改数据——Update 语句</h4>

<pre><code class="language-mysql">Update &lt;表名&gt;
Set &lt;列名&gt; = &lt;表达式&gt; [{, &lt;列名&gt; = &lt;表达式&gt;}]
[Where &lt;条件&gt;]
</code></pre>

<h4 id="删除数据delete-语句">删除数据——Delete 语句</h4>

<pre><code class="language-mysql">Delete From &lt;表名&gt; [Where &lt;条件&gt;]
</code></pre>

<h3 id="空值">空值</h3>

<h4 id="空值的运算">空值的运算</h4>

<blockquote>
  <p>空值是“不知道”或“不存在”或“无意义”的值，用 NULL 表示</p>
</blockquote>

<ul>
  <li>
    <p>属性定义有 <code class="language-plaintext highlighter-rouge">NOT NULL</code> 或 <code class="language-plaintext highlighter-rouge">UNIQUE</code> 约束以及主属性，都不可取空值</p>
  </li>
  <li>
    <p>空值与另一个值的算数运算结果为 NULL，与另一个值的比较运算结果为 UNKWOWN</p>
  </li>
  <li>
    <p>TRUE, FALSE, UNKNOWN 的三值逻辑</p>

    <table>
      <thead>
        <tr>
          <th>逻辑表达式</th>
          <th>值</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">T AND U</code>, <code class="language-plaintext highlighter-rouge">U AND U</code></td>
          <td><code class="language-plaintext highlighter-rouge">U</code></td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">F AND U</code></td>
          <td><code class="language-plaintext highlighter-rouge">F</code></td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">F OR U</code>, <code class="language-plaintext highlighter-rouge">U OR U</code></td>
          <td><code class="language-plaintext highlighter-rouge">U</code></td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">T OR U</code></td>
          <td><code class="language-plaintext highlighter-rouge">T</code></td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">NOT U</code></td>
          <td><code class="language-plaintext highlighter-rouge">U</code></td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="空值的判断">空值的判断</h4>

<p>判断属性是否为空值，用  <code class="language-plaintext highlighter-rouge">IS NULL</code> 或 <code class="language-plaintext highlighter-rouge">IS NOT NULL</code> 来表示</p>

<h3 id="sql-数据控制功能">SQL 数据控制功能</h3>

<ul>
  <li>定义完整性约束条件</li>
  <li>支持事务操作</li>
  <li>提供安全控制功能
    <ul>
      <li>授权
        <ul>
          <li><code class="language-plaintext highlighter-rouge">GRANT &lt;权限&gt; [ON &lt;对象类型&gt; &lt;对象名&gt;] TO &lt;用户&gt;</code></li>
        </ul>
      </li>
      <li>收回权限
        <ul>
          <li><code class="language-plaintext highlighter-rouge">REVOKE &lt;权限&gt; [ON &lt;对象类型&gt; &lt;对象名&gt;] FROM &lt;用户&gt;</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="嵌入式-sql-的意义">嵌入式 SQL 的意义</h3>

<ul>
  <li>嵌入式 SQL 把 SQL 语句嵌入到高级语言中</li>
  <li>嵌入式 SQL 把 SQL 的最佳特性与程序设计语言的最佳特性（如过程处理能力）结合起来，使 SQL 功能最强，灵活性更强。</li>
</ul>

<h1 id="第六章-关系数据理论">第六章 关系数据理论</h1>

<h2 id="61-问题的提出">6.1 问题的提出</h2>

<p>本章中把关系模式看作一个三元组 $R&lt;U, F&gt;$，其中 ：</p>

<ul>
  <li>$R$ 为关系名</li>
  <li>$U$ 为一组属性</li>
  <li>$F$ 为属性组 $U$ 上的一组数据依赖</li>
</ul>

<h3 id="概念">概念</h3>

<h4 id="第一范式">第一范式</h4>

<p>每个分量必须是不可分的数据项，满足这个条件的关系模式就属于第一范式 (1NF)</p>

<p><strong>存在的问题</strong>：</p>

<ul>
  <li>数据冗余</li>
  <li>更新异常 (update anomalies)</li>
  <li>插入异常 (insertion anomalies)</li>
  <li>删除异常 (deletion anomalies)</li>
</ul>

<blockquote>
  <p>一个好的关系模式应当不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。</p>
</blockquote>

<h4 id="数据依赖">数据依赖</h4>

<p>数据依赖是一个关系内部属性与属性之间的一种约束关系，这种约束关系是通过属性间值的相等与否体现出来的数据间的相关联系。</p>

<h4 id="函数依赖-functional-dependency-fd">函数依赖 (Functional Dependency, FD)</h4>

<h4 id="多值依赖-multi-valued-dependency-mvd">多值依赖 (Multi-Valued Dependency, MVD)</h4>

<h2 id="62-规范化">6.2 规范化</h2>

<h3 id="621-函数依赖">6.2.1 函数依赖</h3>

<h4 id="函数依赖">函数依赖</h4>

<p>设 $R(U)$ 是属性集 $U$ 上的关系模式，$X$，$Y$ 是 $U$ 的子集，若对于 $R(U)$ 的<strong>任意</strong>一个可能的关系 $r$，$r$ 中<strong>不可能</strong>存在两个元组在 $X$ 上的属性值相等，而在 $Y$ 上的属性值不等，则称 <strong>$X$ 函数确定 $Y$ 或 $Y$ 函数依赖于 $X$</strong>，记作 $X\rightarrow Y$</p>

<blockquote>
  <p>函数依赖和别的数据依赖一样是一个语义范畴的概念，只能根据语义来确定一个函数依赖。</p>
</blockquote>

<h4 id="平凡--非平凡函数依赖">平凡 &amp; 非平凡函数依赖</h4>

<h5 id="非平凡函数依赖">非平凡函数依赖</h5>

<p>$X\rightarrow Y$，但 $Y\not\subseteq X$，则称 $X\rightarrow Y$ 是<strong>非平凡的函数依赖</strong></p>

<h5 id="平凡函数依赖">平凡函数依赖</h5>

<p>$X\rightarrow Y$，但 $Y\subseteq X$，则称 $X\rightarrow Y$ 是<strong>平凡的函数依赖</strong></p>

<h4 id="完全--部分函数依赖">完全 &amp; 部分函数依赖</h4>

<h5 id="完全函数依赖">完全函数依赖</h5>

<p>在 $R(U)$ 中，如果 $X\rightarrow Y$，并且对于 $X$ 的任何一个真子集 $X’$，都有 $X’\not\rightarrow Y$，则称 $Y$ 对 $X$ 是<strong>完全函数依赖</strong>，记作 $X\overset{F}{\rightarrow}Y$</p>

<h5 id="部分函数依赖-partial-functional-dependency">部分函数依赖 (partial functional dependency)</h5>

<p>记作 $X\overset{P}{\rightarrow}Y$</p>

<h4 id="传递函数依赖-transitive-functional-dependency">传递函数依赖 (transitive functional dependency)</h4>

<p>在 $R(U)$ 中，如果 $X\rightarrow Y (Y\not\subseteq X),Y\not\rightarrow X, Y\rightarrow Z, Z\not\subseteq Y$ 则称 $Z$ 对 $X$ <strong>传递函数依赖</strong>，记为 $X\overset{t}{\rightarrow}Y$ 或 $X\overset{传递}{\rightarrow}Y$</p>

<h3 id="622-码">6.2.2 码</h3>

<h4 id="候选码-candidate-key">候选码 (Candidate key)</h4>

<p>关系中的某一属性组，若它的值为一标识了一个元组，并具有最小性，则称该属性组位候选码。</p>

<p>设 $K$ 为 $R&lt;U,F&gt;$ 中的属性或属性组合，若 $K\overset{F}{\rightarrow} U$，则 $K$ 为 $R$ 的候选码 (candidate key)</p>

<h4 id="超码">超码</h4>

<p>如果 $U$ 函数依赖于 $K$，即 $K\rightarrow U$，则称 $K$ 为超码 (surpkey)</p>

<blockquote>
  <p>候选码是一类特殊的超码，即候选码的超集（如果存在）一定是超码，候选码的任何真子集一定不是超码</p>
</blockquote>

<h4 id="主码">主码</h4>

<p>若候选码多于一个，则选定其中的一个为主码 (primary key)</p>

<h4 id="主属性">主属性</h4>

<p>包含在<strong>任何</strong>一个候选码中的属性称为主属性 (prime attribute)</p>

<h4 id="非主属性-非码属性">非主属性 (非码属性)</h4>

<p><strong>不包含</strong>在<strong>任何</strong>一个候选码中的属性称为主属性 (nonprime attribute) 或 (non-key attribute)</p>

<h4 id="全码">全码</h4>

<p>整个属性组是码</p>

<h4 id="外部码-外码">外部码 (外码)</h4>

<p>关系模式 $R$ 中属性或属性组 $X$ 并非 $R$ 的码，但 $X$ 是另一个关系模式的码，则称 $X$ 是 $R$ 的外部码 (foreign key)，简称外码。</p>

<h3 id="623-范式">6.2.3 范式</h3>

<p>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</p>

<p>低一级范式的关系模式可以通过<strong>模式分解</strong> (schema decomposition) 转化为若干个高一级范式的关系模式的集合，这种过程就叫<strong>规范化</strong> (normalization)。</p>

<h3 id="624-2nf">6.2.4 2NF</h3>

<p>若 $R\in$ 1NF，并且<strong>每一个</strong>非主属性<strong>完全函数依赖</strong>于<strong>任何</strong>一个候选码，则 $R\in$ 2NF</p>

<p>不属于 2NF 的问题</p>

<ul>
  <li>插入异常</li>
  <li>删除异常</li>
  <li>修改复杂</li>
</ul>

<h3 id="625-3nf">6.2.5 3NF</h3>

<p>设关系模式 $R&lt;U,F&gt;\in$ 1NF，若 $R$ 中不存在这样的码 $X$，属性组 $Y$ 及非主属性 $Z (Z\not\subseteq Y)$ 使得 $X\rightarrow Y$，$Y\rightarrow Z$ 成立，$Y\not\rightarrow X$，则称 $R&lt;U, F&gt;\in$ 3NF</p>

<blockquote>
  <p>若 $R\in$ 3NF，则每一个非主属性既不转递依赖于码（任意一个候选码），也不部分依赖于码，也不部分依赖于码</p>
</blockquote>

<h3 id="626-bcnf">6.2.6 BCNF</h3>

<p>关系模式 $R&lt;U, F&gt;\in$ 1NF，若 $X\rightarrow Y$ 且 $Y\not\subseteq X$ 时 $X$ 必含有码，则 $R&lt;U, F&gt;\in$ BCNF</p>

<blockquote>
  <p>关系模式 $R&lt;U, F&gt;$ 中，若每一个决定因素都包含码，则 $R&lt;U,F&gt;\in BCNF$</p>
</blockquote>

<h3 id="627-多值依赖">6.2.7 多值依赖</h3>

<h4 id="多值依赖的定义">多值依赖的定义</h4>

<p>设 $R(U)$ 是属性集 $U$ 上的一个关系模式。$X$，$Y$，$Z$ 是 $U$ 的子集，并且 $Z=U-X-Y$。关系模式 $R(U)$ 中多值依赖 $X\rightarrow\rightarrow Y$ 成立，当且仅当对 $R(U)$ 的任一关系 $r$，给定的一对 $(x,z)$ 值，有一组 $Y$ 值，这组值仅仅决定于 $x$ 值而与 $z$ 值无关。</p>

<h4 id="多值依赖的性质">多值依赖的性质</h4>

<ol>
  <li>多值依赖具有<strong>对称性</strong></li>
</ol>

<p>若 $X\rightarrow\rightarrow Y$，则 $X\rightarrow\rightarrow Z$，其中 $Z=U-X-Y$</p>

<ol>
  <li>
    <p>多值依赖具有<strong>传递性</strong></p>

    <p>若 $X\rightarrow\rightarrow Y$， $Y\rightarrow\rightarrow Z$，则 $X\rightarrow\rightarrow Z-Y$</p>
  </li>
  <li>
    <p>函数依赖可以看作是多值依赖的特殊情况</p>

    <p>若 $X\rightarrow Y$，则 $X\rightarrow\rightarrow Y$</p>
  </li>
  <li>
    <p>若 $X\rightarrow\rightarrow Y$，$X\rightarrow\rightarrow Z$，则 $X\rightarrow\rightarrow YZ$</p>
  </li>
  <li>
    <p>若 $X\rightarrow\rightarrow Y$，$X\rightarrow\rightarrow Z$，则 $X\rightarrow\rightarrow Y\cap Z$</p>
  </li>
  <li>
    <p>若 $X\rightarrow\rightarrow Y$，$X\rightarrow\rightarrow Z$，则 $X\rightarrow\rightarrow Y-Z$，$X\rightarrow\rightarrow Z-Y$</p>
  </li>
</ol>

<h4 id="多值依赖与函数依赖的区别">多值依赖与函数依赖的区别</h4>

<ol>
  <li>多值依赖的有效性与属性集的范围有关</li>
  <li>若函数依赖 $X\rightarrow Y$ 在 $R(U)$ 上成立，则对于任何 $Y’\subset Y$ 均有 $X\rightarrow Y’$ 成立。而多值依赖 $X\rightarrow\rightarrow Y$ 若在 $R(U)$ 上成立，却不能断言对于任何 $Y’\sub Y$ 有 $X\rightarrow\rightarrow Y’$ 成立。</li>
</ol>

<h3 id="628-4nf">6.2.8 4NF</h3>

<p>关系模式 $R&lt;U,F&gt;\in 1NF$，如果对于 $R$ 的每个非平凡多值依赖 $X\rightarrow\rightarrow Y(Y\not\subseteq X)$，$X$ 都包含码，则称 $R&lt;U,F&gt;\in$ 4NF</p>

<blockquote>
  <p>4NF 就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</p>
</blockquote>

<h3 id="629-规范化小结">6.2.9 规范化小结</h3>

<p>规范化的基本思想就是逐步消除数据依赖中不合适的部分，即“一事一地”的模式设计原则。规范化实质上是概念的<strong>单一化</strong>。</p>

<p><img src="/assets/images/post/normalization.png" alt="" /></p>

<p>关系模式的规范化过程是通过对关系模式的分解来实现的，即把低一级的关系模式分解为若干个高一级的关系模式。这种分解不是唯一的。</p>

<h2 id="63-数据依赖的公理系统">6.3 数据依赖的公理系统</h2>

<h3 id="逻辑蕴含">逻辑蕴含</h3>

<p>对于满足一组函数依赖 F 的关系模式 $R&lt;U,F&gt;$，其任何一个关系 $r$，若函数依赖 $X\rightarrow Y$ 都成立（即 $r$ 中任意两元组 $t$、$s$，若 $t[X]=s[X]$，则 $t[Y]=s[Y]$），则称 F <strong>逻辑蕴含</strong> $X\rightarrow Y$</p>

<h3 id="armstrong-公理系统-armstrongs-axiom">Armstrong 公理系统 (Armstrong’s axiom)</h3>

<p>设 $U$ 为属性集总体，$F$ 是 $U$ 上的一组函数依赖，于是又关系模式 $R&lt;U,F&gt;$，对 $R&lt;U,F&gt;$ 来说有以下的推理规则：</p>

<ul>
  <li>
    <p><strong>自反律</strong> (reflexivity rule)</p>

    <p>若 $Y\subseteq X\subseteq U$，则 $X\rightarrow Y$ 为 $F$ 所蕴含。</p>
  </li>
  <li>
    <p><strong>增广律</strong> (augmentation rule)</p>

    <p>若 $X\rightarrow Y$ 为 $F$ 所蕴含，且 $Z\subseteq U$，则 $XZ\rightarrow YZ$ 为 $F$ 所蕴含。</p>
  </li>
  <li>
    <p><strong>传递律</strong> (transitivity rule)</p>

    <p>若 $X\rightarrow Y$ 及 $Y\rightarrow Z$ 为 $F$ 所蕴含，则 $X\rightarrow Z$ 为 $F$ 所蕴含。</p>
  </li>
</ul>

<blockquote>
  <p>Armstrong 公理系统是<strong>有效</strong>的，<strong>完备</strong>的。</p>

  <ul>
    <li>
      <p>有效性</p>

      <p>由 $F$ 出发根据 Armstrong 公理推导出来的每一个函数依赖一定在 $F^+$ 中</p>
    </li>
    <li>
      <p>完备性</p>

      <p>$F^+$ 中的每一个函数依赖，必定可以由 $F$ 出发根据 Armstrong 公理推导出来</p>
    </li>
  </ul>
</blockquote>

<h3 id="推理规则">推理规则</h3>

<ul>
  <li>
    <p><strong>合并规则</strong> (union rule)</p>

    <p>由 $X\rightarrow Y$，$X\rightarrow Z$，有 $X\rightarrow YZ$</p>
  </li>
  <li>
    <p><strong>伪传递规则</strong> (pseudo transitivity rule)</p>

    <p>由 $X\rightarrow Y$，$WY\rightarrow Z$，有 $XW\rightarrow Z$</p>
  </li>
  <li>
    <p><strong>分解规则</strong> (decomposition rule)</p>

    <p>由 $X\rightarrow Y$ 及 $Z\subseteq Y$，有 $X\rightarrow Z$</p>
  </li>
</ul>

<h3 id="引理">引理</h3>

<p>$X\rightarrow A_1A_2…A_k$ 成立的充分必要条件是 $X\rightarrow A_i(i=1,2,…,k)$ 成立</p>

<h3 id="闭包-closure">闭包 (closure)</h3>

<p>在关系模式 $R&lt;U,F&gt;$ 中为 $F$ 所逻辑蕴含的函数依赖的全体叫做 $F$ 的闭包，记为 $F^+$</p>

<h3 id="属性集关于函数依赖的闭包">属性集关于函数依赖的闭包</h3>

<h4 id="定义">定义</h4>

<table>
  <tbody>
    <tr>
      <td>设 $F$ 为属性集 $U$ 上的一组函数依赖，$X$、$Y\subseteq U$，$X_F^+={A</td>
      <td>X\rightarrow A 能由 F 根据 Armstrong 公理导出}$，$X_F^+$ 称为属性集 $X$ 关于函数依赖集 $F$ 的闭包。</td>
    </tr>
  </tbody>
</table>

<h4 id="算法">算法</h4>

<p>求属性集 $X(X\subseteq U)$ 关于 $U$ 上的函数依赖集 $F$ 的闭包 $X_F^+$</p>

<ul>
  <li>
    <p>输入：$X$、$F$</p>
  </li>
  <li>
    <p>输出：$S_F^+$</p>
  </li>
</ul>

<p>步骤：</p>

<ol>
  <li>
    <p>令 $X^{0} = X$, $i=0$</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>求 $B$，这里  $B = {A</td>
          <td>(\exists V)(\exists W)(V\rightarrow W\in F\wedge X\subseteq X^{(i)}\wedge A\in W)}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>$X^{(i+1)}=B\cup X^{(i)}$</p>
  </li>
  <li>
    <p>判断 $X^{(i+1)} = X^{(i)}$</p>
  </li>
  <li>
    <p>若 $X^{(i+1)}$ 与 $X^{(i)}$ 相等或 $X^{(i)} = U$，则 $X^{(i)}$ 就是 $X_F^+$，算法终止</p>
  </li>
  <li>若否，则 $i=i+1$，返回第二步</li>
</ol>

<h3 id="引理-1">引理</h3>

<p>设 $F$ 为属性集 $U$ 上的一组函数依赖，$X$、$Y\subseteq U$，$X\rightarrow Y$ 能由 $F$ 根据 Armstrong 公理导出的充分必要条件是 $Y\subseteq X_F^+$。</p>

<h3 id="定理">定理</h3>

<p>Armstrong 公理系统的有效的、完备的</p>

<h3 id="等价--覆盖">等价 / 覆盖</h3>

<h4 id="定义-1">定义</h4>

<p>如果 $G^+ = F^+$，就说函数依赖集 $F$ 覆盖 $G$ 或 $F$ 与 $G$ 等价。</p>

<h4 id="定理-1">定理</h4>

<p>$G^+=F^+$ 的充分必要条件是 $G^+\subseteqF^+$ 和 $G^+ \subseteq F^+$</p>

<h3 id="最小依赖集-minimal-cover">最小依赖集 (minimal cover)</h3>

<h4 id="定义-2">定义</h4>

<p>如果函数依赖集 $F$ 满足下列条件，则称 $F$ 为一个极小函数依赖集，亦称为<strong>最小依赖集</strong>或<strong>最小依赖</strong></p>
<ol>
  <li>$F$ 中任一函数依赖的右部仅含有一个属性。</li>
  <li>$F$ 中不存在这样的函数依赖 $X\rightarrow A$，使得 $F$ 与 $F-{X\rightarrow A}$ 等价</li>
  <li>$F$ 中不存在这样的函数依赖 $X\rightarrow A$，$X$ 有真子集 $Z$ 使得 $F-{X\rightarrow A}\cup{Z\rightarrow A}$ 与 $F$ 等价</li>
</ol>

<h4 id="算法-1">算法</h4>

<ol>
  <li>
    <table>
      <tbody>
        <tr>
          <td>逐一检查 $F$ 中各函数依赖  $FD_i:X\rightarrow Y$，若 $Y=A_1A_2…A_k,k\ge 2$，则用 ${X\rightarrow A_j</td>
          <td>j=1,2,…,k$ 来取代 $X\rightarrow Y$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>逐一检查 $F$ 中各函数依赖 $FD_i:X\rightarrow A$，令 $G=F-{X\rightarrow A}$，若 $A\inX_G^+$，则从 $F$ 中去掉此函数依赖（因为 $F$ 与 $G$ 等价的充要条件是 $A\in X_G^+$）</li>
  <li>逐一去除 $F$ 中各函数依赖 $FD_i:X\rightarrow A$，设 $X=B_1B_2…B_m,m\ge 2$，逐一考查 $B_i(i=1,2,…,m)$，若 $A\in(X-B_i)_F^+$，则以 $X\rightarrow B_i$ 取代 $X$（因为 $F$ 与 $F-{X\rightarrow A}\cup {Z\rightarrow A}$ 等价的充要条件是 $A\in Z^+$，其中 $Z=X-B_i$）</li>
</ol>

<h2 id="64-模式分解">6.4 模式分解</h2>

<h1 id="第七章-数据库设计">第七章 数据库设计</h1>

<h2 id="71-数据库设计概述">7.1 数据库设计概述</h2>

<p>数据库设计是指对于一个给定的应用环境，构造（设计）优化数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</p>

<ul>
  <li>数据库设计的方法
    <ul>
      <li>手工试凑法（直接设计法）：根据应用的数据要求于处理要求，直接涉及数据库的结构。</li>
      <li>规范设计法：运用软件工程的思想和方法，把整个设计过程划分为若干阶段，把复杂的大问题分为若干相对简单的小问题，每个阶段只解决整个设计中的部分问题。</li>
    </ul>
  </li>
</ul>

<h3 id="711-数据库设计的特点">7.1.1 数据库设计的特点</h3>

<ol>
  <li>
    <p>数据库建设的基本规律</p>

    <p><strong>数据</strong>的收集、整理、组织和不断更新是数据库建设中的重要环节。</p>
  </li>
  <li>
    <p>结构（数据）设计和行为（处理）设计相结合</p>
  </li>
</ol>

<h3 id="713-数据库设计的基本步骤">7.1.3 数据库设计的基本步骤</h3>

<ol>
  <li>
    <p><strong>需求分析</strong></p>

    <p>数据库设计的<strong>基础</strong>。</p>

    <ul>
      <li>对应用环境进行详细调查。收集支持系统目标的基础数据及其处理。</li>
    </ul>
  </li>
  <li>
    <p><strong>概念结构设计</strong></p>

    <p>数据库设计的<strong>关键</strong>。</p>

    <ul>
      <li>通过对用户需求进行综合、归纳与抽象。形成独立于数据库逻辑结构于具体 DBMS 的概念模型，可以用 E-R 图等表示。</li>
    </ul>
  </li>
  <li>
    <p><strong>逻辑结构设计</strong></p>

    <ul>
      <li>将概念结构转换为某个 DBMS 所支持的数据模型，并进行优化。再将得到的逻辑结构转换成特定的 DBMS 能处理的模式、子模式。</li>
    </ul>
  </li>
  <li>
    <p><strong>物理结构设计</strong></p>

    <p>为逻辑数据模型选取一个最适合应用环境的物理结构（包括存取结构和存取方法）</p>

    <ul>
      <li>设计数据库在物理设备上的存储结构和存取方法。一般分为两步：一是确定数据库的内模式；二是对物理结构进行时间与空间效率的评价</li>
    </ul>
  </li>
  <li>
    <p><strong>数据库实施</strong></p>

    <p>运用数据库管理系统提供的数据库语言及其宿主语言，根据逻辑设计和物理设计的结果建立数据库，编写和调试应用程序，组织数据入库，并进行试运行。</p>

    <ul>
      <li>是建立数据库的过程。用 DBMS 的 DDL 描述三级模式，并调试产生目标模式。开发应用程序，组织数据入库并试运行</li>
    </ul>
  </li>
  <li>
    <p><strong>数据库运行和维护</strong></p>

    <p>数再运行过程中需要不断对其进行评估、调整与修改。</p>

    <ul>
      <li>在数据库正式运行后，由 DBA 执行对数据库经常性的维护工作，包括数据库转储与恢复、对数据库控制、数据库性能监控、数据库的重组与重构。</li>
    </ul>
  </li>
</ol>

<h3 id="714-数据库设计过程中的各级模式">7.1.4 数据库设计过程中的各级模式</h3>

<p><img src="/assets/images/post/schema.png" alt="" /></p>

<h2 id="72-需求分析">7.2 需求分析</h2>

<h3 id="721-需求分析的任务">7.2.1 需求分析的任务</h3>

<p>调查的重点是“数据”和“处理”，通过调查、收集与分析，获得用户对数据库的如下要求：</p>
<ol>
  <li>信息要求：指系统中所涉及的数据及数据之间的联系。具体收集数据的名称、类型、长度等，确定数据之间联系的类型。</li>
  <li>处理要求： 指用户要完成什么处理功能，对处理的响应时间和处理方式的要求。</li>
  <li>安全性与完整性要求</li>
</ol>

<h3 id="722-需求分析的方法">7.2.2 需求分析的方法</h3>

<ol>
  <li>首先调查用户的实际要求，与用户达成共识</li>
  <li>分析与表达这些需求。
    <ul>
      <li>用数据流图表达数据和处理之间的关系</li>
      <li>用数据字典描述系统中的各类数据</li>
    </ul>
  </li>
</ol>

<h4 id="数据流图-data-flow-diagram-dfd-图">数据流图 （Data Flow Diagram, DFD 图）</h4>

<p>以图形方式来表达系统的功能、数据在系统内部的逻辑流向和逻辑变换过程。</p>

<h4 id="数据字典">数据字典</h4>

<p>是对数据的集中的系列说明。包含每一个数据元素的名字、含义等各方面的描述。</p>

<ul>
  <li>从数据流图中提取出所有原子数据项</li>
  <li>把有联系的数据项组合起来形成数据组</li>
  <li>以数据组为单位，写出数据项的如下定义：
    <ul>
      <li>语义定义：名字，实际含义等</li>
      <li>类型定义：数据类型，数据宽度，小位数等</li>
      <li>完整性约束定义：值约束、空值约束以及其他比较复杂的完整性约束。</li>
    </ul>
  </li>
  <li>根据用户和实际领域的信息模型需要补充其他数据项及其定义。</li>
</ul>

<h3 id="723-数据字典">7.2.3 数据字典</h3>

<p>数据字典是进行详细的数据收集和数据分析所获得的主要成果。它是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是再需求分析阶段建立，在数据库设计过程中不断修改、充实和完善的。它在数据库设计中占有很重要的地位。</p>

<p>数据字典包括：</p>
<ol>
  <li><strong>数据项</strong></li>
  <li><strong>数据结构</strong></li>
  <li><strong>数据流</strong></li>
  <li><strong>数据存储</strong></li>
  <li><strong>处理过程</strong></li>
</ol>

<h2 id="73-概念结构设计">7.3 概念结构设计</h2>

<h3 id="e-r-图">E-R 图</h3>

<h5 id="e-r-图的组成">E-R 图的组成</h5>

<ul>
  <li>
    <p><strong>实体</strong></p>

    <p>用<strong>长方形</strong>表示实体型，在框内写上实体名</p>
  </li>
  <li>
    <p><strong>联系</strong></p>

    <p>用<strong>菱形</strong>表示实体间的联系，菱形框内写上联系名。用无向边把菱形分别与有关实体相连，在无向边旁标上联系的类型。若联系也具有属性，则属性和菱形也能用无向边连接上。</p>
  </li>
  <li>
    <p><strong>属性</strong></p>

    <p>用<strong>椭圆形</strong>表示实体的属性，并用无向边把实体于其属性连接起来。</p>
  </li>
</ul>

<h5 id="原则">原则</h5>

<ul>
  <li>属性必须是不可分的数据项，不能是另一些属性的聚集</li>
  <li>属性不能与其它实体具有联系，即 E-R 图中所表示的联系是实体之间的联系</li>
  <li>实体和描述它的属性之间保持 1:1 或 n:1 的联系。对于 1:n 或 n:m 的联系，要进行调整，一般可将该属性上升为实体。</li>
</ul>

<h5 id="局部-e-r-图设计步骤">局部 E-R 图设计步骤</h5>

<ol>
  <li>选择局部应用</li>
  <li>以需求分析中得到的数据元素表为基础，利用数据抽象机制，建立实体模型</li>
  <li>确定实体之间的联系类型。用 E-R 图表示这些实体与实体之间的联系，形成分 E-R 图</li>
</ol>

<h5 id="综合分-e-r-图形成总-e-r-图">综合分 E-R 图形成总 E-R 图</h5>

<ul>
  <li>多个分 E-R 图一次集成</li>
  <li>逐步集成，用累加的方式一次集成两个分 E-R 图</li>
</ul>

<h5 id="集成局部-e-r-图的步骤">集成局部 E-R 图的步骤</h5>

<ul>
  <li>
    <p><strong>合并</strong></p>

    <p>解决各分 E-R 图之间的冲突，将各分 E-R 图合并起来生成<strong>初步 E-R 图</strong></p>

    <p><strong>冲突</strong>：</p>

    <ul>
      <li>
        <p><strong>属性冲突</strong></p>

        <p>属性的类型、取值范围或取值集合不同，或属性取值单位冲突</p>

        <blockquote>
          <p>解决：讨论协商解决</p>
        </blockquote>
      </li>
      <li>
        <p><strong>命名冲突</strong></p>

        <p>包括属性名、实体名、联系名之间的同名异义，异名同义</p>

        <blockquote>
          <p>解决：建立命名表，统一命名，异名同义的名字可标为别名</p>
        </blockquote>
      </li>
      <li>
        <p><strong>结构冲突</strong></p>

        <ul>
          <li>
            <p>同一对象在不同应用中有不同抽象</p>

            <blockquote>
              <p>解决：遵守实体与属性的划分原则，把属性变为实体或实体变为属性，使同一对象具有相同的抽象。</p>
            </blockquote>
          </li>
          <li>
            <p>同一实体在不同分 E-R 图中属性个数、次序不同</p>

            <blockquote>
              <p>解决：同一实体的属性通常取分 E-R 图中属性的并，再适当调整次序</p>
            </blockquote>
          </li>
          <li>
            <p>实体之间的联系在不同分 E-R 图中呈现不同类型</p>

            <blockquote>
              <p>解决：根据语义加以综合或调整</p>
            </blockquote>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>修改和重构</strong></p>

    <p>消除不必要的冗余，生成<strong>基本 E-R 图</strong></p>

    <p><strong>消除冗余</strong></p>

    <ul>
      <li>分析法</li>
      <li>规范化方法
        <ol>
          <li>把 E-R 图中实体用符号表示</li>
          <li>把每一对 n:1、1:1 或 n:m 联系表示为实体码之间的函数依赖表达式 X $\rightarrow$ Y</li>
          <li>利用函数依赖集的最小覆盖算法进行极小化处理。</li>
          <li>考察 D 中每一个函数依赖表达式，确定是否为冗余联系</li>
          <li>去掉冗余联系后形成基本 E-R 图。</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h2 id="74-逻辑结构设计">7.4 逻辑结构设计</h2>

<p>逻辑结构设计的任务就是把概念结构转换为选用的 DBMS 所支持的数据模型的过程。</p>

<h3 id="过程">过程</h3>

<ol>
  <li>形成初始关系数据库模式</li>
  <li>关系模式规范化</li>
  <li>关系模式优化</li>
  <li>子模式定义</li>
</ol>

<h3 id="e-r-图向关系模型的转换规则">E-R 图向关系模型的转换规则</h3>

<ul>
  <li>一个实体型转换为一个关系模式。实体的属性就是关系的属性，实体的码就是关系的码。</li>
  <li>一个联系转换为一个关系模式。与该联系相连的各实体的码以及联系的属性转换为关系的属性：
    <ul>
      <li>若联系为 1:1，则每个关系的码均是该关系的候选码</li>
      <li>若联系为 1:n，则该关系的码是 n 端实体的码</li>
      <li>若联系为 n:m，则该关系的码是诸实体码的组合</li>
    </ul>
  </li>
  <li>三个或三个以上实体间的多元联系，转换为一个关系模式，与该多元联系相连的各实体的码以及联系的属性转换为关系的属性，而关系的码为各实体码的组合</li>
  <li>具有相同码的关系可以合并</li>
  <li>弱实体类型的转换
    <ul>
      <li>对于每个弱实体类型，创建一个新的关系，该关系中包含所有弱实体类型的属性。</li>
      <li>把标识关系（被依赖关系）的主码添加到新关系中，并将其作为新关系的外码</li>
      <li>新关系的主码是标识关系的主码和弱实体类型的部分标识（码）的组合</li>
    </ul>
  </li>
  <li>超类 / 子类联系的转换
    <ul>
      <li>为超类和每个子类创建单独的关系</li>
      <li>在超类所创建的关系中，包含所有子类成员都共有的属性，包括主码</li>
      <li>在超类中包含一个（或多个）属性作为子类判定符</li>
      <li>在为每个子类所创建的关系中，包含超类的主码以及子类特有的属性</li>
    </ul>
  </li>
</ul>

<h3 id="关系模型的规范化与优化">关系模型的规范化与优化</h3>

<h4 id="规范化">规范化</h4>

<ul>
  <li>按照数据依赖的理论，逐一分析转换所得关系模式，判断是否存在部分函数依赖、传递函数依赖、多值依赖等，确定它们的范式等级</li>
</ul>

<h4 id="优化">优化</h4>

<ul>
  <li>
    <p>按应用系统的处理要求，确定是否进行关系模式合并或分解</p>
  </li>
  <li>
    <p>为了提高存取效率和存储空间的利用率，可以对关系模式进行必要的分解</p>

    <ul>
      <li>
        <p><strong>水平分解</strong></p>

        <p>是把关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统效率</p>

        <ul>
          <li>
            <p>80/20 原则</p>

            <p>可以把经常使用的那一部分数据分解出来作为一个关系，其他数据作为另一个关系</p>
          </li>
          <li>
            <p>数据分片</p>

            <p>如果关系 R 上具有 n 个事务，而且大多数事务存取的数据不相交，则 R 可以分解为少于或等于 n 个子关系。</p>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>垂直分解</strong></p>

        <p>是把关系模式 R 的属性分解为若干子集合，形成若干子关系模式，</p>

        <ul>
          <li>垂直分解的原则是，经常在一起使用的属性从 R 中分解出来形成一个子关系模式</li>
          <li>垂直分解必须确保无损连接性和保持函数依赖。</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="75-物理结构设计">7.5 物理结构设计</h2>

<h3 id="确定数据库的存储结构">确定数据库的存储结构</h3>

<ul>
  <li>确定存放位置
    <ul>
      <li>经常存取部分和存取频率较低部分分开存放</li>
      <li>数据和日志备份放于不同的磁盘上</li>
    </ul>
  </li>
  <li>确定系统配置
    <ul>
      <li>确定系统配置变量、存储分配参数，进行物理优化</li>
    </ul>
  </li>
</ul>

<h3 id="选择关系的存取方法">选择关系的存取方法</h3>

<blockquote>
  <p>存取方法是使事务能够快速存取数据库中数据的技术</p>
</blockquote>

<h4 id="索引方法">索引方法</h4>

<ul>
  <li>基本概念
    <ul>
      <li>为了加速所需数据的访问</li>
      <li><strong>索引记录 / 索引项</strong>，是索引文件的记录，包括两个域：
        <ul>
          <li><strong>索引域</strong>：存储数据文件中一个或一组域的一个值</li>
          <li><strong>指针</strong>：指向索引域值为 K 的记录所在磁盘块的地址</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>常用 B+ 树索引</li>
  <li>索引存取方法的选择
    <ul>
      <li>选择索引域原则
        <ul>
          <li>经常在查询条件中出现的属性</li>
          <li>经常作为最大值和最小值库函数的参数</li>
          <li>经常作为连接属性</li>
        </ul>
      </li>
      <li>索引并非越多越好</li>
    </ul>
  </li>
</ul>

<h4 id="聚集方法">聚集方法</h4>

<ul>
  <li>基本概念
    <ul>
      <li>把关系中某个属性 / 组（聚集键）值相同的记录集中存放在连续的物理块，称为<strong>聚集</strong>。能够提高该属性的查询速度。</li>
    </ul>
  </li>
  <li>一个关系只能参加一个聚集</li>
  <li>一般原则
    <ul>
      <li>经常进行连接操作的关系可以建立聚集</li>
      <li>单个关系的某组属性经常进行相等比较</li>
      <li>关系的某个属性组值重复率高</li>
    </ul>
  </li>
  <li>注意问题
    <ul>
      <li>建立和维护聚集系统开销很大，对于更新操作远远多余连接操作的关系不应该使用聚集方法。</li>
    </ul>
  </li>
</ul>

<h4 id="hash-方法">HASH 方法</h4>

<ul>
  <li>一种支持快速存取的文件存储方法</li>
  <li>基本概念
    <ul>
      <li>通过 HASH 函数将记录关键字转换成地址</li>
    </ul>
  </li>
  <li>如果关系的属性主要出现在等连接条件中，或出现在相等比较条件中，而且满足以下条件之一，可以选择该方法：
    <ul>
      <li>关系的大小可预知，而且不变</li>
      <li>如果关系大小动态改变，则徐 DBMS 提供动态 HASH 存取方法。</li>
    </ul>
  </li>
</ul>

<h1 id="第六章-存储管理和索引">第六章 存储管理和索引</h1>

<h2 id="存储体系结构">存储体系结构</h2>

<blockquote>
  <ul>
    <li>数据只有被放入<strong>内存</strong>才能被处理</li>
    <li>DBMS 设定数据库的基本存储是在磁盘上，DBMS 的组件管理内存与外存数据的交换</li>
  </ul>
</blockquote>

<ul>
  <li>
    <p>DBMS 存储管理的目标</p>

    <p>最小化磁盘和主存间传输存储块的数量，即最小化磁盘存取次数</p>
  </li>
</ul>

<h3 id="磁盘">磁盘</h3>

<h4 id="结构">结构</h4>

<p><strong>磁盘块</strong>由若干个扇区组成，是<strong>存储分配和检索的逻辑单元</strong>，大小一般在 4k-16k 之间，数据以<strong>块</strong>为单位在磁盘和主存之间传输。页面 (page) 通常指块。</p>

<h4 id="访问时间">访问时间</h4>

<ul>
  <li>
    <p><strong>寻道时间</strong></p>

    <p>磁盘臂定位时间</p>
  </li>
  <li>
    <p><strong>旋转时间</strong></p>

    <p>等待被访问的扇区出现在读写头下方的时间</p>
  </li>
  <li>
    <p><strong>传输时间</strong></p>

    <p>从磁盘读取数据或向磁盘存储数据的时间</p>
  </li>
</ul>

<h3 id="存储管理系统">存储管理系统</h3>

<ul>
  <li>
    <p>数据库 - 文件 - 块 / 页</p>

    <ul>
      <li>
        <p><strong>数据库</strong></p>

        <p>由若干文件组成，这些文件采用专有的格式。操作系统不能获取这些文件内容的任何信息</p>
      </li>
      <li>
        <p><strong>文件</strong></p>

        <p>由若干个定长的存储单元 / 存储块 / 页构成</p>
      </li>
      <li>
        <p><strong>块 / 页</strong></p>

        <p>存储分配和数据传输的单位</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="数据库的物理结构">数据库的物理结构</h3>

<ul>
  <li>
    <p>数据库中的<strong>表</strong>被映射为底层存储中的<strong>文件</strong></p>
  </li>
  <li>
    <p>一个<strong>文件</strong>在逻辑上被组织为<strong>记录</strong>的序列，记录被映射到<strong>磁盘块</strong>上</p>
  </li>
  <li>
    <p><strong>文件</strong>在存储中由若干<strong>磁盘块</strong>构成，<strong>块是存储分配和数据传输的单位</strong></p>
  </li>
  <li>
    <p>一个<strong>块</strong>可以包含几个<strong>记录</strong>，每条<strong>记录</strong>被完全包含在单个块中</p>
  </li>
  <li>
    <p>表所占磁盘块的分配方法</p>

    <ul>
      <li>
        <p><strong>连续分配</strong></p>

        <p>数据被分配到连续的磁盘块上</p>
      </li>
      <li>
        <p><strong>链接分配</strong></p>

        <p>数据块中包含指向下个数据块的指针</p>
      </li>
      <li>
        <p><strong>按簇分配</strong></p>

        <p>簇是连续的几个磁盘块，簇之间用指针连接</p>
      </li>
      <li>
        <p><strong>索引分配</strong></p>

        <p>索引块中存放指向数据块的指针</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="数据库页--磁盘块">数据库页 / 磁盘块</h4>

<p>页是固定大小的数据块</p>

<ul>
  <li>每个页有唯一的标识符 (ID)，DBMS 将页 ID 映射为页的物理位置</li>
  <li>每个页由头部 Header 和数据组成
    <ul>
      <li>Header 包含了页中的元数据，如页大小、Checksum、DBMS 版本等</li>
    </ul>
  </li>
</ul>

<h5 id="分槽-slot-页结构">分槽 (slot) 页结构</h5>

<ul>
  <li>Header 记录了已使用的槽数，以及最后一个被使用槽的起始位置偏移量，以及一个槽数组</li>
  <li>槽数组保存了每个元组的起始位置偏移量</li>
  <li>增加记录时，槽数组从开始到尾部的方向增长，而记录数据则从数据区的尾部到开始的方向增长。当槽数组与元组数据连接到一起时，认为页满</li>
  <li>便于存储变长记录</li>
</ul>

<h4 id="数据库记录">数据库记录</h4>

<p>记录是字节序列，DBMS 负责将该序列解释为属性类型和值</p>

<ul>
  <li>
    <p><strong>记录头部</strong></p>

    <p>包含元组的元数据，例如加锁信息等</p>
  </li>
  <li>
    <p><strong>记录数据</strong></p>

    <p>属性的实际数据。属性一般按表定义中的顺序存储。多数 DBMS 不允许一个记录大小超过一个页</p>
  </li>
  <li>
    <p><strong>唯一标识符 ID</strong></p>

    <ul>
      <li>每个记录被分配了一个 ID</li>
      <li>最常见的形式：页 ID+ (offset 或槽)</li>
      <li>应用程序不能依赖该 ID 进行唯一性标识</li>
    </ul>
  </li>
</ul>

<p><strong>文件中记录的组织方式</strong></p>

<ul>
  <li>
    <p><strong>堆</strong>(Heap)：记录可以存放在文件空间中的任何位置</p>

    <ul>
      <li>
        <p><strong>链表方式</strong></p>

        <p>在文件开始维护一个 header 页，该页存储了空白页链表头指针和数据页链表头指针，每个页记录了当前包含的空槽数</p>
      </li>
      <li>
        <p><strong>页目录方式</strong></p>

        <p>DBMS 维护特殊页保存文件中的数据页的位置，并记录每个页中空槽数</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>顺序</strong>(Sequential)：基于每个记录的搜索码值顺序排列</p>

    <ul>
      <li>文件中记录按搜索码排序。<strong>搜索码</strong>可以是任意属性或属性集合</li>
      <li>通过指针把记录链接起来，每个记录的指针指向按搜索码排列的下一条记录</li>
      <li>可以高效的按某个搜索码处理记录</li>
    </ul>
  </li>
  <li>
    <p><strong>索引</strong>(Indexing)：按某种顺序有序存储</p>
  </li>
  <li>
    <p><strong>散列</strong> (Hashing)：在搜索码上的 hash 函数，计算出记录在文件中存放的块</p>
  </li>
  <li>
    <p><strong>聚集</strong>(Clustering)：将有联系的记录存储在同一个块上，以最小化 I/O 次数</p>

    <ul>
      <li>具有相同或相似属性值的记录存储于连续的磁盘块中</li>
      <li><strong>聚集码</strong>是一种属性，它定义了哪些记录被存储在一起</li>
      <li>多表聚集：将多个关系存储于一个文件中，在每个块中存储两个或更多关系的相关记录，可以加快特定的连接查询，但会使单个表的访问变慢</li>
    </ul>
  </li>
</ul>

<h4 id="缓存管理系统">缓存管理系统</h4>

<ul>
  <li>块 / 页是存储分配和数据交换的单位</li>
  <li>管理目标：最小化磁盘和主存间传输存储块的数量，即最小化磁盘存取次数；实现手段是在主存中保持尽量多的块</li>
  <li><strong>缓冲区</strong>：是主存中可以存储磁盘块副本的区域</li>
  <li><strong>缓存管理器</strong>：负责缓存空间分配，内外存交换</li>
</ul>

<h5 id="缓冲区组织与管理">缓冲区组织与管理</h5>

<ul>
  <li>缓冲区被组织为一个固定大小的页面数组，每个元素称为帧，存放磁盘上的一个页 / 块</li>
  <li>缓冲区元数据——页表 (page table)，跟踪当前内存中的所有页，并保存了每个页的元数据，包括
    <ul>
      <li>Dirty Flag：由修改页的线程设置，通知存储管理器该页必须写回磁盘</li>
      <li>Pin / Reference 计数器：在一页被进程读写操作前要钉住 (Pin)，方式该页被移出，操作结束后解除钉（计数器减 1），只有计数器 = 0 时，才能被移出或写回磁盘</li>
    </ul>
  </li>
  <li>缓冲区的共享锁与排它锁
    <ul>
      <li>缓冲区管理器提供封锁系统，允许数据库进程以共享或排他模式封锁页，在完成操作后释放封锁</li>
      <li>实现并发控制，读操作加共享锁，更新操作加排他锁</li>
      <li>加锁规则：一次只能由一个进程获得排它锁，共享锁与排它锁不能同时加，多个进程可以同时持有共享锁</li>
    </ul>
  </li>
  <li>缓冲区替换策略
    <ul>
      <li>最近最少使用 (LRU, Least Recently Used) 策略及其改进算法</li>
    </ul>
  </li>
</ul>

<h4 id="索引">索引</h4>

<h5 id="基本概念">基本概念</h5>

<ul>
  <li>索引文件构成
    <ul>
      <li>索引记录 / 索引项，是索引文件的记录，包括两个域：
        <ul>
          <li>索引域（搜索码）：存储数据文件中一个或一组域（属性）</li>
          <li>指针：指向索引域值为 K 的记录所在磁盘块的地址</li>
        </ul>
      </li>
      <li>索引将表中的部分属性进行组织或排序，使得利用这些属性能够快速有效进行表的访问</li>
      <li>DBMS 负责在执行查询时使用最恰当的索引</li>
    </ul>
  </li>
</ul>

<h5 id="索引的分类">索引的分类</h5>

<ul>
  <li>
    <p>基本类型</p>

    <ul>
      <li>
        <p><strong>排序索引</strong></p>

        <p>索引项是排序的</p>
      </li>
      <li>
        <p><strong>哈希索引</strong></p>

        <p>索引项使用索引域上的 hash 函数确定位置</p>
      </li>
    </ul>
  </li>
  <li>
    <p>聚集索引与非聚集索引</p>

    <ul>
      <li>
        <p><strong>聚集索引</strong></p>

        <p>索引项值排列顺序与记录在文件中的排列顺序一致，也成为<strong>主索引</strong></p>
      </li>
      <li>
        <p><strong>非聚集索引</strong></p>

        <p>索引项指定的次序与文件中记录的排列顺序不同，也称为<strong>辅助索引</strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p>稠密索引与稀疏索引</p>

    <ul>
      <li>
        <p><strong>稠密索引</strong></p>

        <p>对文件中的每个搜索码值都有一个索引项</p>
      </li>
      <li>
        <p><strong>稀疏索引</strong></p>

        <p>只有部分索引域值有索引记录，当文件记录以索引域排序时，可以采用</p>
      </li>
    </ul>

    <blockquote>
      <p>相比稠密索引，稀疏索引占空间小且维护代价低，但定位记录慢。非聚集索引都是稠密索引</p>
    </blockquote>
  </li>
</ul>

<h5 id="多级索引">多级索引</h5>

<ul>
  <li>对索引文件建立稀疏索引
    <ul>
      <li>外层索引：基本索引的稀疏索引</li>
      <li>内层索引：基本索引文件</li>
    </ul>
  </li>
  <li>
    <p>二叉树索引</p>
  </li>
  <li>
    <p>多枝树索引</p>
  </li>
  <li>
    <p><strong>B 树（平衡树）索引</strong></p>

    <ul>
      <li>是附加限制条件的索引树。限制了每个节点放置关键字与指针的最小和最大个数：根节点有 [2, n] 个子节点，中间节点有 [n/2, n] 个子结点，叶节点有 [n/2, n-1] 个记录指针，n 值对于特定树是固定的。
        <ul>
          <li>从树根到叶节点每条路径的长度都相同，因此所有的叶结点都在同一层上</li>
          <li>B 树的关键字是散布在各层上</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>B+ 树</strong></p>

    <ul>
      <li>是 B 树的改进，把树中所有关键字都按递增次序从左到右安排在节点上，并且链接起来。B+ 树能同时进行随机查找和顺序查找。</li>
      <li>节点结构
        <ul>
          <li>每个节点最多包含 n-1 个搜索码 / 索引码值 $K_1, K_2, …, K_{n-1}$，以及 n 个指针 $P_1, P_2, …, P_n$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Hash 索引</strong></p>

    <ul>
      <li>
        <p>基于哈希表 (Hash Table) 实现</p>
      </li>
      <li>
        <p>哈希表实现 key 到 value 的映射。通过键值映射到表中一个位置来访问记录，这个映射函数叫做 Hash 函数，存放记录的数组叫做哈希表。</p>
      </li>
      <li>
        <p><strong>哈希表</strong></p>

        <ul>
          <li>
            <p><strong>哈希函数</strong></p>

            <p>将很大的 key 空间映射到比较小的域，用于计算桶 / 槽数组的元素符号；非用于加密算法的哈希函数，计算速度快且碰撞率低</p>
          </li>
          <li>
            <p><strong>哈希方案</strong> (scheme)</p>

            <p>解决一个哈希值对应多条记录。最长使用溢出链接 (Chaining) 法</p>
          </li>
        </ul>
      </li>
      <li>
        <p>分类</p>

        <ul>
          <li><strong>静态哈希</strong>：哈希表的大小是固定的
            <ul>
              <li>文件增大时，太多的溢出桶将降低访问性能</li>
              <li>数据规模缩小时，会造成空间浪费</li>
            </ul>
          </li>
          <li><strong>动态哈希</strong>：允许哈希表的大小动态修改
            <ul>
              <li>定期重哈希：创建新的大的哈希表，把原表上的 key 重新哈希到新表上</li>
              <li>线性哈希：以一种递增的方式重新哈希</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="第七章-关系查询处理与查询优化">第七章 关系查询处理与查询优化</h1>

<h2 id="关系查询处理步骤">关系查询处理步骤</h2>

<h3 id="1-查询分析">1. 查询分析</h3>

<ul>
  <li>词法分析</li>
  <li>SQL 语法检查和语法分析</li>
</ul>

<h3 id="2-查询检查">2. 查询检查</h3>

<ul>
  <li>语义检查</li>
  <li>存取权限检查</li>
  <li>SQL 语句转换为关系代数表达式（查询树 / 语法分析树）</li>
</ul>

<h3 id="3-查询优化">3. 查询优化</h3>

<ul>
  <li>选择一个高效执行的查询处理策略</li>
  <li>生成查询计划</li>
</ul>

<h3 id="4-查询执行">4. 查询执行</h3>

<ul>
  <li>生成查询计划的代码</li>
  <li>代码执行</li>
</ul>

<h2 id="查询代价的度量">查询代价的度量</h2>

<p>假设存取一个块就需要进行一次磁盘访问，使用<strong>访问磁盘的块数</strong>作为估计代价的因素</p>

<h2 id="查询操作的实现">查询操作的实现</h2>

<h3 id="选择运算实现算法">选择运算实现算法</h3>

<ul>
  <li>
    <p><strong>全表扫描法</strong></p>

    <p>按照物理顺序读表的 M 块到内存，检查内存的每个元组 t，如果满足条件则输出 t，直到表所有块都经过上述检查</p>
  </li>
  <li>
    <p><strong>索引扫描法</strong></p>

    <p>如果在选择条件的属性上有索引，先通过索引找到目标索引项，再通过索引项找到元组</p>
  </li>
</ul>

<h3 id="连接运算实现算法">连接运算实现算法</h3>

<h4 id="嵌套循环法">嵌套—循环法</h4>

<ul>
  <li>
    <p>两个连接的表，第一个表为外循环，另一个为内循环。</p>
  </li>
  <li>
    <p>连接运算 $r \bowtie _{\theta} s$ 的实现算法，$r$ 是外循环表，$s$ 是内循环表</p>

    <p><img src="/assets/images/post/forfor.png" alt="" /></p>
  </li>
  <li>
    <p>不需要索引，并使用于任何连接条件</p>
  </li>
  <li>
    <p>需要检查两个关系中的每一对元组，代价高</p>
  </li>
  <li>
    <p>如果连接操作使用的缓冲区的块数为 k，分配 (k-1) 块给外表 r，1 块给内表 s，则存取块数为：$b_r+\frac{b_r}{k-1}\times b_s$，其中 $b_r$ 为表 r 的块数，$b_s$ 为表 s 的块数</p>
  </li>
  <li>
    <p>应选择较小的表作为外表</p>
  </li>
</ul>

<h4 id="索引连接法">索引连接法</h4>

<p>第二个表按照连接属性建索引，取第一个表元组的连接属性与第二个表元组的连接属性比较。</p>

<ul>
  <li>如果内层关系 s 的连接属性上有索引，则对于外层关系 r 中的每一个元组 $t_r$，可以用索引查找 s 中与 $t_r$ 满足连接条件的元组</li>
  <li>如果 r 和 s 在连接属性上都有索引，则以元组较少的关系作为外层关系，代价最小</li>
</ul>

<h4 id="排序合并法">排序—合并法</h4>

<p>两个表都按照连接属性排序，取第一个表元组的连接属性与第二个表元组的连接属性比较。</p>

<ol>
  <li>将两个关系在连接属性上排序</li>
  <li>为每个关系分配一个指针，分别为 $p_r$ 和 $p_s$，对于 $p_r$ 指向 r 的一个连接属性值，移动 $p_s$ 找到 s 中与该值相等的元组，与 $p_r$ 指向的元组做连接，如此移动两个指针分别遍历 r 和 s</li>
</ol>

<ul>
  <li>两个关系的每个块都只需要读一次，访问块数 = $b_r$ + $b_s$</li>
  <li>只能用于等值连接或自然连接</li>
</ul>

<h4 id="hash-join-法">Hash Join 法</h4>

<p>连接属性作为 hash 码，用同一个 hash 函数把两个连接表的元组散列到同一个 hash 文件。</p>

<ol>
  <li>哈希函数 h 用于划分两个关系，h 将连接属性值映射到 {0, 1, …, n} 集合上。将 r 的元组划分为 $r_0, r_1, …, r_n$ 个部分，如果 h($t_r$[JoinAttrs])=i，则元组 $t_r$ 将被放入 $r_i$，同理将 s 页划分成 $s_0, s_1, …, s_n$ 个部分</li>
  <li>对于某个连接属性值，若被哈希为 i，则 s 中相应的元组必定在 $s_i$ 中，而 r 中的元组必定在 $r_i$ 中，因此只需要将 $s_i$ 和 $r_i$ 中的元组相比较</li>
</ol>

<p>适用于等值连接或自然连接</p>

<h3 id="排序">排序</h3>

<ul>
  <li>内存中完全容纳的关系，可采用快速排序 (quicksort) 法等算法</li>
  <li>内存无法容纳的关系，可采用<strong>外排序-归并</strong>算法</li>
</ul>

<h4 id="外排序-归并">外排序-归并</h4>

<ol>
  <li>建立多个排序好的归并段 (run)，每个段仅包含关系的部分记录</li>
  <li>对归并段进行归并</li>
</ol>

<h3 id="其他运算">其他运算</h3>

<ul>
  <li>
    <p><strong>去重</strong></p>

    <p>使重复数据向相邻，保留一个数据删除其它</p>

    <ul>
      <li>排序方法</li>
      <li>哈希方法</li>
    </ul>
  </li>
  <li>
    <p><strong>投影</strong></p>

    <p>在每个元组上执行投影，之后再去重</p>
  </li>
  <li>
    <p><strong>集合运算——并、交、差</strong></p>

    <ul>
      <li>类似排序-合并连接，排序然后对每个已排序的关系扫描一次</li>
      <li>类似 hash-join 将两个关系分区，再两个关系对应区中执行运算</li>
    </ul>
  </li>
  <li>
    <p><strong>库函数</strong></p>

    <p>基于分组属性进行排序或散列以聚集同组的元组，再执行库函数</p>
  </li>
</ul>

<h3 id="表达式的执行">表达式的执行</h3>

<p>可选方法包括物化 (materialized) 方法和流水线 (pipeline) 方法</p>

<h4 id="物化方法">物化方法</h4>

<ul>
  <li>按次序每次只执行一个运算，运算结构被物化到一个临时关系中，这些临时关系一般需要写到磁盘上</li>
  <li>方法适用性广泛，但临时表的写和读代价大</li>
</ul>

<h4 id="流水线方法">流水线方法</h4>

<ul>
  <li>同时执行多个运算，将结果传递给下一个运算</li>
  <li>不需要在磁盘上存储临时关系，代价小，但对有些运算不适用，如排序等</li>
</ul>

<h2 id="查询优化">查询优化</h2>

<blockquote>
  <p><strong>查询优化目标</strong>：选择一个高效执行的查询处理策略，使得查询代价最小，即发个文磁盘的块数最少</p>
</blockquote>

<h4 id="分类">分类</h4>

<h5 id="代数优化">代数优化</h5>

<p>关系代数表达式的优化，即按照一定的规则，改变代数表达式中操作的次序和组合</p>

<h5 id="物理优化">物理优化</h5>

<p>存取路径和底层操作算法的选择。包括基于规则或基于代价等</p>

<h4 id="查询优化的结果">查询优化的结果</h4>

<p><strong>查询计划</strong>：定义了每个操作的算法以及这些操作执行的顺序</p>

<h4 id="代数优化-1">代数优化</h4>

<p>通过对关系代数表达式的等价变化来提高查询效率</p>

<ul>
  <li>
    <p>关系代数表达式的<strong>等价</strong></p>

    <p>指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的</p>
  </li>
</ul>

<h5 id="关系代数表达式等价变换规则">关系代数表达式等价变换规则</h5>

<ol>
  <li>
    <p>连接、笛卡尔积交换律
$$
E_1 \times E_2 = E_2 \times E_1 <br />
E_1 \bowtie E_2 = E_2 \bowtie E_1 \\ 
E_1 \underset{F}{\bowtie} E_2 = E_2 \underset{F}{\bowtie} E_1
$$</p>
  </li>
  <li>
    <p>连接、笛卡尔积的结合律
$$
(E_1\times E_2)\times E_3 = E_1\times (E_2\times E_3)<br />
(E_1\bowtie E_2)\bowtie E_3=E_1 \bowtie (E_2\bowtie E_3) <br />
(E_1\underset{F_1}{\bowtie} E_2)\underset{F_2}{\bowtie} E_3 = E_1\underset{F_1}{\bowtie}(E_2\underset{F_2}{\bowtie}E_3)
$$</p>
  </li>
  <li>
    <p>投影的串联定理
$$
\Pi_{A_1, A_2,…,A_n}(\Pi_{B_1,B_2,…,B_m}(E)) = \Pi_{A_1, A_2,…,A_n}(E)
$$</p>
  </li>
  <li>
    <p>选择的串联定律
$$
\sigma_{F_1}(\sigma_{F_2}(E)) = \sigma_{F_1\wedge F_2}(E)
$$</p>
  </li>
  <li>
    <p>选择与投影的交换律
$$
\sigma_{F_1}(\Pi_{A_1, A_2, …, A_n}(E)) = \Pi_{A_1, A_2,…,A_n}(\sigma_F(E))
$$</p>
  </li>
  <li>
    <p>选择与笛卡尔积交换律</p>

    <ul>
      <li>
        <p>$F$ 中只有 $E_1$ 的属性</p>
      </li>
      <li>
        <p>$F=F_1\wedge F_2$，且 $F_1$ 只有 $E_1$ 的属性，$F_2$ 中只有 $E_2$ 的属性</p>

        <p>$\sigma_F{E_1\times E_2}=\sigma_{F_1}(E_1)\times \sigma_{F_2}(E_2)$</p>
      </li>
      <li>
        <p>$F_1$ 只有 $E_1$ 的属性，$F_2$ 有 $E_1$ 和 $E_2$ 的属性</p>

        <p>$\sigma_F(E_1\times E_2)=\sigma_{F_2}(\sigma_{F_1}(E_1)\times E_2)$</p>
      </li>
    </ul>
  </li>
  <li>
    <p>选择与并的分配律</p>

    <p>$\sigma_F(E_1\cup E_2)=\sigma_F(E_1)\cup \sigma_F(E_2)$</p>
  </li>
  <li>
    <p>选择与差的分配律</p>

    <p>$\sigma_F(E_1-E_2)=\sigma_F(E_1)-\sigma_F(E_2)$</p>
  </li>
  <li>
    <p>选择对自然连接的分配律</p>

    <p>$\sigma_F(E_1\bowtie E_2)=\sigma_F(E_1)\bowtie\sigma_F(E_2)$</p>
  </li>
  <li>
    <p>投影与笛卡尔积的分配律</p>

    <p>$\Pi_{A_1, A_2,…,A_n,B_1,B_2,…,B_m}(E_1\times E_2)=\Pi_{A_1,A_2,…,A_n}(E_1)\times \Pi_{B_1,B_2,..,B_m}(E_2)$</p>
  </li>
  <li>
    <p>投影与并的分配律</p>

    <p>$\Pi_{A_1,A_2,…,A_n}(E_1\cup E_2)=\Pi_{A_1,A_2,…,A_n}(E_1)\cup\Pi_{A_1, A_2,…,A_n}(E_2)$</p>
  </li>
</ol>

<h5 id="查询树">查询树</h5>

<p>查询树的关系代数表达式的树形表示</p>

<ul>
  <li>操作的关系位于叶结点</li>
  <li>关系运算位于内部节点</li>
  <li>执行方式：自底向上执行，当一个内部节点的操作分量可用时，该节点的操作启动执行，执行结束后用结果关系代替该节点</li>
</ul>

<h5 id="查询树的构造">查询树的构造</h5>

<ul>
  <li>将 SQL 语句转换为关系代数表达式
    <ul>
      <li>SELECT 子句对应投影操作</li>
      <li>FROM 子句对应笛卡尔积</li>
      <li>WHERE 子句对应选择操作</li>
    </ul>
  </li>
  <li>将关系代数表达式转换为查询树</li>
</ul>

<h5 id="查询树的启发式优化优化的一般准则">查询树的启发式优化（优化的一般准则）</h5>

<ul>
  <li><strong>选择运算尽早执行</strong>。是优化策略中最重要，最基本的一条（减少中间关系-减少元组数据）</li>
  <li><strong>投影运算尽早执行</strong>（减小中间关系-减少属性数目）</li>
  <li>把投影运算和选择运算同时进行；把投影同其前或其后的双目运算结合起来（减少扫描关系的次数）</li>
  <li>把某些选择同在它前面要执行的笛卡尔积结合起来称为一个连接运算（把笛卡尔积与选择转换为连接）</li>
  <li>找出公共子表达式，把公共子表达式的结果写入中间文件，重复使用。（中间结果复用）</li>
</ul>

<h3 id="物理优化-1">物理优化</h3>

<ul>
  <li>选择高效合理的操作算法或存取路径，得到优化的查询计划</li>
  <li>查用方法
    <ul>
      <li>基于规则的启发式优化算法</li>
      <li>基于代价估算的优化算法</li>
      <li>两者结合的优化算法</li>
    </ul>
  </li>
</ul>

<h4 id="基于启发式规则的存取路径选择优化">基于启发式规则的存取路径选择优化</h4>

<h5 id="选择操作的启发式规则">选择操作的启发式规则</h5>

<ul>
  <li>对于小关系，使用全表顺序扫描</li>
  <li>对于大关系：可以采用索引扫描法（如结果的元组数目较小），全表顺序扫描</li>
</ul>

<h5 id="连接关系的启发式规则">连接关系的启发式规则</h5>

<ul>
  <li>如果两个表都已经按照连接属性排序——排序-合并法</li>
  <li>如果一个表在连接属性上有索引——索引连接法</li>
  <li>如果连接属性上未排序且未建索引，且其中一个表较小——Hash Join 法</li>
  <li>最后可选用嵌套循环法，并选择较小的表作为外循环表</li>
</ul>

<h3 id="查询优化的一般步骤">查询优化的一般步骤</h3>

<ol>
  <li>把查询转换成语法树，如关系代数语法树</li>
  <li>把语法树利用代数优化转换成优化后的标准形式</li>
  <li>利用基于启发式规则的物理优化，选择底层的存取路径。生成查询计划，利用基于代价的物理优化，选择代价最小的</li>
</ol>

<h1 id="第八章-事务处理技术">第八章 事务处理技术</h1>

<h2 id="事务">事务</h2>

<h3 id="定义-3">定义</h3>

<p><strong>事务</strong> (Transaction) 是用户定义的数据库操作序列，这些操作要么都做，要么都不做，是一个不可分割的工作单位。</p>

<h3 id="特性">特性</h3>

<h4 id="原子性-atomicity">原子性 (Atomicity)</h4>

<p>事务中包括的所有操作要么都做，要么都不做</p>

<h4 id="一致性-consistency">一致性 (Consistency)</h4>

<p>事务执行的结果必须是使数据库从一个一致性状态，变到另一个一致性状态</p>

<h4 id="隔离性-isolation">隔离性 (Isolation)</h4>

<p>一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰</p>

<h4 id="持久性-durability">持久性 (Durability)</h4>

<p>一个事务一旦提交之后，它对数据库的映像必须是永久的。其它操作或故障不应该对其执行结果有任何影响</p>

<ul>
  <li>事务的 <strong>ACID</strong> 特性对于数据库数据的正确、有效具有重要意义。但事务的特性有可能遭破坏，主要有两种情况：
    <ul>
      <li>多个事务并行运行时，不同事物的操作交叉进行</li>
      <li>事物在运行过程中被强行停止</li>
    </ul>
  </li>
  <li>利用数据库<strong>并发控制</strong>机制以及数据库<strong>恢复</strong>机制保证事物的特性不被破坏，从而保证数据库数据的正确、有效
    <ul>
      <li>原子性由恢复机制实现</li>
      <li>一致性是由事物的原子性保证的</li>
      <li>隔离性通过并发控制机制实现</li>
      <li>持久性通过恢复机制实现</li>
    </ul>
  </li>
  <li><strong>事务是数据库恢复和并发控制的基本单位</strong></li>
  <li>事务的开始与结束可以由用户<strong>显式</strong>控制。如果用户没有显式定义事务，则由 DBMS 按缺省规定自动划分事务。</li>
  <li>事务与应用程序是两个概念，一般来说，一个应用程序可以包含多个事务</li>
</ul>

<h3 id="sql-中事务的定义">SQL 中事务的定义</h3>

<h4 id="事务开始">事务开始</h4>

<p><code class="language-plaintext highlighter-rouge">BEGIN TRANSACTION</code></p>

<h4 id="事务结束">事务结束</h4>

<h5 id="正常结束">正常结束</h5>

<p>提交事务，正常结束</p>

<p><code class="language-plaintext highlighter-rouge">COMMIT</code></p>

<h5 id="非正常结束">非正常结束</h5>

<p>撤销全部更新，回滚到事务开始时状态。非正常结束</p>

<p><code class="language-plaintext highlighter-rouge">ROLLBACK</code></p>

<h2 id="数据库恢复技术">数据库恢复技术</h2>

<h3 id="定义-4">定义</h3>

<p>数据库管理系统必须具有把数据库<strong>从错误状态恢复到某一已知正确状态</strong>的功能，这就是数据库的恢复</p>

<h3 id="方法">方法</h3>

<p>数据库恢复是通过数据库管理系统的恢复子系统完成的</p>

<p>数据库恢复的基本原理为<strong>冗余</strong>。即利用存储在系统别处的冗余数据来重建或恢复修正数据库</p>

<h3 id="意义">意义</h3>

<ul>
  <li><strong>保证事务的原子性</strong>。实现事务非正常终止时的回滚</li>
  <li>当<strong>系统发生故障</strong>以后，数据库能够恢复到正确状态</li>
</ul>

<h3 id="故障">故障</h3>

<h4 id="种类">种类</h4>

<h5 id="事务内部的故障">事务内部的故障</h5>

<ul>
  <li><strong>可预期的</strong>：事务根据内部的测试条件，确定是否回滚</li>
  <li><strong>不可预期的</strong>：指不能由应用程序处理的事务故障，如死锁、运算溢出，违反完整性规则等</li>
</ul>

<h5 id="系统故障">系统故障</h5>

<ul>
  <li>是指<strong>造成系统停止运行</strong>的任何事情，使得系统要重新启动，如硬件错误，操作系统故障，停电等。</li>
  <li>这类故障打断所有正在运行的事务，使事务都异常中止，但<strong>不会破坏数据库</strong></li>
</ul>

<h5 id="介质故障">介质故障</h5>

<ul>
  <li>介质故障指外存故障，如磁盘损坏，瞬时强磁场干扰等</li>
  <li>这类故障将<strong>破坏全部或部分数据库</strong>，并<strong>影响正在存取这部分数据的所有事务</strong></li>
</ul>

<h5 id="计算机病毒">计算机病毒</h5>

<ul>
  <li>计算机病毒是一种人为的破坏或故障，已成为数据库系统的主要威胁之一</li>
  <li>多数病毒<strong>对数据进行非法修改</strong></li>
</ul>

<h2 id="数据转储">数据转储</h2>

<h3 id="定义-5">定义</h3>

<p>是 DBA 定期的将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本成为<strong>后备副本或后援副本</strong></p>

<h3 id="分类-1">分类</h3>

<h4 id="静态转储">静态转储</h4>

<h5 id="定义-6">定义</h5>

<p>系统中无事务进行时进行的转储操作。并在转储过程中，不允许对数据库进行任何读取，修改。</p>

<h5 id="优点">优点</h5>

<p>保证副本的数据一致性</p>

<h5 id="缺点">缺点</h5>

<p>由于转储必须等待正在运行的事务结束才能开始，而新的事物必须等待转储结束才能进行，降低了数据库的可用性</p>

<h4 id="动态转储">动态转储</h4>

<h5 id="定义-7">定义</h5>

<p>转储期间允许对数据库进行存取或修改</p>

<h5 id="优点-1">优点</h5>

<p>不影响数据的可用性</p>

<h5 id="缺点-1">缺点</h5>

<p>不能保证副本上的数据正确，有效。还必须把转储期间各事物对数据库的修改记录下来，建立<strong>日志文件</strong>。后援副本加上日志文件就能把数据库恢复到某一时刻的正确状态。</p>

<h3 id="转储方式">转储方式</h3>

<h4 id="海量转储">海量转储</h4>

<p>海量转储指每次转储全部数据库</p>

<h4 id="增量转储">增量转储</h4>

<p>增量转储指每次只转储上一次转储后更新过的数据</p>

<h2 id="日志文件的建立与使用">日志文件的建立与使用</h2>

<h3 id="定义-8">定义</h3>

<p>日志是用来<strong>记录事务对数据库更新操作</strong>的文件。</p>

<h3 id="格式">格式</h3>

<h4 id="以记录为单位">以记录为单位</h4>

<ul>
  <li>记载的内容
    <ul>
      <li>各个事务的开始标记</li>
      <li>各个事务的结束标记</li>
      <li>各个事务的所有更新操作</li>
    </ul>
  </li>
  <li>每个日志记录中包含的信息项
    <ul>
      <li>事务标识（标明是哪个事务）</li>
      <li>操作的类型（输入、删除或修改）</li>
      <li>操作对象（记录的内部标识）</li>
      <li>更新前数据的旧值（对插入操作，此项为空）</li>
      <li>更新后数据的新值（对删除操作，此项为空）</li>
    </ul>
  </li>
</ul>

<h4 id="以数据块为单位">以数据块为单位</h4>

<p>日志记录的内容包括事务标识以及更新前和更新后的数据块</p>

<h3 id="作用">作用</h3>

<ul>
  <li><strong>事务故障和系统故障修复</strong>必须使用日志文件</li>
  <li>在<strong>动态转储</strong>方式中必须建立日志文件，后备副本和日志文件综合起来才能有效地恢复数据库</li>
  <li>在<strong>静态转储</strong>方式中，用日志文件恢复转储结束时刻到故障点间的事务</li>
</ul>

<h3 id="日志文件的写入规则">日志文件的写入规则</h3>

<ul>
  <li>登记的次序严格按并发事务执行的时间顺序</li>
  <li>必须<strong>先写日志文件，后写数据库</strong></li>
</ul>

<h2 id="故障的恢复策略">故障的恢复策略</h2>

<h3 id="事务故障的恢复">事务故障的恢复</h3>

<p>事务故障的恢复——<strong>UNDO</strong>，即撤销事务</p>

<p>在不影响其它事务的情况下，<strong>强行回滚</strong>，撤销已做的修改。具体步骤：</p>

<ul>
  <li>反向扫描日志文件，查找该事务的更新操作</li>
  <li>对该事务的更新操作（插入、删除、修改）执行逆操作，即将日志记录中的“更新前的值”写入数据库</li>
  <li>如此处理下去，直到读到该事务的开始标志</li>
</ul>

<h3 id="系统故障-1">系统故障</h3>

<p>系统故障——<strong>UNDO+REDO</strong></p>

<ul>
  <li>系统故障造成数据库不一致状态的原因
    <ul>
      <li>未完成的事务对数据库的更新可能已经写入数据库</li>
      <li>已提交事务对数据库的更新可能还留在缓冲区未写入数据库</li>
    </ul>
  </li>
  <li>恢复操作需要<strong>撤销 (UNDO) 故障发生时未完成的任务，重做 (REDO) 已完成的任务</strong></li>
</ul>

<h3 id="步骤">步骤</h3>

<h4 id="系统故障-2">系统故障</h4>

<ol>
  <li>正向扫描日志文件，找出故障发生前已经提交的事务，将其事务标识记入<strong>重做 (REDO) 队列</strong>，同时找出故障发生时尚未完成的事务，将其事务标识记入<strong>撤销 (UNDO)</strong> 队列</li>
  <li>对撤销队列中的各个事务进行 UNDO 处理</li>
  <li>对重做队列中的各个事务进行 REDO 处理</li>
</ol>

<h4 id="介质故障-1">介质故障</h4>

<ol>
  <li>装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致状态。对于动态转储的副本，还需要装入转储开始时刻的日志文件副本，将数据库恢复到一致状态</li>
  <li>装入存储以后的日志文件副本，重做已经完成的事务</li>
</ol>

<h3 id="具有检查点的恢复技术">具有检查点的恢复技术</h3>

<h4 id="优势">优势</h4>

<ul>
  <li>利用日志技术进行恢复时，恢复子系统通常需要检查大量日志记录，存在的问题是：
    <ul>
      <li>搜索日志耗费大量时间</li>
      <li>不必要重做某些事物</li>
    </ul>
  </li>
  <li>检查点技术可以改善效率，使得在检查点之前提交的事务，在数据库恢复处理时不必重做</li>
</ul>

<h4 id="检查点技术">检查点技术</h4>

<ul>
  <li>在日志文件中增加<strong>检查点 (checkpoint) 记录</strong></li>
  <li>检查点记录的内容
    <ul>
      <li>建立检查点时刻<strong>所有正在执行的事务清单</strong></li>
      <li>这些事务<strong>最近一个日志记录的地址</strong></li>
    </ul>
  </li>
  <li>系统中增加一个<strong>重新开始文件</strong>，用来记录各个<strong>检查点记录在日志文件中的地址</strong></li>
  <li>恢复子系统<strong>动态维护日志文件</strong>，即周期性地执行如下操作
    <ul>
      <li>将当前日志缓存中的所有<strong>日志记录写入磁盘的日志文件上</strong></li>
      <li>在日志文件上<strong>写入一个检查点记录</strong></li>
      <li>将当前数据缓存的所有<strong>数据记录写入磁盘的数据库中</strong></li>
      <li>把<strong>检查点记录在日志文件中的地址写入重新开始文件</strong>s</li>
    </ul>
  </li>
</ul>

<h4 id="利用检查点技术进行恢复">利用检查点技术进行恢复</h4>

<ul>
  <li><strong>利用重新开始文件定位最近检查点记录</strong>：在重新开始文件中找到最后一个检查点记录在日志文件中的地址</li>
  <li><strong>找到检查点时刻运行事务清单</strong>：由该检查点记录得到检查点建立时刻所有正在运行的事务清单 ACTIVE-LIST，把 ACTIVE-LIST 暂时放入 UNDO-LIST</li>
  <li><strong>确定需要撤销和重做的事务</strong>：从<strong>检查点开始</strong>正向扫描日志文件，做如下处理，直到文件结束
    <ul>
      <li>如果有新开始的事务 $T_i$，把 $T_i$ 暂时放入 UNDO-LIST</li>
      <li>如果有提交的事务 $T_j$ ，把 $T_j$ 从 UNDO-LIST 队列移入到 REDO-LIST 队列</li>
    </ul>
  </li>
  <li><strong>执行撤销或重做动作</strong>：对 UNDO-LIST 中的每一个事物执行 UNDO 操作，对 REDO-LIST 中的每个事务执行 REDO 操作</li>
</ul>

<h2 id="数据库镜像">数据库镜像</h2>

<p>根据 DBA 的要求，自动把整个 DB 或其中的关键数据复制到另一个磁盘上，由 DBMS 自动保证镜像数据库与主数据库的一致性。</p>

<h2 id="并发控制">并发控制</h2>

<p><img src="/assets/images/post/concurrent.png" alt="" /></p>

<h3 id="并发控制-1">并发控制</h3>

<ul>
  <li>事务并发执行的优点
    <ul>
      <li>一个事务由不同的步骤组成，所设计的系统资源也不同。这些步骤可以并发执行，以<strong>提高系统的吞吐量</strong></li>
      <li>系统中存在着周期不等的各种事务，串行会导致难以预测的时延。如果各个事务所涉及的是数据库的不同部分，采用并发会<strong>减少平均响应时间</strong></li>
    </ul>
  </li>
  <li>事务并发执行带来的问题
    <ul>
      <li><strong>多个事务同时存取同一数据</strong>时，如不加控制就可能会读取或存储不正确的数据，破坏数据库的一致性。</li>
    </ul>
  </li>
</ul>

<h3 id="并发操作导致的数据不一致性">并发操作导致的数据不一致性</h3>

<h4 id="丢失更新-lost-update">丢失更新 (Lost Update)</h4>

<p>两个事务 T1 和 T2 读入同一数据并修改，T2 提交的结果破坏了 T1 提交的结果，导致 T1 的修改被丢失</p>

<p><img src="/assets/images/post/lostUpdate.png" alt="" /></p>

<h4 id="脏数据的读出-dirty-read">“脏”数据的读出 (Dirty Read)</h4>

<p>事务 T1 修改某一数据，并将其写回磁盘，事务 T2 读取同一数据后，T1 由于某种原因被撤销，这时 T1 已修改过的数据恢复为原值，T2 读到的数据就与数据库中的不一致，则 T2 读到的数据就为“脏”数据。</p>

<p><img src="/assets/images/post/dirtyRead.png" alt="" /></p>

<h4 id="不能重复读-non-repeatable-read">不能重复读 (Non-Repeatable Read)</h4>

<p>事务 T1 读取数据后，事务 T2 执行更新（修改、插入、删除操作），使 T1 无法再现前一次读取的结果。</p>

<p><img src="/assets/images/post/nonrepeatableread.png" alt="" /></p>

<h3 id="并发控制基本思想">并发控制基本思想</h3>

<p>并发控制就是要<strong>合理调度并发事务</strong>，<strong>避免并发事务之间的互相干扰造成数据的不一致性</strong></p>

<h3 id="并发控制的基本手段封锁">并发控制的基本手段——封锁</h3>

<h4 id="定义-9">定义</h4>

<p><strong>封锁</strong>就是事务 T 在对某个数据对象等操作之前，先向系统发出请求，对其<strong>加锁</strong>，从而对该数据有了一定的控制权</p>

<h4 id="分类-2">分类</h4>

<h5 id="排他锁x-锁exclusive-lock">排他锁（X 锁，eXclusive lock）</h5>

<p>事务 T 对数据对象 R 加上 X 锁，则<strong>只允许 T 读取和修改 R</strong>，其它事务对 R 的<strong>任何</strong>封锁请求都不能成功，直至 T 释放 R 上的 X 锁。</p>

<h5 id="共享锁s-锁share-lock">共享锁（S 锁，Share lock）</h5>

<p>事务 T 对数据对象 R 加上 S 锁，则事务 T <strong>可以读取但不能修改 R</strong>，其它事务只能对 R 加 S 锁，而不能对 R 加 X 锁，直到 T 释放 R 上的 S 锁。</p>

<h4 id="基本锁的相容矩阵">基本锁的相容矩阵</h4>

<table>
  <thead>
    <tr>
      <th>T1 \ T2</th>
      <th>X</th>
      <th>S</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**X**</td>
      <td>N</td>
      <td>N</td>
    </tr>
    <tr>
      <td>**S**</td>
      <td>N</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>

<h4 id="封锁协议">封锁协议</h4>

<p><img src="/assets/images/post/rule.png" alt="" /></p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>内容</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**一级封锁协议**</td>
      <td>事务 T 在修改数据 R 之前必须对其家 X 锁，直到事务结束（正常结束 &amp; 非正常结束）才释放。</td>
      <td>方式丢失修改，并保证事务 T 是可恢复的。不能保证可重复读和读“脏”数据。</td>
    </tr>
    <tr>
      <td>**二级封锁协议**</td>
      <td>一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，**读完后**即可释放 S 锁。</td>
      <td>可以防止丢失更新，还可以进一步防止读“脏”数据。但不能保证可重复读。</td>
    </tr>
    <tr>
      <td>**三级封锁协议**</td>
      <td>一级封锁协议加上事务 T 在读取 R 之前必须对其加 S 锁，**直到事务结束**才释放。</td>
      <td>防止丢失修改，读“脏”数据和不可重复读。</td>
    </tr>
  </tbody>
</table>

<h4 id="封锁的粒度">封锁的粒度</h4>

<h5 id="定义-10">定义</h5>

<h6 id="封锁对象">封锁对象</h6>

<p>属性值、属性值集合、元组、关系、某索引项、整个索引、整个数据库、物理页、块等</p>

<h6 id="封锁粒度">封锁粒度</h6>

<p>封锁对象的大小成为封锁粒度</p>

<h5 id="性质">性质</h5>

<ul>
  <li>封锁粒度大，则并发度低，封锁机构简单，开销小</li>
  <li>封锁粒度小，则并发度搞，封锁机构复杂，开销高</li>
</ul>

<h5 id="多粒度封锁">多粒度封锁</h5>

<p>在一个系统中<strong>同时支持多种封锁粒度</strong>供不同的事务选择。选择封锁粒度时应考虑<strong>封锁开销</strong>和<strong>并发度</strong>两个因素，适当选择封锁粒度以达到最优效果。</p>

<h4 id="多粒度封锁-1">多粒度封锁</h4>

<h5 id="多粒度树">多粒度树</h5>

<p>多粒度树的根节点是整个数据库，表示最大的粒度。叶结点表示最小的粒度。</p>

<h5 id="多粒度封锁协议">多粒度封锁协议</h5>

<ul>
  <li>多粒度封锁协议<strong>允许多粒度树种的每个节点被独立的加锁。对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁</strong>。因此，在多粒度封锁种一个数据对象可能以两种方式加锁，即：
    <ul>
      <li><strong>显式封锁</strong>：是应事务的要求直接加到数据对象上的封锁</li>
      <li><strong>隐式封锁</strong>：是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加锁</li>
    </ul>
  </li>
  <li>在多粒度封锁方法中，<strong>显式封锁和隐式封锁的效果相同</strong></li>
</ul>

<h5 id="存在的问题">存在的问题</h5>

<p>在多粒度封锁方法中，一般对某个数据对象加锁，系统要做如下检查：</p>

<ul>
  <li>是否<strong>与该数据对象上的显式封锁冲突</strong>（检查对象本身）</li>
  <li>是否<strong>与该数据对象上的隐式封锁冲突</strong>（检查对象的所有上级结点）</li>
  <li>是否<strong>与该数据对象的下级的显示封锁冲突</strong>（检查其所有下级结点）</li>
</ul>

<h4 id="意向锁">意向锁</h4>

<h5 id="定义-11">定义</h5>

<p><strong>意向锁</strong>的含义是该结点的下层结点正在被加锁。</p>

<ul>
  <li>对任意结点加锁时，必须先对其上级结点加意向锁</li>
  <li>意向锁的好处是：在对象加锁时，<strong>不再检查下级结点的封锁</strong>，只需检查对象和它的上级结点</li>
</ul>

<h5 id="分类-3">分类</h5>

<h6 id="意向共享锁-intent-share-lock简称-is-锁">意向共享锁 (Intent Share Lock，简称 IS 锁)</h6>

<p>如果要对一个数据对象加 IS 锁，表示它的后裔结点拟（意向）加 S 锁。</p>

<h6 id="意向排它锁-intent-exclusive-lock简称-ix-锁">意向排它锁 (Intent Exclusive Lock，简称 IX 锁)</h6>

<p>如果要对一个数据对象加 IX 锁，表示它的后裔结点拟（意向）加 X 锁。</p>

<h6 id="意向共享排它锁-share-intent-exclusive-lock简称-six-锁">意向共享排它锁 (Share Intent Exclusive Lock，简称 SIX 锁)</h6>

<p>如果要对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁，即 <strong>SIX = S + IX</strong></p>

<h5 id="加锁方法">加锁方法</h5>

<p>任意事务 T 要对一个数据对象加锁，<strong>先对它的上级对象加意向锁</strong>，申请封锁按自上而下的次序进行；释放封锁时，应按照自下而上的次序进行。</p>

<h5 id="相容矩阵">相容矩阵</h5>

<table>
  <thead>
    <tr>
      <th>T1 \ T2</th>
      <th>S</th>
      <th>X</th>
      <th>IS</th>
      <th>IX</th>
      <th>SIX</th>
      <th>-</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**S**</td>
      <td>Y</td>
      <td>N</td>
      <td>Y</td>
      <td>N</td>
      <td>N</td>
      <td>Y</td>
    </tr>
    <tr>
      <td>**X**</td>
      <td>N</td>
      <td>N</td>
      <td>N</td>
      <td>N</td>
      <td>N</td>
      <td>Y</td>
    </tr>
    <tr>
      <td>**IS**</td>
      <td>Y</td>
      <td>N</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
    </tr>
    <tr>
      <td>**IX**</td>
      <td>N</td>
      <td>N</td>
      <td>Y</td>
      <td>Y</td>
      <td>N</td>
      <td>Y</td>
    </tr>
    <tr>
      <td>**SIX**</td>
      <td>N</td>
      <td>N</td>
      <td>Y</td>
      <td>N</td>
      <td>N</td>
      <td>Y</td>
    </tr>
    <tr>
      <td>**-**</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>

<h4 id="活锁与死锁">活锁与死锁</h4>

<h5 id="活锁">活锁</h5>

<h6 id="定义-12">定义</h6>

<p>任务或执行者没有被阻塞，但由于某些条件没有满足，导致一直无法得到执行。</p>

<h6 id="解决">解决</h6>

<p>采用先来先服务的策略</p>

<h5 id="死锁">死锁</h5>

<h6 id="定义-13">定义</h6>

<p>当两个以上的运算单元，双方都在等待对方停止执行，以取得系统资源，但是没有一方提前退出时，发生死锁。</p>

<h6 id="解决-1">解决</h6>

<ul>
  <li>预防死锁</li>
  <li>死锁检测和解除</li>
</ul>

<h5 id="死锁预防">死锁预防</h5>

<ul>
  <li><strong>一次封锁法</strong>
    <ul>
      <li>要求每个事务必须<strong>一次</strong>将所有要使用的数据<strong>全部</strong>加锁，否则<strong>不能</strong>执行。</li>
      <li>可以有效地防止死锁的发生，但由于需要扩大加锁范围，因此会<strong>降低系统的并发度</strong></li>
    </ul>
  </li>
  <li><strong>顺序封锁法</strong>
    <ul>
      <li><strong>预先对数据对象规定一个封锁顺序</strong>。所有的事务都要按照这个顺序执行封锁。</li>
      <li>可以有效的防止死锁，但由于数据库中数据的不断变化和事务封锁要求的动态提出而<strong>实现难度大</strong></li>
    </ul>
  </li>
</ul>

<h5 id="死锁检测">死锁检测</h5>

<ul>
  <li>
    <p><strong>超时法</strong></p>

    <p>如果一个事务的等待时间超过了规定的期限，就认为发生了死锁</p>
  </li>
  <li>
    <p><strong>等待图法</strong></p>

    <p>事务等待图是一个有向图 G=(T, U)，其中 T 为结点集合，每个结点表示正在运行的事务，U 为边集，每条边表示事务的等待情况。并发控制子系统周期性的检测事务等待图，<strong>如果发现图中存在环路，则表示系统出现死锁</strong></p>
  </li>
</ul>

<h5 id="死锁恢复">死锁恢复</h5>

<ul>
  <li>通常采用的方法是<strong>选择一个处理死锁代价最小的事务，将其撤销</strong>，释放此事务持有的所有锁，使其他食物得以继续运行下去。对于所撤销的食物所作的操作必须加以恢复。</li>
</ul>

<h2 id="事务的调度">事务的调度</h2>

<h3 id="定义-14">定义</h3>

<p>N 个事务的一个调度 S 是 N 个事务所有操作的一个<strong>序列</strong>。表示这些操作的<strong>执行顺序</strong>。并且这个序列满足：对于每个事务 T，如果操作 i 在事务 T 中先于操作 k 执行，则在 S 中操作 i 也必须先于操作 k 执行。</p>

<h3 id="并发调度的可串行性">并发调度的可串行性</h3>

<h4 id="定义-15">定义</h4>

<h5 id="可串行化调度">可串行化调度</h5>

<p>多个事务的并发执行是<strong>正确</strong>的，当且仅当其结果与<strong>按某一次序串行执行</strong>它们时的结果相同，我们称这种调度策略为<strong>可串行化调度</strong>。</p>

<h5 id="冲突操作">冲突操作</h5>

<p>冲突操作是<strong>不同事务</strong>对<strong>同一数据</strong>的<strong>读-写</strong>操作以及<strong>写-写</strong>操作。</p>

<h4 id="性质-1">性质</h4>

<p><strong>可串行性是并行事务正确性的准则</strong></p>

<blockquote>
  <p>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。</p>
</blockquote>

<h4 id="判定">判定</h4>

<ul>
  <li>
    <p>一个调度 Sc 在保证冲突操作次序不变的情况下，可以通过交换两个事务不冲突操作的顺序，得到另一个穿行调度 Sc’，则调度 Sc 为<strong>冲突可串行化调度</strong>。</p>

    <blockquote>
      <p>不同事务的冲突操作与同一个事物的两个操作不能交换。</p>
    </blockquote>
  </li>
  <li>
    <p><strong>一个冲突可串行化调度，一定是可串行化调度</strong></p>
  </li>
</ul>

<h4 id="两段锁协议-two-phase-locking">两段锁协议 (Two-phase Locking)</h4>

<h5 id="内容">内容</h5>

<ol>
  <li>在对任何数据进行读、写操作之前，事务首先要获得对数据的封锁</li>
  <li>在释放一个封锁之后，事务不再获得其它封锁</li>
</ol>

<h5 id="含义">含义</h5>

<p>事务分为两个阶段，第一个阶段是获得封锁，也称为<strong>扩展阶段</strong>，第二个阶段是释放封锁，也称为<strong>收缩阶段</strong></p>

<h5 id="作用-1">作用</h5>

<p>可保证并行事务的可串行性</p>

<h4 id="并发调度的可串行性-1">并发调度的可串行性</h4>

<h5 id="定理-2">定理</h5>

<p>若所有事物均遵从两段锁协议，则这些食物的所有并发调度都是可串行化的。</p>

<h5 id="注意的问题">注意的问题</h5>

<ul>
  <li>事务遵守两段锁协议是可串行化调度的充分条件而不是必要条件</li>
  <li>两段锁协议并不要求事务在执行任何数据库读、写操作之前就一次申请全部封锁，因此<strong>遵守两段锁的事务仍可能发生死锁</strong>。</li>
</ul>

<h1 id="第九章-数据库保护">第九章 数据库保护</h1>

<p><strong>数据安全性控制</strong>是保护数据库防止恶意的破坏和非法存取。</p>

<p><strong>数据完整性控制</strong>是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出。</p>

<blockquote>
  <p>安全性防范的是非法用户和非法操作，完整性措施防范的对象是不合语义的数据。</p>
</blockquote>

<h2 id="数据库安全性控制">数据库安全性控制</h2>

<h3 id="定义-16">定义</h3>

<p>数据库的安全性是指保护数据库以<strong>防止不合法的使用所造成的数据泄露、更改和破坏</strong>，它包括：</p>

<ul>
  <li>向授权用户提供可靠的信息服务</li>
  <li>拒绝对数据的非授权存取访问请求，保证给数据的可用性、完整性和一致性，进而保护数据库所有者和使用者的合法权益</li>
</ul>

<h3 id="数据库安全性控制-1">数据库安全性控制</h3>

<h4 id="用户标识与鉴别">用户标识与鉴别</h4>

<p>用户标识和认证是系统提供的<strong>最外层</strong>安全保护措施</p>

<ul>
  <li><strong>标识</strong>是指系统采用一定的方式标识其用户或应用程序的名字或身份</li>
  <li><strong>认证</strong>是指系统在用户或应用程序登录时判断其是否为合法的授权用户</li>
  <li>常用的方法是采用<em>用户名</em>和<em>口令</em></li>
</ul>

<h4 id="存取控制">存取控制</h4>

<h5 id="定义-17">定义</h5>

<p>存取控制确保合法用户<strong>按照指定的权限</strong>使用 DBMS 和访问数据，而非法用户或不具有相关权限的用户则不能。</p>

<ul>
  <li><strong>用户权限定义</strong>：将用户权限记录到数据字典中，形成安全规则或授权规则</li>
  <li><strong>合法权限检查</strong>：每当用户发出数据库操作请求后，DBMS 根据数据字典中的安全规则进行合法权限检查，决定是否接受用户的操作请求。</li>
  <li><strong>用户权限定义和合法权限检查机制一起组成了 DBMS 的安全子系统</strong>。</li>
</ul>

<h5 id="自主存取控制-discretionary-access-control-dac">自主存取控制 (discretionary access control, DAC)</h5>

<p>用户对于不同的数据对象拥有不同的存取权限，不同的用户对同一对象也有不同的权限，而且<strong>用户还可以将其拥有的权限转授给其他用户</strong>。</p>

<p>根据预先定义的用户权限进行存取控制。<strong>用户权限</strong>是指用户对数据对象允许执行的操作类型，由<strong>数据对象</strong>和<strong>操作类型</strong>两个要素组成。</p>

<p>对于用户存取权限的定义称为<strong>授权</strong>。在授权中应指明：<strong>用户名、数据对象名、允许的操作类型</strong></p>

<h5 id="强制存取控制-mandatory-access-control-mac">强制存取控制 (mandatory access control, MAC)</h5>

<p>每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。<strong>对于任一个对象，只有具有合法许可证的用户才可以存取</strong>。</p>

<h4 id="强制存取方法">强制存取方法</h4>

<p>在 MAC 中，DBMS 所管理的全部实体被分为<strong>主体</strong>和<strong>客体</strong>两类</p>

<ul>
  <li><strong>主体</strong>是系统中的活动实体，既包括 DBMS 所管理的<strong>实际用户</strong>，也包括<strong>代表用户的各进程</strong></li>
  <li><strong>客体</strong>是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引、视图等</li>
</ul>

<p>对于主体和客体，DBMS 为他们每个实例指定一个<strong>敏感度标记 (Label)</strong>。敏感度标记被分为若干级别，如<strong>绝密</strong>、<strong>机密</strong>、<strong>秘密</strong>、<strong>公开</strong>等。<strong>主体</strong>的敏感度标记称为<strong>许可证级别</strong>，<strong>客体</strong>的敏感度标记称为<strong>密级</strong>。</p>

<p>MAC 机制通过<strong>对比主体和客体的 Label</strong>来确定是否能够存取。</p>

<ul>
  <li>仅当主体的许可证级别<strong>大于或等于</strong>客体的密级时，该主体才能<strong>读取</strong>相应的客体。</li>
  <li>当且仅当主体的许可证级别<strong>等于</strong>客体的密级时，该主体才能<strong>写</strong>相应的客体。</li>
</ul>

<h4 id="其它方法">其它方法</h4>

<h5 id="视图控制">视图控制</h5>

<p>为不同的用户定义不同的视图，可以将用户对数据的访问限制在一定的范围内。</p>

<h5 id="审计">审计</h5>

<p><strong>把用户对数据库的所有曹祖都自动记录下来放入审计日志中</strong>。DBA 可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。</p>

<h5 id="数据加密">数据加密</h5>

<p><strong>防止数据库中数据在存储和传输中失密</strong>。</p>

<h3 id="sql-的数据安全性控制">SQL 的数据安全性控制</h3>

<h4 id="用户权限">用户权限</h4>

<h5 id="用户级权限">用户级权限</h5>

<p>是数据库管理员<strong>为每个用户授予的特定权限</strong>，是对用户<strong>使用整个数据库权限的限定</strong>。与整个数据库相关，与数据库中具体的关系无关。</p>

<h5 id="关系级权限">关系级权限</h5>

<p>是数据库管理员或数据库对象的拥有者为用户授予的<strong>与关系或视图有关的权限</strong>，这种权限是对用户<strong>使用关系和视图权限的限定</strong>。</p>

<h4 id="角色与用户组">角色与用户组</h4>

<p>为了管理数据库特权的方便，数据库还支持<strong>角色与用户组</strong>的概念。</p>

<h5 id="角色">角色</h5>

<p><strong>角色是一组权限的集合</strong>，可以把它授予用户或其他角色。当把某个角色授予用户（或角色）或从用户（或角色）收回时，就同时授予或收回了该角色代表的全部权限。</p>

<h5 id="用户组">用户组</h5>

<p><strong>用户组是一组具有相同特性用户的集合</strong>。在授权或收回权限时，可以以用户组为单位进行。</p>

<h4 id="授予grant-语句">授予——<code class="language-plaintext highlighter-rouge">Grant</code> 语句</h4>

<p>在 SQL 语言中，通过 <code class="language-plaintext highlighter-rouge">Grant</code> 语句授予用户用户级权限或角色</p>

<pre><code class="language-mysql">Grant &lt;用户名权限&gt;|&lt;角色&gt; [{, 用户级权限&gt;|&lt;角色&gt;}]
	To &lt;用户名&gt;|&lt;角色&gt;|public [{, &lt;用户名&gt;|&lt;角色&gt;}] # public: 数据库中的全部用户
	[With Grant Option] # 允许被授权的用户将指定的用户级权限或角色授予其他用户
</code></pre>

<p>DBA 和数据库对象所有者将这些数据库对象上的部分或全部权限授予其他用户。</p>

<pre><code class="language-mysql">Grant ALL | &lt;权限&gt; [{, &lt;权限&gt;}]
	On &lt;表名&gt;|&lt;视图名&gt; [{, &lt;表名&gt;|&lt;视图名&gt;}]
	To {&lt;用户&gt; [{, &lt;用户&gt;}] | public}
	[With Grant Option]
</code></pre>

<h4 id="收回revoke-语句">收回——<code class="language-plaintext highlighter-rouge">Revoke</code> 语句</h4>

<pre><code class="language-mysql">Revoke &lt;用户级权限&gt;|&lt;角色&gt; [{, &lt;用户级权限&gt;|&lt;角色&gt;}]
	From &lt;用户名&gt;|&lt;角色&gt;|public [{, &lt;用户名&gt;|&lt;角色&gt;}]
</code></pre>

<pre><code class="language-mysql">Revoke ALL | &lt;表级权限&gt; [{, &lt;表级权限&gt;}]
	On &lt;表名&gt;|&lt;视图名&gt; [{, &lt;表名&gt;|&lt;视图名&gt;}]
	To {&lt;用户&gt; [{, &lt;用户&gt;}] | public}
	[With Grant Option]
</code></pre>

<p>收回权限时，若该用户已将权限授予其他用户，则也一并收回</p>

<h3 id="可信计算机系统评测标准">可信计算机系统评测标准</h3>

<ul>
  <li>TCSEC (Trusted Computer System Evaluation Criteria)</li>
  <li>TDI (Trusted Database Interpretation) / TCSEC</li>
  <li>TDI 与 TCSEC 从安全策略、责任、保证、文档四个方面描述了安全级别划分的指标</li>
</ul>

<h2 id="数据库完整性控制">数据库完整性控制</h2>

<h3 id="数据完整性含义">数据完整性含义</h3>

<p>数据完整性是指数据的<strong>正确性</strong>和<strong>相容性</strong>。</p>

<ul>
  <li><strong>正确性</strong>是指数据应具有合法的类型，并在有效的取值范围之内</li>
  <li><strong>相容性</strong>是指表示同一个事实的两个数据应该相同</li>
</ul>

<p>数据库能否保持完整性关系到数据库系统是否能够反映现实世界，因此维护数据库完整性十分重要。</p>

<h3 id="完整性约束条件">完整性约束条件</h3>

<h4 id="定义-18">定义</h4>

<p><strong>施加在数据库数据之上的语义约束条件</strong>称为数据库完整性约束条件。数据库系统依据完整性约束条件进行完整性检查。</p>

<p>作用对象</p>

<ul>
  <li><strong>列</strong>（主要是类型、取值范围、精度等）</li>
  <li><strong>元组</strong>（主要是各个字段间联系的约束）</li>
  <li><strong>关系</strong>（主要是若干元组间、关系间联系的约束）</li>
</ul>

<h4 id="分类-4">分类</h4>

<h5 id="静态约束">静态约束</h5>

<p>静态约束是指数据库在每一<strong>确定状态</strong>数据对象所应满足的约束条件，它是<strong>反映数据库状态合理性的约束</strong>。</p>

<ul>
  <li><strong>静态列级约束</strong>是对一个列的取值域的说明，包括对数据类型（类型、长度、单位、精度等）、数据格式、取值范围或取值集合、空值等的约束。</li>
  <li><strong>静态元组约束</strong>规定了组成一个元组的各个列之间的约束关系。</li>
  <li><strong>静态关系约束</strong>规定了一个关系的若干元组或者若干关系之间常常存在的各种联系或约束。包括：实体完整性约束、参照完整性约束、函数依赖、统计约束等。</li>
</ul>

<h5 id="动态约束">动态约束</h5>

<p>动态约束是指数据库从一种状态转变为另一种状态时，<strong>新、旧值之间</strong>所应满足的约束条件，它是<strong>反映数据库状态变迁的约束</strong>。</p>

<ul>
  <li><strong>动态列级约束</strong>是修改列定义或列值时应满足的约束条件。</li>
  <li><strong>动态元组约束</strong>指修改元组指时元组中各个字段间需要满足的约束。</li>
  <li><strong>动态关系约束</strong>指加载关系变化前后状态上的限制条件。</li>
</ul>

<h3 id="完整性控制">完整性控制</h3>

<h4 id="包括">包括</h4>

<ul>
  <li><strong>定义功能</strong>：提供定义完整性约束条件的机制</li>
  <li><strong>检查功能</strong>：检查用户发出的操作请求是否违背了完整性约束条件</li>
  <li><strong>违约响应</strong>：若违背了完整性约束条件，则采取一定措施来保证数据的完整性</li>
</ul>

<h4 id="分类-5">分类</h4>

<h5 id="立即执行约束">立即执行约束</h5>

<p>在执行用户事务的过程中，在<strong>一条语句执行完后</strong>立即进行完整性约束的检查。若违背了完整性约束，系统将拒绝<strong>该操作</strong>。</p>

<h5 id="延迟执行约束">延迟执行约束</h5>

<p>在<strong>整个用户事务执行完毕后</strong>，再进行完整性约束检查，结果正确方能提交，否则系统将拒绝<strong>整个事务</strong>。</p>

<h4 id="完整性规则的表示">完整性规则的表示</h4>

<p>用五元组 (D, O, A, C, P) 表示</p>

<ul>
  <li><strong>D</strong> (Data) 约束所作用的数据对象</li>
  <li><strong>O</strong> (Operation) 除法完整性检查的数据库操作</li>
  <li><strong>A</strong> (Assertion) 数据对象必须满足的断言或语义约束</li>
  <li><strong>C</strong> (Condition) 选择 A 作用的数据对象值的谓词</li>
  <li><strong>P</strong> (Procedure) 违反完整性规则时除法的过程</li>
</ul>

<h4 id="sql-支持">SQL 支持</h4>

<h5 id="create-table"><code class="language-plaintext highlighter-rouge">CREATE TABLE</code></h5>

<pre><code class="language-mysql">Create Table &lt;表名&gt;
	(&lt;列名&gt; &lt;数据类型&gt; [&lt;列级完整性约束&gt;]
    [{, &lt;列名&gt; &lt;数据类型&gt; [&lt;列级完整性约束&gt;]}]
    [{, &lt;表级完整性约束&gt;}]);
</code></pre>

<p>其中，完整性约束可以是：</p>

<pre><code class="language-mysql">NULL / NOTNULL
UNIQUE
PRIMARY KEY
FOREIGN KEY
CHECK
</code></pre>

<h5 id="assertion-断言"><code class="language-plaintext highlighter-rouge">ASSERTION</code> 断言</h5>

<pre><code class="language-mysql">CREATE ASSERTION &lt;断言名&gt; &lt;CHECK 子句&gt;
</code></pre>

<h5 id="trigger-触发器"><code class="language-plaintext highlighter-rouge">TRIGGER</code> 触发器</h5>

<p><strong>触发器</strong> (Trigger) 是用户定义再关系上的一类由事件驱动的特殊过程</p>

<p>对于用户对表的更新操作，系统自动激活相应触发器，执行完整性控制</p>

<pre><code class="language-mysql">CREATE TRIGGER &lt;触发其名称&gt;
	{BEFORE | AFTER} &lt;触发器事件&gt; ON &lt;表名&gt;
	REFERENCING NEW | OLD ROW AS &lt;变量&gt;
	FOR EACH {ROW|STATEMENT}
	[WHEN &lt;触发条件&gt;]
	&lt;触发动作体&gt;
</code></pre>

<h1 id="第四部分-数据库新技术">第四部分 数据库新技术</h1>

<h2 id="数据仓库-data-warehouse">数据仓库 (Data Warehouse)</h2>

<h3 id="定义-19">定义</h3>

<p><strong>数据仓库</strong>(Data Warehouse) 1990 年提出，是<strong>支持管理决策过程</strong>的、<strong>面向主题</strong>的、集成的、随时间而增长的持久数据集合。</p>

<h3 id="业务">业务</h3>

<ul>
  <li>数据仓库上的业务处理称作 <strong>OLAP</strong> (On-line Analytical Processing)，即<strong>联机分析处理</strong>。</li>
  <li>数据库上的业务处理称作 <strong>OLTP</strong> (On-line Transaction Processing)，即<strong>联机事务处理</strong></li>
</ul>

<h2 id="新时代数据管理面临的挑战">新时代数据管理面临的挑战</h2>

<ul>
  <li><strong>数据量</strong>：互联网时代，数据量呈指数级飞速增长，从 TB 到 PB 或更多</li>
  <li><strong>用户数</strong>：从几千人到几亿人</li>
  <li><strong>非结构化数据</strong>占总数据量的 80% 以上</li>
</ul>

<h2 id="数据库管理技术的新发展">数据库管理技术的新发展</h2>

<h3 id="sql">SQL</h3>

<ul>
  <li>传统关系型数据库，支持 SQL 操作，事务 ACID 特性</li>
  <li>几千用户，TB 级数据</li>
</ul>

<h3 id="nosql">NoSQL</h3>

<ul>
  <li>Not Only SQL，非关系型的数据库，水平可扩展、分布式</li>
  <li>不使用 SQL，不支持事务的 ACID 操作</li>
  <li>HBase, MongoDB 等</li>
</ul>

<h3 id="newsql">NewSQL</h3>

<ul>
  <li>新的可扩展 / 高性能数据库</li>
  <li>不仅具有 NoSQL 的海量数据存储管理能力，还保持了传统数据库支持 ACID 和 SQL 等特性</li>
  <li>VoltDB, ScaleBase, 阿里 DRDS 等</li>
</ul>

<h2 id="第九章-分布式数据库系统">第九章 分布式数据库系统</h2>

<h3 id="基本概念-1">基本概念</h3>

<h4 id="定义-20">定义</h4>

<p>分布式数据库是由一组分布再计算机网络的<strong>不同结点上的数据</strong>组成，<strong>每个结点具有独立的处理能力（称为场地自治），可以执行局部应用，同时每个结点也能通过网络通信支持全局应用</strong>。</p>

<ul>
  <li><strong>局部应用</strong>：只操作一个结点上数据库的应用</li>
  <li><strong>全局应用</strong>：操作两个或两个以上结点上的数据库的应用</li>
</ul>

<h4 id="特点">特点</h4>

<p>分布式数据库以“<strong>数据分布</strong>”为前提，强调<strong>场地自治性（局部应用）</strong>以及<strong>自治场地之间的协作性（全局应用）</strong>。</p>

<ul>
  <li><strong>场地自治性</strong>：每个场地有自己的数据库、一组终端，运行局部 DBMS，是独立的 DBS，具有高度自治性。</li>
  <li><strong>自治场地之间的协作性</strong>：各结点组成整体。整体性的含义是，从用户角度看，<strong>分布式数据库系统逻辑上如同一个集中式数据库一样</strong>，用户可以再任何场地执行全局应用。</li>
</ul>

<p>分布式数据库系统的特点有：</p>

<ol>
  <li><strong>数据独立性</strong>
    <ul>
      <li>数据的逻辑独立性和物理独立性</li>
      <li>数据的<strong>分布独立性（也称分布透明性）</strong>：数据的逻辑分片、数据物理位置分布的细节、重复剧本（冗余数据）一致性问题、局部结点上的数据模型等域用户程序无关。</li>
    </ul>
  </li>
  <li><strong>集中与自治相结合的控制结构</strong>
    <ul>
      <li>数据的共享有两个层次
        <ul>
          <li>一是<strong>局部共享</strong>。即在局部数据库中存储局部结点各用户的共享数据</li>
          <li>二是<strong>全局共享</strong>。即在分布式数据库系统的各个结点也存储供其他结点的用户共享的数据，支持系统的全局应用。</li>
        </ul>
      </li>
      <li>分布式数据库系统常常采用集中和自治相结合的控制结构
        <ul>
          <li>各局部的 DBMS 可以独立的管理局部的数据库，具有<strong>自治功能</strong>。</li>
          <li>系统又设有<strong>集中控制结构</strong>，协调各局部 DBMS 的工作，执行全局应用。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>适当增加数据冗余</strong>
    <ul>
      <li>在分布式数据库系统中适当的增加了冗余数据，<strong>在不同的结点存储同一数据的多个副本</strong>
        <ul>
          <li><strong>在提高系统的可靠性、可用性</strong>，当某一结点出现故障时，系统可以对另一结点的相同副本进行操作，不会因为一处故障而造成整个系统的瘫痪。</li>
          <li><strong>提高系统性能</strong>，系统可以选择用户最近的数据副本来进行操作，减少通信代价，改善整个系统的性能。</li>
        </ul>
      </li>
      <li>不利于更新，增加了系统维护的代价</li>
    </ul>
  </li>
  <li>全局的一致性、可串行性和可恢复性
    <ul>
      <li>分布式数据库除了各局部数据库应满足集中式数据库的一致性、可串行性和可恢复性以外，还应保证数据库的<strong>全局一致性、并行操作的可串行性和系统的全局可恢复性</strong>。</li>
    </ul>
  </li>
</ol>

<h3 id="体系结构">体系结构</h3>

<h4 id="模式结构">模式结构</h4>

<ul>
  <li>
    <p><strong>全局外模式及全局外模式 / 全局概念模式映像</strong>（映像 1）</p>

    <p>全局外模式全局应用的用户视图，是全局概念模式的子集；映像 1 定义全局外模式到全局概念模式的映像。</p>
  </li>
  <li>
    <p><strong>全局概念模式</strong></p>

    <p>定义分布式数据库中数据的整体逻辑结构，使得数据如同没有分布一样</p>
  </li>
  <li>
    <p><strong>分片模式及全局概念模式 / 分片模式映像</strong>（映像2）</p>

    <p>每一个全局关系可以分为若干互不相交的部分，每一部分称为一个<strong>片段</strong>。分片模式及映像2定义片段以及全局关系到片段的映像。这种映像是一对多的。</p>
  </li>
  <li>
    <p><strong>分布模式及分片模式 / 分布模式映像</strong>（映像 3）</p>

    <p>定义片段的存放结点及片段到结点的映像。分布模式的映像类型确定了分布式数据库是冗余的还是非冗余的。</p>
  </li>
  <li>
    <p><strong>分布模式 / 局部数据库概念模式映像</strong>（映像 4）</p>

    <p>该映像把存储在局部场地的全局关系或全局关系的片段映像为各局部概念模式。</p>
  </li>
</ul>

<p><img src="/assets/images/post/ddbms.png" alt="" /></p>

<h4 id="数据分片">数据分片</h4>

<h5 id="水平分片">水平分片</h5>

<p>将关系依照一定条件<strong>按行</strong>分为不相交的若干子集，每个子集称为一个水平片段。</p>

<h5 id="垂直分片">垂直分片</h5>

<p>将关系<strong>按列</strong>分为若干属性子集，每个子集称为一个垂直片段。垂直分片的片段通过连接的方法恢复原关系。因此<strong>垂直分片的诸片段通常都包含关系的码</strong>。</p>

<h5 id="导出分片">导出分片</h5>

<p>导出水平分片，分片的条件不是关系本身属性条件，而是其它关系的属性条件。</p>

<h5 id="混合分片">混合分片</h5>

<p>指按上述三种分片方式得到的片段，继续按另一种方式分片</p>

<h5 id="数据分片的约束">数据分片的约束</h5>

<h6 id="完全性">完全性</h6>

<p>一个全局关系中的数据<strong>必须完全划分为若干片段</strong>，不允许某些数据属于全局关系但不属于任何片段。</p>

<h6 id="不相交性">不相交性</h6>

<p>不允许一个全局关系的某些数据既属于该全局关系的某一个片段，又属于另一个片段（垂直分片的码属性除外）</p>

<h6 id="可重构性">可重构性</h6>

<p>可以由片段重构全局关系</p>

<ul>
  <li><strong>垂直分片可用连接操作重构</strong></li>
  <li><strong>水平分片可用并操作重构</strong></li>
</ul>

<h4 id="分布透明性">分布透明性</h4>

<h5 id="分片透明性">分片透明性</h5>

<p>用户或应用程序只对全局关系进行操作而不必考虑关系的分片。它是分布透明性的<strong>最高层次</strong></p>

<h5 id="位置透明性">位置透明性</h5>

<p>用户或应用程序不必了解片段的存储场地也不必关系各数据副本的一致性</p>

<h5 id="局部数据模型透明性">局部数据模型透明性</h5>

<p>用户或应用程序不必了解局部场地上是哟个的是哪一种数据模型。模型的转换以及查询语言等的转换均由分布式 / 局部概念模式（映像 4）完成</p>

<h4 id="分布式数据库管理系统-ddbms">分布式数据库管理系统 DDBMS</h4>

<h5 id="组成">组成</h5>

<ul>
  <li><strong>LDBMS</strong>（局部场地上的数据库管理系统）
    <ul>
      <li>功能：建立和管理局部数据库，提供场地自治能力，执行局部应用及全局查询的子查询。</li>
    </ul>
  </li>
  <li><strong>GDBMS</strong>（全局数据库管理系统）
    <ul>
      <li>功能：提供分布透明性，协调全局事务的执行，协调各局部 DBMS 以完成全局应用，并保证数据库的全局一致性，执行并发控制，实现更新同步，提供全局恢复功能</li>
    </ul>
  </li>
  <li><strong>GDD</strong>（全局数据字典）
    <ul>
      <li>存放全局概念模式、分片模式、分布模式的定义以及各模式之间映像的定义</li>
      <li>存放有关用户存取权限的定义，以保证全局用户的合法权限和数据库的安全性</li>
      <li>存放数据完整性约束条件的定义</li>
    </ul>
  </li>
  <li><strong>CM</strong>（通信管理）
    <ul>
      <li>在分布式数据库各场地之间传递消息和数据，完成通信功能</li>
    </ul>
  </li>
</ul>

<h5 id="分类-6">分类</h5>

<h6 id="按全局控制方式分类">按全局控制方式分类</h6>

<ul>
  <li>
    <p><strong>全局控制集中的 DDBMS</strong></p>

    <ul>
      <li>特点：GDBMS 集中在某一结点上，GDD 只有一个，也放在该结点上</li>
      <li>优点：控制简单，容易设计实现</li>
      <li>缺点：易形成瓶颈，并且一旦该结点出现故障，整个系统将瘫痪</li>
    </ul>
  </li>
  <li>
    <p><strong>全局控制分散的 DDBMS</strong></p>

    <ul>
      <li>特点：GDBMS 分散在每一个结点上，GDD 也在每个结点上有一份。这类结构称为<strong>完全分布的 DDBMS</strong></li>
      <li>优点：结点独立、自治性强，单个结点出席那问题不会使系统瘫痪</li>
      <li>缺点：全局控制的协调机制和一致性维护都比较复杂</li>
    </ul>
  </li>
  <li>
    <p><strong>全局控制部分分散的</strong> <strong>DDBMS</strong></p>

    <p>根据应用的需要将全局数据库管理器和全局数据字典分散在<strong>某些</strong>结点上，介于上述两者之间</p>
  </li>
</ul>

<h6 id="按局部-dbms-的类型分类">按局部 DBMS 的类型分类</h6>

<ul>
  <li>
    <p><strong>同构型 DDBMS</strong></p>

    <p>每个结点的局部数据库具有相同的 DBMS，即使硬件与操作系统互不相同</p>
  </li>
  <li>
    <p><strong>异构型 DDBMS</strong></p>

    <p>各结点的局部数据库具有不同的 DBMS</p>
  </li>
</ul>

<h3 id="主要技术">主要技术</h3>

<h4 id="分布式查询处理和优化">分布式查询处理和优化</h4>

<h5 id="分布式查询类型与处理过程">分布式查询类型与处理过程</h5>

<p>分为局部查询、远程查询和全局查询</p>

<ul>
  <li>局部查询和远程查询<strong>只涉及单个结点的数据</strong>（本地或远程），可以采用<strong>集中式数据库的处理技术</strong></li>
  <li><strong>全局查询涉及到多个结点的数据，十分复杂</strong></li>
</ul>

<h5 id="分布式查询处理过程">分布式查询处理过程</h5>

<ol>
  <li>
    <p><strong>查询分解</strong></p>

    <p>把查询操作分解为若干子查询，每个子查询只涉及某一个结点的数据，可由局部 DBMS 处理。必须选择查询开销最省的哪些结点（物理片段）</p>
  </li>
  <li>
    <p><strong>选择操作执行次序</strong></p>

    <p>确定涉及不同结点上关系的连接和并操作的次序</p>
  </li>
  <li>
    <p><strong>选择执行操作的算法</strong></p>

    <p>包括选择存取路径、选择某种操作的算法以及连接的执行方法</p>
  </li>
</ol>

<h5 id="查询优化的目标">查询优化的目标</h5>

<p>首要目标是：<strong>使查询执行时通信代价最省</strong></p>

<blockquote>
  <p>不同结点之间的连接操作和并操作是数据传输的主要原因，因此连接查询的优化是优化中需要研究的中重要问题</p>
</blockquote>

<h5 id="连接查询的优化">连接查询的优化</h5>

<ul>
  <li><strong>半连接</strong>：使用半连接来缩减关系（或片段）进而节省传输的开销
    <ul>
      <li>定义<img src="/assets/images/post/half.png" alt="" /></li>
      <li>性质 <img src="/assets/images/post/half1.png" alt="" /></li>
    </ul>
  </li>
</ul>

<h4 id="分布式事务管理">分布式事务管理</h4>

<h5 id="分布事务的原子性和可串行性">分布事务的原子性和可串行性</h5>

<ul>
  <li>在分布式数据库系统中，一个全局事务被划分为许多结点上的子事务</li>
  <li>分布事务的<strong>原子性</strong>是：组成该事务的所有子事务要么一致的全部提交，要么一致的全部回滚</li>
  <li>在多用户系统中，还必须保证分布式数据的<strong>可串行性</strong></li>
</ul>

<h5 id="事务的恢复">事务的恢复</h5>

<p>每个场地都有一个<strong>局部事务管理器</strong>，负责管理局部子事务的执行。同时，<strong>各局部事务管理器之间必须有相互协调，保证分布事务的原子性</strong>：各子事务要么都提交，要么都回滚</p>

<p>对局部事务管理进行协调，保证分布事务原子性最常用的技术——<strong>两段提交协议</strong> (2-Phase-Commitment Protocol)</p>

<h6 id="两段提交协议-2-phase-commitment-protocol">两段提交协议 (2-Phase-Commitment Protocol)</h6>

<p>把分布事务的所有局部事务管理分为两类：<strong>协调者</strong>（一个），<strong>参与者</strong></p>

<ul>
  <li><strong>协调者</strong>：负责作出该事务是提交还是撤销的最后决定</li>
  <li><strong>参与者</strong>：负责管理相应于子事务的执行以及在各自局部数据库上执行写操作</li>
</ul>

<p><strong>内容</strong>：</p>

<ul>
  <li><strong>第一阶段：协调者征求意见做决定</strong>
    <ul>
      <li>协调者向所有参与者发出”准备提交“信息，并记入日志；参与者准备提交就回答”就绪“，否则回答”撤销“，并记入日志</li>
      <li>如果在规定时间内，协调者收到所有参与者的”就绪“信息，则做出”提交“决定，否则”撤销“</li>
    </ul>
  </li>
  <li><strong>第二阶段：参与者执行决定</strong>
    <ul>
      <li>协调者将有关决定写入日志，然后把这个决定发送给所有参与者</li>
      <li>所有参与者收到命令后，首先在日志中记入”收到提交 / 撤销决定“的信息，并向协调者发送应答信息，最后执行相应决定。</li>
      <li>协调者收到所有参与者的应答消息后，一个事务的执行到此结束。有关日志信息可以脱机保存。</li>
    </ul>
  </li>
  <li>采用两段提交协议后，当系统发生故障时，各场地利用各自有关的日志进行事务恢复</li>
</ul>

<h5 id="事务的并发控制">事务的并发控制</h5>

<ul>
  <li>分布式数据库系统中的并发控制也可以采用<strong>封锁技术</strong>，但更加复杂
    <ul>
      <li>分布式数据库系统支持<strong>多副本</strong></li>
      <li>由于事务的分布执行，封锁的方法会引起<strong>全局死锁</strong></li>
    </ul>
  </li>
  <li>策略：
    <ul>
      <li>处理多副本封锁的几种可能方法
        <ul>
          <li>对<strong>写</strong>操作，要申请<strong>所有</strong>副本的 X 锁；对<strong>读</strong>操作，只要申请<strong>某个</strong>副本的 S 锁。</li>
          <li>无论是写操作还是读操作都要对<strong>大多数</strong>副本申请 X 锁或 S 锁</li>
          <li>规定某个场地上的副本为主副本，所有的读、写操作均申请对主副本的封锁</li>
        </ul>
      </li>
      <li>解决全局自锁（两个以上场地上发生死锁）
        <ul>
          <li>死锁检测及解除方式</li>
          <li>死锁预防</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>ericaaaaaaaa</name></author><category term="Data" /><category term="note" /><category term="data" /><category term="database" /><summary type="html"><![CDATA[数据库系统原理]]></summary></entry><entry><title type="html">Artificial Intelligence</title><link href="http://localhost:4000/artificialintelligence/2022/01/03/ArtificialIntelligence.html" rel="alternate" type="text/html" title="Artificial Intelligence" /><published>2022-01-03T00:00:00+08:00</published><updated>2022-01-03T00:00:00+08:00</updated><id>http://localhost:4000/artificialintelligence/2022/01/03/ArtificialIntelligence</id><content type="html" xml:base="http://localhost:4000/artificialintelligence/2022/01/03/ArtificialIntelligence.html"><![CDATA[<h1 id="loss-function">Loss Function</h1>

<h2 id="regularization-add-term-to-loss">Regularization: Add term to loss</h2>

<p>$L=\frac{1}{N}\sum_{i=1}^{N}\sum_{j\not= y_i}\max(0, f(x_i;W)<em>j-f(x_i;W)</em>{y_i}+1)+\lambda R(W)$</p>

<p>In common use:</p>

<p><img src="/assets/images/post/reg.png" alt="" /></p>

<h3 id="dropout">Dropout</h3>

<p>In each forward pass, randomly set some neurons to zero</p>

<p>Probability of dropping is a hyperparameter; 0.5 is common</p>

<p><img src="/assets/images/post/drop.png" alt="" /></p>

<h3 id="data-augmentation">Data Augmentation</h3>

<ul>
  <li>Horizontal Flipping 水平翻转</li>
  <li>Random Cropping 随机裁剪</li>
  <li>Random Scaling 随机放缩</li>
  <li>Color Jittering 颜色抖动</li>
  <li>Random Translation 随机平移</li>
  <li>Random Shearing 随机剪切</li>
</ul>

<h2 id="regression">Regression</h2>

<h3 id="l1-loss">L1 Loss</h3>

<table>
  <tbody>
    <tr>
      <td>$L(y, \hat{y})=w(\theta)</td>
      <td>\hat{y}-y</td>
      <td>$</td>
    </tr>
  </tbody>
</table>

<h3 id="l2-loss">L2 Loss</h3>

<p>$L(y, \hat{y})=w(\theta)(\hat{y}-y)^2$</p>

<h2 id="classification">Classification</h2>

<h3 id="hinge-loss-function-铰链损失函数">Hinge Loss Function 铰链损失函数</h3>

<p>$L(y, \hat{y}) = \max{(0, 1-\hat{y}y)}$</p>

<p>$y\in{-1, 1}$</p>

<h3 id="cross-entropy-loss-function-交叉熵损失函数">Cross-Entropy Loss Function 交叉熵损失函数</h3>

<p>In binary classification, $L(y, \hat{y}) = -y\log{(\hat{y})}-(1-y)\log{(1-\hat{y})}$</p>

<p>In multiclass classification (class number = M), $L(y) = -\sum_{c=1}^My_o, c\log{(p_o, c)}$</p>

<blockquote>
  <ul>
    <li>M - number of classes (dog, cat, fish)</li>
    <li>log - the natural log</li>
    <li>y - binary indicator (0 or 1) if class label cc is the correct classification for observation $o$</li>
    <li>p - predicted probability observation $o$ is of class $c$</li>
  </ul>
</blockquote>

<h3 id="exponential-loss-function-指数损失函数">Exponential Loss Function 指数损失函数</h3>

<p>$L(y,\hat{y}) = \exp{(-y\hat{y})}$</p>

<h2 id="sgd-stochastic-gradient-descent-随机梯度下降">SGD, Stochastic Gradient Descent 随机梯度下降</h2>

<p>在梯度下降时，为了加快收敛速度，通常使用一些优化方法。</p>

<p><img src="/assets/images/post/sgd.png" alt="" /></p>

<p>SGD每次都会在当前位置上沿着负梯度方向更新（下降，沿着正梯度则为上升），并不考虑之前的方向梯度大小等等。而动量（moment）通过引入一个新的变量 v去积累之前的梯度（通过指数衰减平均得到），得到加速学习过程的目的。</p>

<blockquote>
  <p>最直观的理解就是，若当前的梯度方向与累积的历史梯度方向一致，则当前的梯度会被加强，从而这一步下降的幅度更大。若当前的梯度方向与累积的梯度方向不一致，则会减弱当前下降的梯度幅度。</p>
</blockquote>

<h3 id="nesterov-momentum">Nesterov Momentum</h3>

<p><img src="https://img-blog.csdn.net/20180518154303163" alt="" /></p>

<h3 id="ada-grad-adaptive-gradient">Ada Grad (Adaptive Gradient)</h3>

<p>通常，我们在每一次更新参数时，对于所有的参数使用相同的学习率。而AdaGrad算法的思想是：每一次更新参数时（一次迭代），不同的参数使用不同的学习率。</p>

<p>Added element-wise scaling of the gradient based on the historical sum of squares in each dimension.</p>

<p><img src="/assets/images/post/ada.png" alt="" /></p>

<h3 id="rmsprop-leaky-adagrad">RMSProp: “Leaky AdaGrad”</h3>

<p><img src="/assets/images/post/rms.png" alt="" /></p>

<h3 id="adam">Adam</h3>

<p><img src="/assets/images/post/adam.png" alt="" /></p>

<p>Adam with beta1 = 0.9, beta2 = 0.999, and learning_rate = 1e-3 or 5e-4 is a great starting point for many models</p>

<h1 id="gradient-descent">Gradient Descent</h1>

<h2 id="1-dimension">1 Dimension</h2>

<ol>
  <li>Randomly pick an initial value $w^0$</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Compute $\frac{\partial L}{\partial w}</td>
          <td>_{w=w^0}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$w^1\gets w^0-\eta\frac{\partial L}{\partial w}</td>
          <td>_{w=w^0}$, where $\eta$ stands for <strong>learning rate</strong></td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h2 id="2-dimension">2 Dimension</h2>

<p>$y=wx_1+b$</p>

<ol>
  <li>Randomly pick an initial value $w^0, b^0$</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Compute $\frac{\partial L}{\partial w}</td>
          <td>_{w=w^0}$, $\frac{\partial L}{\partial b}</td>
          <td>_{w=w^0, b=b^0}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Update $w$ and $b$ iteratively: $w^1\gets w^0-\eta\frac{\partial L}{\partial w}</td>
          <td>_{w=w^0}$, $b^1\gets b^0-\eta\frac{\partial L}{\partial b}</td>
          <td>_{w=w^0, b=b^0}$, where $\eta$ stands for <strong>learning rate</strong></td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h2 id="learning-rate-decay">Learning rate decay</h2>

<h3 id="step">Step</h3>

<p>Reduce learning rate at a few fixed points. E.g. for ResNets, multiply LR by 0.1 after epochs 30, 60, and 90</p>

<h3 id="cosine">Cosine</h3>

<p>$\alpha_t=\frac{1}{2}\alpha_0(1+\cos (t\pi/T))$</p>

<ul>
  <li>$\alpha_0$: initial learning rate</li>
  <li>$\alpha_t$: learning rate at epoch t</li>
  <li>$T$: total number of epochs</li>
</ul>

<h3 id="linear">Linear</h3>

<p>$\alpha_t=\alpha_0(1-t/T)$</p>

<h3 id="inverse-sqrt">Inverse Sqrt</h3>

<p>$\alpha_t = \alpha_1/\sqrt{t}$</p>

<h2 id="looking-at-learning-curves">Looking at learning curves</h2>

<p>Losses may be noisy, use a scatter plot and also plot moving average to see trends better.</p>

<h1 id="activation-function">Activation Function</h1>

<blockquote>
  <p>introduce non-linear properties to the network</p>
</blockquote>

<p><img src="/assets/images/post/activationFunction.png" alt="" /></p>

<h2 id="sigmoid">Sigmoid</h2>

<h3 id="formula">Formula</h3>

<p>$$
\sigma(x) = \frac{1}{1+e^{-x}}
$$</p>

<h3 id="features">Features</h3>

<ul>
  <li>Squashes numbers to range <strong>[0, 1]</strong></li>
</ul>

<h3 id="problems">Problems</h3>

<ul>
  <li>
    <p>Saturated neurons <strong>“kill” the gradients</strong></p>
  </li>
  <li>
    <p>Sigmoid outputs are <strong>not zero-centered</strong></p>

    <blockquote>
      <p>The gradient on $w$ is always all positive or negative, so the gradient can upgrade in only one direction.</p>
    </blockquote>
  </li>
  <li>
    <p>A bit <strong>compute expensive</strong></p>
  </li>
</ul>

<h2 id="tanh">Tanh</h2>

<h3 id="formula-1">Formula</h3>

<p>$$
\tanh(x) = \frac{\sinh(x)}{\cosh(x)}=\frac{e^x-e^{-x}}{e^x+e^{-x}}
$$</p>

<h3 id="features-1">Features</h3>

<ul>
  <li>Squashes number to range <strong>[-1, 1]</strong></li>
  <li><strong>Zero centered</strong></li>
</ul>

<h3 id="problems-1">Problems</h3>

<ul>
  <li>Saturated neurons <strong>“kill” the gradients</strong></li>
</ul>

<h2 id="relu">ReLU</h2>

<h3 id="formula-2">Formula</h3>

<p>$$
f(x) = \max(0, x)
$$</p>

<h3 id="features-2">Features</h3>

<ul>
  <li><strong>Does not saturate</strong> (in &gt;0 region)</li>
  <li>Very <strong>computationally efficient</strong></li>
  <li>Converges much <strong>faster</strong></li>
  <li>More biologically plausible</li>
</ul>

<h3 id="problems-2">Problems</h3>

<ul>
  <li><strong>Not zero-centered</strong></li>
  <li><strong>“kill” the gradients</strong> (in $\le$ 0 region), what we called the <em>“dead ReLU”</em></li>
</ul>

<h2 id="leaky-relu">Leaky ReLU</h2>

<h3 id="formula-3">Formula</h3>

<p>$$
f(x) = \max(0.01x, x)
$$</p>

<h3 id="features-3">Features</h3>

<ul>
  <li>Does <strong>not saturate</strong> (in &gt;0 region)</li>
  <li>Vary <strong>computationally efficient</strong></li>
  <li>Converges much <strong>faster</strong></li>
  <li>Will <strong>not “die”</strong></li>
</ul>

<h3 id="references">References</h3>

<h4 id="parametric-rectifier-prelu">Parametric Rectifier (PReLU)</h4>

<p>$$
f(x) = \max(\alpha x, x)
$$</p>

<h2 id="elu">ELU</h2>

<h3 id="formula-4">Formula</h3>

<p>$$
f(x) = \left{ \begin{array}{lc} x &amp; if\ x &gt; 0\\alpha(\exp{(x)}-1) &amp; if\ x \le 0\end{array}\right.
$$</p>

<h3 id="features-4">Features</h3>

<ul>
  <li><strong>All</strong> benefits of ReLU</li>
  <li>Closer to zero mean outputs</li>
  <li>Negative saturation regime compared with Leaky ReLU adds some robustness to noise</li>
</ul>

<h3 id="problems-3">Problems</h3>

<ul>
  <li>Computation requires exp()</li>
</ul>

<h2 id="maxout">Maxout</h2>

<blockquote>
  <p>There is also another popular variant called <em>maxout</em> which is the generalized form above relu and leaky relu.</p>
</blockquote>

<h3 id="formula-5">Formula</h3>

<p>$$
\max(w_1^T x+b_1, w_2^T x+b_2)
$$</p>

<h3 id="features-5">Features</h3>

<ul>
  <li><strong>Generalizes</strong> ReLU and Leaky ReLU</li>
  <li>Does <strong>not saturate</strong></li>
  <li>Does <strong>not die</strong></li>
</ul>

<h3 id="problems-4">Problems</h3>

<ul>
  <li>Doubles the number of parameters / neuron</li>
</ul>

<h1 id="layers">Layers</h1>

<h2 id="fully-connected-layer">Fully Connected Layer</h2>

<p>dot product</p>

<p><img src="/assets/images/post/q1.png" alt="" /></p>

<h2 id="convolution-layer">Convolution Layer</h2>

<p><img src="/assets/images/post/cnn.png" alt="" /></p>

<p>Number of parameters in the layer: $K\times (F^2\times C + 1)$</p>

<blockquote>
  <p>$+1$ for bias</p>
</blockquote>

<h1 id="gans-generative-adversarial-network-生成对抗网络">GANS, Generative Adversarial Network 生成对抗网络</h1>

<p><img src="/assets/images/post/gan.png" alt="" /></p>

<h2 id="generative-model-g-生成器">Generative Model G 生成器</h2>

<p>Captures data distribution and generate samples close to real distribution</p>

<h2 id="discriminative-model-d-判别器">Discriminative Model D 判别器</h2>

<p>Estimates the probability that a sample came from the training data rather than G</p>

<p><img src="/assets/images/post/q0.png" alt="" /></p>

<p><img src="/assets/images/post/q2.png" alt="" /></p>

<p><img src="/assets/images/post/q3.png" alt="" /></p>

<p><img src="/assets/images/post/t0.png" alt="" /></p>

<p><img src="/assets/images/post/t1.png" alt="" /></p>

<p><img src="/assets/images/post/t2.png" alt="" /></p>

<p><img src="/assets/images/post/t3.png" alt="" /></p>]]></content><author><name>ericaaaaaaaa</name></author><category term="ArtificialIntelligence" /><category term="note" /><category term="artificial-intelligence" /><summary type="html"><![CDATA[Loss Function]]></summary></entry><entry><title type="html">Compiler</title><link href="http://localhost:4000/computerarchitecture/2021/12/22/Compiler.html" rel="alternate" type="text/html" title="Compiler" /><published>2021-12-22T00:00:00+08:00</published><updated>2021-12-22T00:00:00+08:00</updated><id>http://localhost:4000/computerarchitecture/2021/12/22/Compiler</id><content type="html" xml:base="http://localhost:4000/computerarchitecture/2021/12/22/Compiler.html"><![CDATA[<center><h1>编译实验课程设计文档</h1></center>

<h2 id="写在前面">写在前面</h2>

<p>本文档对于编译器的每个部分的实现进行了说明，大体上分为数据结构、算法思路和难点分析三个部分。</p>

<h2 id="目录">目录</h2>

<p>[toc]</p>

<h2 id="词法分析">词法分析</h2>

<h3 id="数据结构">数据结构</h3>

<p><code class="language-plaintext highlighter-rouge">Token</code></p>

<p>建立 <code class="language-plaintext highlighter-rouge">Token</code> 类，存储每个 Token 所在的行号 (lineNum)，包含的内容 (content) 和 Token 的类别 (TokenType)。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">TokenType</span> <span class="p">{</span>
    <span class="n">IDENFR</span><span class="p">,</span> <span class="n">INTCON</span><span class="p">,</span> <span class="n">STRCON</span><span class="p">,</span> <span class="n">MAINTK</span><span class="p">,</span> <span class="n">CONSTTK</span><span class="p">,</span> <span class="n">INTTK</span><span class="p">,</span> <span class="n">BREAKTK</span><span class="p">,</span>
    <span class="n">CONTINUETK</span><span class="p">,</span> <span class="n">IFTK</span><span class="p">,</span> <span class="n">ELSETK</span><span class="p">,</span> <span class="n">NOT</span><span class="p">,</span> <span class="n">AND</span><span class="p">,</span> <span class="n">OR</span><span class="p">,</span> <span class="n">WHILETK</span><span class="p">,</span> <span class="n">VOIDTK</span><span class="p">,</span>
    <span class="n">GETINTTK</span><span class="p">,</span> <span class="n">PRINTFTK</span><span class="p">,</span> <span class="n">RETURNTK</span><span class="p">,</span> <span class="n">PLUS</span><span class="p">,</span> <span class="n">MINU</span><span class="p">,</span> <span class="n">MULT</span><span class="p">,</span> <span class="n">DIV</span><span class="p">,</span> <span class="n">MOD</span><span class="p">,</span>
    <span class="n">LSS</span><span class="p">,</span> <span class="n">LEQ</span><span class="p">,</span> <span class="n">GRE</span><span class="p">,</span> <span class="n">GEQ</span><span class="p">,</span> <span class="n">EQL</span><span class="p">,</span> <span class="n">NEQ</span><span class="p">,</span> <span class="n">ASSIGN</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">,</span>
    <span class="n">SEMICN</span><span class="p">,</span> <span class="n">COMMA</span><span class="p">,</span> <span class="n">LPARENT</span><span class="p">,</span> <span class="n">RPARENT</span><span class="p">,</span> <span class="n">LBRACK</span><span class="p">,</span> <span class="n">RBRACK</span><span class="p">,</span> <span class="n">LBRACE</span><span class="p">,</span> <span class="n">RBRACE</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Token</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">lineNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 行号</span>
    <span class="n">string</span> <span class="n">content</span><span class="p">;</span> <span class="c1">// 内容</span>
    <span class="n">string</span> <span class="n">classId</span><span class="p">;</span> <span class="c1">// 类别</span>
    <span class="n">TokenType</span> <span class="n">tokenType</span> <span class="o">=</span> <span class="n">ERROR</span><span class="p">;</span>

    <span class="n">Token</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 默认构造</span>

    <span class="n">Token</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">string</span> <span class="n">c</span><span class="p">,</span> <span class="n">string</span> <span class="n">id</span><span class="p">,</span> <span class="n">TokenType</span> <span class="n">type</span><span class="p">)</span> <span class="o">:</span> 
        <span class="n">lineNum</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">classId</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">id</span><span class="p">)),</span> <span class="n">content</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span> <span class="n">tokenType</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="算法流程">算法流程</h3>

<p>以字符为单位遍历输入程序，根据下图所示的流程图，将输入字符流逐一转化为相应 Token</p>

<p><img src="/assets/images/post/resources/lexical_analysis.png" alt="" /></p>

<h3 id="难点分析">难点分析</h3>

<p>词法分析的正确实现需要细致，这体现在以下几个方面：</p>
<ul>
  <li>不漏读，不复读字符：
    <ul>
      <li>在判断当前字符所对应的 Token 类型时，若不符合当前类型，应继续分析可能的下一种 Token 类型，而非将指针向后移动，从而跳过当前字符；也不能在当前字符已符合某种 Token 类型时继续判断当前字符类型，造成字符重复使用。</li>
    </ul>
  </li>
  <li>Token 前缀相同时的判断
    <ul>
      <li>如 &lt;= 与 &lt;，&gt;= 与 &gt;，!= 与 !，== 与 = 等前缀相同的情况，需要根据后一个字符判断 Token 类型</li>
    </ul>
  </li>
</ul>

<h2 id="语法分析">语法分析</h2>

<h3 id="数据结构-1">数据结构</h3>

<h3 id="astnode"><code class="language-plaintext highlighter-rouge">ASTNode</code></h3>

<p>建立 AST 结点类 <code class="language-plaintext highlighter-rouge">ASTNode</code>，所有语法成分将继承自此节点。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ASTNode</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ASTNode</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">ASTNode</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 默认构造</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 输出形式</span>
<span class="p">};</span>
</code></pre></div></div>

<p>对文法中的每个终结符和非终结符建类，所有类均继承自 <code class="language-plaintext highlighter-rouge">ASTNode</code>，类内含有该类可推导出的语法成分的指针。</p>

<blockquote>
  <p>例：</p>
  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Exp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ASTNode</span> <span class="p">{</span> <span class="c1">// 表达式</span>
<span class="nl">public:</span>
 <span class="n">AddExp</span> <span class="o">*</span><span class="n">addExp</span><span class="p">;</span>

 <span class="n">Exp</span><span class="p">()</span> <span class="o">:</span> <span class="n">ASTNode</span><span class="p">()</span> <span class="p">{}</span>

 <span class="k">explicit</span> <span class="n">Exp</span><span class="p">(</span><span class="n">AddExp</span> <span class="o">*</span><span class="n">ae</span><span class="p">)</span> <span class="o">:</span> <span class="n">addExp</span><span class="p">(</span><span class="n">ae</span><span class="p">)</span> <span class="p">{}</span>

 <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
     <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"&lt;Exp&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>  </div>
</blockquote>

<h3 id="算法流程-1">算法流程</h3>

<ol>
  <li>消除文法中的左递归
    <blockquote>
      <p>e.g.
原文法：AddExp := MulExp | AddExp (’+’ | ‘-‘) MulExp
消除左递归后的文法：AddExp := MulExp | MulExp (’+’ | ‘-‘) AddExp</p>
    </blockquote>
  </li>
  <li>
    <p>采用 LL(n) 的方式进行语法分析，避免回溯</p>
  </li>
  <li>
    <p>构建 AST (Abstract Syntax Tree，抽象语法树)</p>

    <p>采用递归的方式对每个非终结符构建 parse 函数。</p>

    <blockquote>
      <p>例：</p>
      <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Exp</span><span class="o">*</span> <span class="nf">parseExp</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 解析 Exp 类</span>
<span class="k">auto</span> <span class="o">*</span><span class="n">exp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Exp</span><span class="p">(</span><span class="n">parseAddExp</span><span class="p">());</span> <span class="c1">// 调用 addExp 调用程序 (返回 * addExp)</span>
<span class="n">ASTTree</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">exp</span><span class="p">);</span> <span class="c1">// 将 expression 结点加入树中</span>
<span class="k">return</span> <span class="n">exp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>      </div>
    </blockquote>
  </li>
</ol>

<h3 id="难点分析-1">难点分析</h3>

<ul>
  <li>消除左递归：
    <ul>
      <li>由于原文法中存在左递归的情况，因此为了避免在语法分析中出现循环的情况，需要消除原文法中的左递归。但由于输出为根据原文法生成的语法树的后缀形式，因此在消除左递归后应适当变换，使输出满足原文法要求。</li>
    </ul>
  </li>
  <li>指针的使用
    <ul>
      <li>在设计时考虑在每个类中存储对象本身而非对象的指针，但在实现过程中，由于各个类之间存在复杂的调用关系（包括环路），因此可能需要提前使用未定义的类。因此于其在类中用对象的形式存储属性，用指针更加节约空间且灵活，除此之外，还能避免拷贝构造时发生浅拷贝等问题。</li>
    </ul>
  </li>
  <li>利用堆空间而非栈空间存储对象
    <ul>
      <li>在设计时，设想直接在 parse 函数中创建各个类的对象，但由于复杂的程序往往涉及到多层深入的调用关系，而函数内部声明的对象也有其生存周期，因此发生了程序在面对长输入程序时出现信息丢失和爆栈的情况。</li>
      <li>解决方案是用 <code class="language-plaintext highlighter-rouge">new</code> 声明对象，将各个类的对象存放在堆空间中，加长对象的生存周期，避免爆栈和信息缺失的问题。</li>
    </ul>
  </li>
</ul>

<h2 id="符号表生成">符号表生成</h2>

<h3 id="数据结构-2">数据结构</h3>

<h4 id="symbol"><code class="language-plaintext highlighter-rouge">Symbol</code></h4>

<p>建立符号类 <code class="language-plaintext highlighter-rouge">Symbol</code> 记录符号的名字，地址，维度，声明行号和使用行号等信息。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">VarType</span> <span class="p">{</span>
    <span class="n">DEFAULT</span><span class="p">,</span> <span class="n">INTCONST</span><span class="p">,</span> <span class="n">INTVAR</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Symbol</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dimension</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">VarType</span> <span class="n">varType</span> <span class="o">=</span> <span class="n">DEFAULT</span><span class="p">;</span> <span class="c1">// const?</span>
    <span class="kt">int</span> <span class="n">declareLine</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 声明行号</span>
    <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">usedLine</span><span class="p">;</span> <span class="c1">// 使用行号</span>

    <span class="n">Symbol</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">Symbol</span><span class="p">(</span><span class="k">const</span> <span class="n">Token</span><span class="o">&amp;</span> <span class="n">token</span><span class="p">,</span> <span class="n">VarType</span> <span class="n">vt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">content</span><span class="p">),</span> <span class="n">varType</span><span class="p">(</span><span class="n">vt</span><span class="p">),</span> <span class="n">dimension</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span>
                                               <span class="n">declareLine</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">lineNum</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">use</span><span class="p">(</span><span class="kt">int</span> <span class="n">lineNum</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">usedLine</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">lineNum</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="symboltable"><code class="language-plaintext highlighter-rouge">SymbolTable</code></h4>

<p>建立符号表类，用 map 的方式存储符号集 Symbol，其中，键为 Symbol 的名称，值为 Symbol 的指针</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SymbolTable</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">Symbol</span> <span class="o">*&gt;</span> <span class="n">symbols</span><span class="p">;</span> <span class="c1">// symbol 符号集</span>
    <span class="n">SymbolTable</span> <span class="o">*</span><span class="n">father</span> <span class="o">=</span> <span class="nb">nullptr</span> <span class="c1">// 指向父符号表的指针</span>
    <span class="n">list</span><span class="o">&lt;</span><span class="n">SymbolTable</span> <span class="o">*&gt;</span> <span class="n">sons</span><span class="p">;</span> <span class="c1">// 指向子符号表的指针集</span>

    <span class="n">SymbolTable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 默认构造</span>

    <span class="kt">int</span> <span class="n">insert</span><span class="p">(</span><span class="n">Symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 向符号表中插入 Symbol* sym</span>
        <span class="cm">/* return 1 on success, return 0 on failure */</span>
        <span class="n">string</span> <span class="n">sym_name</span> <span class="o">=</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">Symbol</span> <span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
        <span class="n">iter</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">sym_name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">symbols</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// not find</span>
            <span class="n">symbols</span><span class="p">[</span><span class="n">sym_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Symbol</span> <span class="o">*</span><span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">sym_name</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 在符号表及其父符号表中查找名为 sym_name 的 Symbol</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">Symbol</span> <span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
        <span class="n">iter</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">sym_name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">symbols</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// not find</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">father</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="o">*</span><span class="n">symbol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Symbol</span><span class="p">();</span>
                <span class="k">return</span> <span class="n">symbol</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">father</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">sym_name</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">SymbolTable</span> <span class="o">*</span><span class="n">newSon</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 建立子符号表并返回其指针</span>
        <span class="k">auto</span> <span class="o">*</span><span class="n">symbolTable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SymbolTable</span><span class="p">();</span>
        <span class="n">symbolTable</span><span class="o">-&gt;</span><span class="n">father</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">sons</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">symbolTable</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">symbolTable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">SymbolTable</span> <span class="o">*</span><span class="n">newBrother</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 建立兄弟符号表返回其指针</span>
        <span class="k">auto</span> <span class="o">*</span><span class="n">symbolTable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SymbolTable</span><span class="p">();</span>
        <span class="n">symbolTable</span><span class="o">-&gt;</span><span class="n">father</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">father</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">father</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">father</span><span class="o">-&gt;</span><span class="n">sons</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">symbolTable</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">symbolTable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">SymbolTable</span> <span class="o">*</span><span class="n">back</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="c1">// 返回父符号表的指针</span>
        <span class="k">return</span> <span class="n">father</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="算法流程-2">算法流程</h3>

<p>建立根符号表，并将当前符号表的指针指向根符号表。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SymbolTable</span> <span class="o">*</span><span class="n">symbolTable</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">SymbolTable</span><span class="p">();</span>
<span class="n">SymbolTable</span> <span class="o">*</span><span class="n">currentSymbolTable</span> <span class="o">=</span> <span class="n">symbolTable</span><span class="p">;</span>
</code></pre></div></div>

<p>每当进入一个新的 Block 或新的函数时，建立新的子符号表，并将当前符号表的指针 <code class="language-plaintext highlighter-rouge">currentSymbolTable</code> 指向新的子符号表。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Block</span><span class="o">*</span> <span class="nf">parseBlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">currentSymbolTable</span> <span class="o">=</span> <span class="n">currentSymbolTable</span><span class="o">-&gt;</span><span class="n">newSon</span><span class="p">();</span>
    <span class="c1">// ...</span>
    <span class="n">currentSymbolTable</span> <span class="o">=</span> <span class="n">currentSymbolTable</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>    
<span class="p">}</span>
</code></pre></div></div>

<p>当遇到声明 (<code class="language-plaintext highlighter-rouge">Decl</code>) 语句和函数形参声明时，向符号表中填入 Symbol 并检查是否存在重名问题</p>

<p>在 <code class="language-plaintext highlighter-rouge">Stmt</code> 中使用符号时，由当前符号表逐层向上检索所用符号名和符号类型，检查是否存在未定义和改变 const 值等问题。</p>

<h3 id="难点分析-2">难点分析</h3>

<p>符号表实现中的困难主要来自于对变量生存周期和作用域的理解。</p>

<p>在函数中，形参和函数体应共享一个符号表，而不能因为函数体为 <code class="language-plaintext highlighter-rouge">Block</code> 而创建只属于函数体的符号表。因此在进入 <code class="language-plaintext highlighter-rouge">parseBlock</code> 时，应首先判断是否在函数体内，若是，则不创建新符号表，否则创建新的子符号表，并将当前符号表的指针指向该符号表。</p>

<h2 id="函数表生成">函数表生成</h2>

<h3 id="数据结构-3">数据结构</h3>

<h4 id="function"><code class="language-plaintext highlighter-rouge">Function</code></h4>

<p>建立 Function 类，存储函数名，形参和返回值等信息</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">ReturnType</span> <span class="p">{</span>
    <span class="n">VOID</span><span class="p">,</span> <span class="n">INT</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Function</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="c1">// 函数名</span>
    <span class="n">ReturnType</span> <span class="n">returnType</span> <span class="o">=</span> <span class="n">VOID</span><span class="p">;</span> <span class="c1">// 函数返回值类型</span>
    <span class="n">list</span><span class="o">&lt;</span><span class="n">Symbol</span> <span class="o">*&gt;</span> <span class="n">parameters</span><span class="p">;</span>

    <span class="n">Function</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">Function</span><span class="p">(</span><span class="n">string</span> <span class="n">n</span><span class="p">,</span> <span class="n">ReturnType</span> <span class="n">rt</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">Symbol</span> <span class="o">*&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="n">returnType</span><span class="p">(</span><span class="n">rt</span><span class="p">),</span> <span class="n">parameters</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{}</span>

    <span class="kt">int</span> <span class="n">paramsMatch</span><span class="p">(</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Symbol</span> <span class="o">*&gt;</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 判断函数参数个数，类别是否吻合</span>
        <span class="cm">/* return: 0 -- success, -1 -- number doesn't fit, -2 -- type doesn't fit */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parameters</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">params</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">require_iter</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="k">auto</span> <span class="n">get_iter</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">require_iter</span> <span class="o">!=</span> <span class="n">parameters</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="n">require_iter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">varType</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">get_iter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">varType</span> <span class="o">&amp;&amp;</span>
                      <span class="p">(</span><span class="o">*</span><span class="n">require_iter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dimension</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">get_iter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dimension</span><span class="p">))</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
                <span class="o">++</span><span class="n">require_iter</span><span class="p">;</span>
                <span class="o">++</span><span class="n">get_iter</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="functiontable"><code class="language-plaintext highlighter-rouge">FunctionTable</code></h4>

<p>建立函数表 <code class="language-plaintext highlighter-rouge">FunctionTable</code>，用于存储全部声明函数的函数名，返回值等信息。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FunctionTable</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">Function</span> <span class="o">*&gt;</span> <span class="n">functions</span><span class="p">;</span> <span class="c1">// 用 map 存储全部声明函数</span>

    <span class="n">FunctionTable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 默认构造</span>

    <span class="kt">int</span> <span class="n">insert</span><span class="p">(</span><span class="n">Function</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* return 1 on success, return 0 on failure */</span>
        <span class="n">string</span> <span class="n">func_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">Function</span> <span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span> 
        <span class="n">iter</span> <span class="o">=</span> <span class="n">functions</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">func_name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">functions</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// not find</span>
            <span class="n">functions</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Function</span> <span class="o">*</span><span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">func_name</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 在函数表中寻找名为 func_name 的函数</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">Function</span> <span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
        <span class="n">iter</span> <span class="o">=</span> <span class="n">functions</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">func_name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">functions</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// not find</span>
            <span class="k">auto</span> <span class="o">*</span><span class="n">function</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Function</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="算法流程-3">算法流程</h3>

<p>建立全局函数表 functionTable，每声明一个新的函数时向其中加入 Function 并判断函数是否存在重名等问题。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FunctionTable</span> <span class="o">*</span><span class="n">functionTable</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">FunctionTable</span><span class="p">();</span>
</code></pre></div></div>

<p>每次用到函数时在函数表中根据函数名查找函数，判断是否存在未声明的问题。若函数已经声明，则进一步判断参数个数与类型是否与声明中相吻合。</p>

<h3 id="难点分析-3">难点分析</h3>

<p>函数表中不仅需要记录函数名和返回值等信息，还需记录函数参数个数和类型等信息。</p>

<h2 id="错误处理">错误处理</h2>

<h3 id="数据结构-4">数据结构</h3>

<h4 id="error"><code class="language-plaintext highlighter-rouge">Error</code></h4>

<p>建立 <code class="language-plaintext highlighter-rouge">Error</code> 类，存储错误行号和错误类型</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Error</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">lineNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 错误行号</span>
    <span class="n">string</span> <span class="n">errorType</span><span class="p">;</span> <span class="c1">// 错误类型</span>

    <span class="n">Error</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 默认构造</span>

    <span class="n">Error</span><span class="p">(</span><span class="kt">int</span> <span class="n">ln</span><span class="p">,</span> <span class="n">string</span> <span class="n">et</span><span class="p">)</span> <span class="o">:</span> <span class="n">lineNum</span><span class="p">(</span><span class="n">ln</span><span class="p">),</span> <span class="n">errorType</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">et</span><span class="p">))</span> <span class="p">{}</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">Error</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">lineNum</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">errorType</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="算法流程-4">算法流程</h3>

<p>建立全局错误队列，存储所有程序中出现的错误，由于错误处理的输出需要有序，因此在输出前统一对错误进行排序，再逐一输出。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">*&gt;</span> <span class="n">errors</span><span class="p">;</span>
</code></pre></div></div>

<p>错误处理办法：</p>
<ul>
  <li>分析每个错误所有可能出现的位置</li>
  <li>在语法分析建立 AST 的同时对生成符号表、函数表并对错误进行判断。</li>
  <li>每判断出一个错误将错误的行号和类型码存储在 Error 类中，并将其加入 errors</li>
</ul>

<table>
  <thead>
    <tr>
      <th>错误类别码</th>
      <th>错误类型</th>
      <th>判断方法</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a</td>
      <td>非法符号</td>
      <td>当 Token 为 STRCONST 时，对格式字符串的合法性进行判断。</td>
    </tr>
    <tr>
      <td>b</td>
      <td>名字重定义</td>
      <td>建立符号表与函数表，每定义新的符号 / 函数时向表中添加，当前符号 / 函数名在当前作用域内已定义，则产生名字重定义问题。</td>
    </tr>
    <tr>
      <td>c</td>
      <td>未定义的名字</td>
      <td>在使用变量和函数时在符号表和函数表中查询，若无法查询到，则证明出现未定义的名字。</td>
    </tr>
    <tr>
      <td>d</td>
      <td>函数参数个数不匹配</td>
      <td>在函数声明时在 Function 类中存储函数的形参信息（类别、数量、顺序），在调用函数时记录传递参数的信息，并于 Function 中的参数个数相对比，若不同，则抛出函数参数个数不匹配的错误</td>
    </tr>
    <tr>
      <td>e</td>
      <td>函数参数类型不匹配</td>
      <td>函数声明时在 Function 类中存储函数的形参信息（类别、数量、顺序），在调用函数时记录传递参数的信息，并于 Function 中的参数类型（类型、维度）相对比，若不同，则抛出函数参数个数不匹配的错误</td>
    </tr>
    <tr>
      <td>f</td>
      <td>无返回值的函数存在不匹配的 <code class="language-plaintext highlighter-rouge">return</code></td>
      <td>在函数声明时，若函数的 returnType 为 VOIDTK，则获取函数块内最后一条语句，若其为 return 语句且不为 "return;"，则报错</td>
    </tr>
    <tr>
      <td>g</td>
      <td>有返回值的函数缺少 return 语句</td>
      <td>在函数声明时，若函数的 returnType 为 INTTK，则获取函数块内最后一条语句，若其不为 return 语句，则报错</td>
    </tr>
    <tr>
      <td>h</td>
      <td>不能改变常量的值</td>
      <td>在变量声明并加入符号表时存储其是否为 const，在对变量赋值时，若变量存在且为 INTCONST，则报错</td>
    </tr>
    <tr>
      <td>i</td>
      <td>缺少分号</td>
      <td>在 parse 函数遇到 <code class="language-plaintext highlighter-rouge">auto *semicn = new Semicn(*(iter++));</code> 时将其替换为先检查当前 iter 的 Token 类是否为 SEMICN，若是，则重复之前的操作，若不是，则自动补全分号并抛出 i 型错误</td>
    </tr>
    <tr>
      <td>j</td>
      <td>缺少右小括号</td>
      <td>在 parse 函数遇到 <code class="language-plaintext highlighter-rouge">auto *rparent = new Rparent(*(iter++));</code> 时将其替换为先检查当前 iter 的 Token 类是否为 RPARENT，若是，则重复之前的操作，若不是，则自动补全右小括号并抛出 j 型错误</td>
    </tr>
    <tr>
      <td>k</td>
      <td>缺少右中括号</td>
      <td>在 parse 函数遇到 <code class="language-plaintext highlighter-rouge">auto *rbrack = new Rbrack(*(iter++));</code> 时将其替换为先检查当前 iter 的 Token 类是否为 RBRACK，若是，则重复之前的操作，若不是，则自动补全右中括号并抛出 k 型错误</td>
    </tr>
    <tr>
      <td>l</td>
      <td><code class="language-plaintext highlighter-rouge">printf</code> 中格式字符串与表达式个数不匹配</td>
      <td>在语法分析的过程中，在遇到 Stmt -&gt; printf ‘(’ FormatString {, Exp} ‘)’ 时记录 Exp 的数量和 FormatString 中 ‘%d’ 的数量，将两者对比，若不同，则抛出 l 型错误</td>
    </tr>
    <tr>
      <td>m</td>
      <td>在非循环块中使用 <code class="language-plaintext highlighter-rouge">break</code> 和 <code class="language-plaintext highlighter-rouge">continue</code> 语句</td>
      <td>设立 recursive 变量，用于记录所在的循环层数，当循环层数为 0 (不处于任何循环当中时)，若出现 <code class="language-plaintext highlighter-rouge">break</code> 和 <code class="language-plaintext highlighter-rouge">continue</code> 则抛出 m 类型错误。</td>
    </tr>
  </tbody>
</table>

<h3 id="难点分析-4">难点分析</h3>

<p>错误处理考察实现细节，需要对每种错误可能出现的情况进行详细的讨论，并适当修改语法分析代码。</p>

<p>另外，对于“缺失”类型的错误，需要注意不让程序进入死循环。</p>

<p>例：在语法分析中，读取函数形参 parseFuncFParams 在读入右小括号时退出</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(...)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">iter</span><span class="p">).</span><span class="n">tokenType</span> <span class="o">==</span> <span class="n">LBRACK</span><span class="p">)</span> <span class="p">{</span>
    	<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但需要考虑右小括号缺失的情况，此时应添加条件判断，即：若读入 <code class="language-plaintext highlighter-rouge">{</code> （代表进入函数体），也视作函数形参输入完成，且抛出右小括号缺失类型错误。</p>

<h2 id="中间代码生成">中间代码生成</h2>

<p>中间代码采用 SSA（静态单一赋值）的形式，采用类似 LLVMIR 的语言，便于后续优化。</p>

<blockquote>
  <p>在静态单一赋值的代码中，每个变量仅被赋值一次。生成 SSA 形式的中间代码极大的简化了优化的实现和优化程序的效率，但缺点在于构建 SSA 形式的代码难度较大。</p>
</blockquote>

<h3 id="中间代码语法简述">中间代码语法简述</h3>

<p>由于中间代码并不需要真正被 LLVM 编译器编译通过，因此在实现上以方便书写且满足 SSA 规范为准，在具体语法上可能与标准的 LLVM 有所差异。</p>

<h4 id="类型">类型</h4>

<p>中间代码中需要对变量的类型进行标识，为了使得优化程序更好的对于各个不同的变量类型执行相应的优化操作，因此选择保留尽量多的信息。如：源程序中的 int 在中间代码中可以对应全局变量和局部变量。</p>

<p>中间代码中所使用的变量 / 常量类型如下：</p>

<ul>
  <li>
    <p>临时变量 <code class="language-plaintext highlighter-rouge">TEMP</code></p>

    <p>在定义后使用一次即消亡的变量，不对应程序中的变量，用于在计算时保存临时结果。</p>
  </li>
  <li>
    <p>全局变量 <code class="language-plaintext highlighter-rouge">INTGLOBAL</code></p>

    <p>对应程序中全局声明的 <code class="language-plaintext highlighter-rouge">int</code> 类型。</p>
  </li>
  <li>
    <p>全局常量 <code class="language-plaintext highlighter-rouge">INTGLOBALCONST</code></p>

    <p>对应程序中全局声明的 <code class="language-plaintext highlighter-rouge">const int</code> 类型。</p>
  </li>
  <li>
    <p>局部变量 <code class="language-plaintext highlighter-rouge">INTLOCAL</code></p>

    <p>对应程序中局部声明的 <code class="language-plaintext highlighter-rouge">int</code> 类型。</p>
  </li>
  <li>
    <p>局部常量 <code class="language-plaintext highlighter-rouge">INTLOCALCONST</code></p>

    <p>对应程序中局部声明的 <code class="language-plaintext highlighter-rouge">const int</code> 类型。</p>
  </li>
  <li>
    <p>指针变量 <code class="language-plaintext highlighter-rouge">POINTER</code></p>

    <p>对应程序中声明的局部数组类型。</p>
  </li>
  <li>
    <p>数字 <code class="language-plaintext highlighter-rouge">NUMBER</code></p>

    <p>对应程序中的立即数。</p>
  </li>
  <li>
    <p>字符串 <code class="language-plaintext highlighter-rouge">FORMATSTRING</code></p>

    <p>对应程序中 <code class="language-plaintext highlighter-rouge">printf</code> 中的字符串。</p>
  </li>
  <li>
    <p>函数名称 <code class="language-plaintext highlighter-rouge">FUNCTIONNAME</code></p>

    <p>对应程序中的函数名。</p>
  </li>
  <li>
    <p>label <code class="language-plaintext highlighter-rouge">LABEL</code></p>

    <p>用于表示基本块的开始和便于基本块之间跳转语句的正常实现。</p>
  </li>
</ul>

<p>为了能够更加直观的在输出到文件中的中间代码中辨识各个变量类型，对每种类型均定义了不同的输出方式，如下：</p>

<table>
  <thead>
    <tr>
      <th>变量类型</th>
      <th>输出方式</th>
      <th>举例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">TEMP</code></td>
      <td><code class="language-plaintext highlighter-rouge">i32 ${id}</code></td>
      <td><code class="language-plaintext highlighter-rouge">i32 $1</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">INTGLOBAL</code> or <code class="language-plaintext highlighter-rouge">INTGLOBALCONST</code></td>
      <td><code class="language-plaintext highlighter-rouge">i32 @{id}</code> or <code class="language-plaintext highlighter-rouge">[{size} * i32]* @{id}</code></td>
      <td><code class="language-plaintext highlighter-rouge">i32 @0</code>, <code class="language-plaintext highlighter-rouge">[3 * i32] @4</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">INTLOCAL</code> or <code class="language-plaintext highlighter-rouge">INTLOCALCONST</code></td>
      <td><code class="language-plaintext highlighter-rouge">i32 %{id}</code></td>
      <td><code class="language-plaintext highlighter-rouge">i32 %5</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">POINTER</code></td>
      <td><code class="language-plaintext highlighter-rouge">i32* %{id}</code> or <code class="language-plaintext highlighter-rouge">[size * i32]* %{id}</code></td>
      <td><code class="language-plaintext highlighter-rouge">i32* %1</code> or <code class="language-plaintext highlighter-rouge">[2 * i32]* %5</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LABEL</code></td>
      <td><code class="language-plaintext highlighter-rouge">label{id}</code> or <code class="language-plaintext highlighter-rouge">main</code></td>
      <td><code class="language-plaintext highlighter-rouge">label1</code> or <code class="language-plaintext highlighter-rouge">main</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FUNCTIONNAME</code></td>
      <td><code class="language-plaintext highlighter-rouge">@{name}</code></td>
      <td><code class="language-plaintext highlighter-rouge">@func</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">NUMBER</code></td>
      <td><code class="language-plaintext highlighter-rouge">i32 {number}</code></td>
      <td><code class="language-plaintext highlighter-rouge">i32 512</code></td>
    </tr>
  </tbody>
</table>

<h4 id="语句">语句</h4>

<p>中间代码的语句主要分为一下几种：</p>

<ul>
  <li>声明语句</li>
  <li>算数语句：实现基本的加减乘除等操作，变量类型可以为 <code class="language-plaintext highlighter-rouge">TEMP</code> 或 <code class="language-plaintext highlighter-rouge">NUMBER</code>
    <ul>
      <li>双目运算
        <ul>
          <li>算数运算 (<code class="language-plaintext highlighter-rouge">ADDIR</code>, <code class="language-plaintext highlighter-rouge">SUBIR</code>, <code class="language-plaintext highlighter-rouge">MULIR</code>, <code class="language-plaintext highlighter-rouge">DIVIR</code>, <code class="language-plaintext highlighter-rouge">MODIR</code>)</li>
          <li>逻辑运算 (<code class="language-plaintext highlighter-rouge">ANDIR</code>, <code class="language-plaintext highlighter-rouge">ORIR</code>, <code class="language-plaintext highlighter-rouge">EQIR</code>, <code class="language-plaintext highlighter-rouge">NEQIR</code>, <code class="language-plaintext highlighter-rouge">GREIR</code>, <code class="language-plaintext highlighter-rouge">GEQIR</code>, <code class="language-plaintext highlighter-rouge">LSSIR</code>, <code class="language-plaintext highlighter-rouge">LEQIR</code>)</li>
        </ul>
      </li>
      <li>单目运算
        <ul>
          <li>算数运算 (<code class="language-plaintext highlighter-rouge">ADDSINGLEIR</code>, <code class="language-plaintext highlighter-rouge">SUBSINGLEIR</code>)</li>
          <li>逻辑运算 (<code class="language-plaintext highlighter-rouge">NOTIR</code>)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>跳转语句
    <ul>
      <li>无条件跳转 (<code class="language-plaintext highlighter-rouge">BR</code>)</li>
      <li>有条件跳转 (<code class="language-plaintext highlighter-rouge">BRTRUE</code>, <code class="language-plaintext highlighter-rouge">BRFALSE</code>)</li>
      <li>跳转并移动栈指针（由于存在 <code class="language-plaintext highlighter-rouge">continue</code> 和 <code class="language-plaintext highlighter-rouge">break</code> 语句，在跳转时可能出现跳转前后栈指针不一致的情况，因此这种指令需要在跳转后将栈指针移动至正确的位置）<code class="language-plaintext highlighter-rouge">BRCHECK</code></li>
    </ul>
  </li>
  <li>函数相关语句
    <ul>
      <li>函数定义 (<code class="language-plaintext highlighter-rouge">FUNCDECLIR</code>)</li>
      <li>函数调用 (<code class="language-plaintext highlighter-rouge">CALL</code>)</li>
      <li>函数返回 (<code class="language-plaintext highlighter-rouge">RET</code>)</li>
    </ul>
  </li>
  <li>存取语句 (<code class="language-plaintext highlighter-rouge">LOAD</code>, <code class="language-plaintext highlighter-rouge">STORE</code>, <code class="language-plaintext highlighter-rouge">GETPOINTER</code>)，其中，<code class="language-plaintext highlighter-rouge">GETPOINTER</code> 可获得数组相应位置的地址</li>
  <li>mem2reg 相关语句 (<code class="language-plaintext highlighter-rouge">MEM2REGASSIGN</code>, <code class="language-plaintext highlighter-rouge">MEM2REGMOVE</code>)</li>
  <li>其它语句（用于标识程序中 Block 的开始和结尾，便于栈指针移动至正确位置）
    <ul>
      <li><code class="language-plaintext highlighter-rouge">LBRACEIR</code>, <code class="language-plaintext highlighter-rouge">RBRACEIR</code>, <code class="language-plaintext highlighter-rouge">LSHARPIR</code>, <code class="language-plaintext highlighter-rouge">RSHARPIR</code></li>
    </ul>
  </li>
</ul>

<p>为了能更清楚的在输出后的中间代码中辨识语句类型，对每种语句定义了相应的输出操作。</p>

<h4 id="mem2reg-与-phi">mem2reg 与 phi</h4>

<p>静态单一赋值要求同一个变量只能被赋值一次，但遇到下图所示的情况，应当如何确定应该输出哪一个 i 的值呢？</p>

<p>一个最简单的实现办法就是利用 LOAD 和 STORE 语句，每次直接从内存中读写，而不需要考虑具体应当取哪一种赋值（如下图中左边代码所示），但这样做显然效率不高，大量的存取指令会占用大量的程序运行时间。</p>

<p>为了能够提高程序的运行效率，需要消解 LOAD 与 STORE 语句，将其变为 SSA 形式的赋值语句，而实现从 LOAD, STORE 到 SSA 的转化的步骤就被称作 mem2reg。为了使程序能够在具有分支的情况下依然保持正确性，引入 phi 指令。</p>

<p>phi 指令的语法是</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">val0</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">label0</span><span class="o">&gt;</span><span class="p">],</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">val1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">label1</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">...</span>
</code></pre></div></div>

<p>phi 指令被安排在每个基本块的最开头，且执行没有先后顺序。phi 指令中的 label 对应着基本块的前驱，而 val 则是 result 可能的取值。</p>

<p>举例来说，下图中右面的代码就是插入了 phi 的代码。其中，语句 <code class="language-plaintext highlighter-rouge">&amp;4 = phi [&amp;2, label1] [&amp;3, label2]</code> 代表若从 label1 跳转至该基本块，则 <code class="language-plaintext highlighter-rouge">&amp;4</code> 取 <code class="language-plaintext highlighter-rouge">&amp;2</code> 的值，否则若从 label2 跳转至该基本块，<code class="language-plaintext highlighter-rouge">&amp;4</code> 取 <code class="language-plaintext highlighter-rouge">&amp;3</code> 的值。</p>

<p><img src="/assets/images/post/mem2reg.png" alt="" /></p>

<h3 id="数据结构-5">数据结构</h3>

<h4 id="value"><code class="language-plaintext highlighter-rouge">Value</code></h4>

<p>在 SSA 形式的中间代码中，包括变量、常量、label 等一切皆是 <code class="language-plaintext highlighter-rouge">Value</code>，因此建立 <code class="language-plaintext highlighter-rouge">Value</code> 类以及其对应的 <code class="language-plaintext highlighter-rouge">VarType</code> 枚举类。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">VarType</span> <span class="p">{</span>
    <span class="n">DEFAULT</span><span class="p">,</span> <span class="n">INTCONST</span><span class="p">,</span> <span class="n">INTVAR</span><span class="p">,</span> <span class="n">VOIDVAR</span><span class="p">,</span>
    <span class="n">INTGLOBAL</span><span class="p">,</span> <span class="n">INTGLOBALCONST</span><span class="p">,</span> <span class="n">INTLOCAL</span><span class="p">,</span> <span class="n">INTLOCALCONST</span><span class="p">,</span>
    <span class="n">LABEL</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">NUMBER</span><span class="p">,</span> <span class="n">FUNCTIONNAME</span><span class="p">,</span> <span class="n">FORMATSTRING</span><span class="p">,</span>
    <span class="n">TEMP</span><span class="p">,</span> <span class="n">STRING</span><span class="p">,</span> <span class="n">PMET</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Value</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span> <span class="c1">// 独一无二的 id，若为 NUMBER 则 id 为其对应的值</span>
    <span class="n">VarType</span> <span class="n">varType</span> <span class="o">=</span> <span class="n">DEFAULT</span><span class="p">;</span> <span class="c1">// Value 类型</span>
    <span class="kt">int</span> <span class="n">symbolTableId</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 对应的符号表</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="c1">// 对应的函数名或变量名</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 变量大小</span>
    <span class="kt">int</span> <span class="n">declLine</span><span class="p">;</span> <span class="c1">// 定义变量的行号</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">useLine</span><span class="p">;</span> <span class="c1">// 使用变量的行号</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="llvmir"><code class="language-plaintext highlighter-rouge">LLVMIR</code></h4>

<p>建立中间代码类 <code class="language-plaintext highlighter-rouge">LLVMIR</code> 以及其对应的枚举类 <code class="language-plaintext highlighter-rouge">IRType</code>，用于表示各类中间代码，它的构造函数接受不同数量的 <code class="language-plaintext highlighter-rouge">Value</code> 和 <code class="language-plaintext highlighter-rouge">IRType</code>，生成各种形式的 IR。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">IRType</span> <span class="p">{</span>
    <span class="n">IRTYPE</span><span class="p">,</span> <span class="c1">// DEFAULT</span>
    <span class="n">ADDIR</span><span class="p">,</span> <span class="n">SUBIR</span><span class="p">,</span> <span class="n">MULIR</span><span class="p">,</span> <span class="n">DIVIR</span><span class="p">,</span> <span class="n">MODIR</span><span class="p">,</span> <span class="c1">// 加减乘除</span>
    <span class="n">ANDIR</span><span class="p">,</span> <span class="n">ORIR</span><span class="p">,</span> <span class="n">EQIR</span><span class="p">,</span> <span class="n">NEQIR</span><span class="p">,</span> <span class="c1">// 与或非、等于、不等于</span>
    <span class="n">NOTIR</span><span class="p">,</span> <span class="n">ADDSINGLEIR</span><span class="p">,</span> <span class="n">SUBSINGLEIR</span><span class="p">,</span> <span class="c1">// 单目运算</span>
    <span class="n">GREIR</span><span class="p">,</span> <span class="n">GEQIR</span><span class="p">,</span> <span class="n">LSSIR</span><span class="p">,</span> <span class="n">LEQIR</span><span class="p">,</span> <span class="c1">// 比较运算</span>
    <span class="n">BR</span><span class="p">,</span> <span class="n">RET</span><span class="p">,</span> <span class="n">CALL</span><span class="p">,</span> <span class="n">BRTRUE</span><span class="p">,</span> <span class="n">BRFALSE</span><span class="p">,</span> <span class="n">BRCHECK</span><span class="p">,</span> <span class="c1">// 跳转运算</span>
    <span class="n">FUNCDECLIR</span><span class="p">,</span> <span class="n">GLOBALDECLIR</span><span class="p">,</span> <span class="n">LOCALDECLIR</span><span class="p">,</span> <span class="n">CONSTDECLIR</span><span class="p">,</span> <span class="c1">// 定义（函数、全局、局部、常量）</span>
    <span class="n">LOAD</span><span class="p">,</span> <span class="n">STORE</span><span class="p">,</span> <span class="n">ALLOCA</span><span class="p">,</span> <span class="n">LABELIR</span><span class="p">,</span> <span class="n">ASSIGNIR</span><span class="p">,</span> <span class="n">TEMPALLOCA</span><span class="p">,</span> <span class="c1">// 存取运算</span>
    <span class="n">LBRACEIR</span><span class="p">,</span> <span class="n">RBRACEIR</span><span class="p">,</span> <span class="n">LSHARPIR</span><span class="p">,</span> <span class="n">RSHARPIR</span><span class="p">,</span> <span class="c1">// 大括号 / 中括号（用于标记 Block 的始末，便于 stack pointer 移动到正确的位置）</span>
    <span class="n">GETPOINTERIR</span><span class="p">,</span> <span class="c1">// 数组取地址</span>
    <span class="n">MEM2REGASSIGN</span><span class="p">,</span> <span class="n">MEM2REGMOVE</span><span class="p">,</span> <span class="n">TEMPPHI</span><span class="p">,</span> <span class="n">PHI</span> <span class="c1">// mem2reg 有关指令</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">LLVMIR</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">IRType</span> <span class="n">irType</span> <span class="o">=</span> <span class="n">IRTYPE</span><span class="p">;</span> <span class="c1">// IR 类型</span>
    <span class="kt">int</span> <span class="n">lineNum</span><span class="p">;</span> <span class="c1">// IR 行号</span>
    <span class="kt">int</span> <span class="n">blockLineNum</span><span class="p">;</span> <span class="c1">// 在 BasicBlock 中的行号（在变量冲突分析时使用）</span>
    <span class="c1">// 以下属性均为 LLVMIR 构造时需要用到的参数</span>
    <span class="n">Value</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Value</span> <span class="o">*&gt;</span> <span class="n">params</span><span class="p">;</span>
    <span class="n">Variable</span> <span class="o">*</span><span class="n">variable</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Variable</span> <span class="o">*&gt;</span> <span class="n">varParams</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">labels</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">valueId</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="basicblock"><code class="language-plaintext highlighter-rouge">BasicBlock</code></h4>

<p><code class="language-plaintext highlighter-rouge">BasicBlock</code> 的含义是”基本块“，用来表示一段连续执行的程序序列。基本块中的代码只能顺序执行，只能从开头进入，从结尾离开。将程序划分为基本块的优点在于便于分析程序的控制流，从而使得优化能够更加方便的完成。</p>

<p>由基本块的特性，定义对应的类及其属性如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BasicBlock</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span> <span class="c1">// 每个 BasicBlock 独有的 id, 对应其开头的 label 值</span>
    <span class="kt">int</span> <span class="n">dfnNum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 深度优先搜索遍历顺序，在构建控制流图时使用</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">BasicBlock</span> <span class="o">*&gt;</span> <span class="n">precursor</span><span class="p">;</span> <span class="c1">// 前驱基本块</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">BasicBlock</span> <span class="o">*&gt;</span> <span class="n">successor</span><span class="p">;</span> <span class="c1">// 后继基本块</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">BasicBlock</span> <span class="o">*&gt;</span> <span class="n">bucket</span><span class="p">;</span> <span class="c1">// 深度优先搜索树中的孩子节点，在构建控制流图时使用</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">BasicBlock</span> <span class="o">*&gt;</span> <span class="n">strictDominator</span><span class="p">;</span> <span class="c1">// 严格支配基本块</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">BasicBlock</span> <span class="o">*&gt;</span> <span class="n">dominanceFrontier</span><span class="p">;</span> <span class="c1">// 支配边界</span>
    <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">sdom</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// 直接支配基本块</span>
    <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">idom</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// 半支配基本块</span>
    <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">dfsFather</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// 深度优先搜索树中的父亲节点</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">defValue</span><span class="p">;</span> <span class="c1">// 当前基本块中定义的变量</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">useValue</span><span class="p">;</span> <span class="c1">// 当前基本块中使用的变量</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">phis</span><span class="p">;</span> <span class="c1">// 当前基本块开头插入的 phi 指令</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">def</span><span class="p">;</span> <span class="c1">// 当前基本块中定义的变量及其定义行号</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">use</span><span class="p">;</span> <span class="c1">// 当前基本块中使用的变量及其使用行号</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">defBeforeUse</span><span class="p">;</span> <span class="c1">// 当前基本块中定义先于使用的变量</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">useBeforeDef</span><span class="p">;</span> <span class="c1">// 当前基本快中使用先于定义的变量</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">;</span> <span class="c1">// 进入基本快的数据流</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">;</span> <span class="c1">// 从基本快中出来的数据流</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="edge"><code class="language-plaintext highlighter-rouge">Edge</code></h4>

<p>为了更方便的得到控制流图，还需要了解基本块之间的跳转关系，对应图论中两个节点之间的边，因此定义边类 <code class="language-plaintext highlighter-rouge">Edge</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Edge</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">source</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// 边的起始点</span>
    <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// 边的终点</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="算法流程-5">算法流程</h3>

<h4 id="0-判断代码是否存在错误">0. 判断代码是否存在错误</h4>

<p>若代码有错误，则直接退出程序。在需要编译的代码无语法错误时，进入中间代码生成程序。</p>

<h4 id="1-含有-alloca-load-store-的中间代码">1. 含有 ALLOCA, LOAD, STORE 的中间代码</h4>

<p>遍历语法树，对其中的每一个节点建立 <code class="language-plaintext highlighter-rouge">CodeGen</code> 函数，并返回一个 <code class="language-plaintext highlighter-rouge">Value</code> 值。</p>

<p>例如，对于 <code class="language-plaintext highlighter-rouge">AddExp</code>，其在文法中的定义为 <code class="language-plaintext highlighter-rouge">AddExp -&gt; MulExp | AddExp ('+' | '-') MulExp</code>，由定义可知，<code class="language-plaintext highlighter-rouge">AddExp</code> 需要将 <code class="language-plaintext highlighter-rouge">MulExp</code> 计算出的结果进行加法或减法操作并返回计算结果。故其生成中间代码的函数为：（只展示主题结构）</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Value</span><span class="o">*</span> <span class="n">AddExp</span><span class="o">::</span><span class="n">codeGen</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">mulExps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codeGen</span><span class="p">();</span>
    <span class="kt">size_t</span> <span class="n">length</span> <span class="o">=</span> <span class="n">addSubASTs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="o">*</span><span class="n">temp_val</span> <span class="o">=</span> <span class="n">mulExps</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codeGen</span><span class="p">();</span> <span class="c1">// 调用每个 MulExp 的 codeGen 函数，得到 MulExp 的运算结果。</span>
        <span class="c1">// ...</span>
        <span class="n">midCode</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">LLVMIR</span><span class="p">((</span><span class="n">opType</span> <span class="o">==</span> <span class="n">PLUS</span> <span class="o">?</span> <span class="n">ADDIR</span> <span class="o">:</span> <span class="n">SUBIR</span><span class="p">),</span> <span class="n">llvmLineNumber</span><span class="o">++</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">params</span><span class="p">));</span> <span class="c1">// 根据运算符生成对应的中间代码（加法 / 减法）</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>将遍历语法树时产生的所有中间代码都保存在全局的 <code class="language-plaintext highlighter-rouge">midCode</code> 中，便于之后进行多遍优化。</p>

<p>需要注意的是，由于中间代码需要保持静态单一赋值的特性，因此所有对变量的定义均转化为 <code class="language-plaintext highlighter-rouge">ALLOCA</code> 语句，意为直接为变量分配一段内存；所有对变量的取值操作则转化为 <code class="language-plaintext highlighter-rouge">LOAD</code> 语句，意为从内存中读相应值；而所有对变量的赋值操作则转化为 <code class="language-plaintext highlighter-rouge">STORE</code>，意为向内存中存入相应值。</p>

<p>特别的，对于数组，用 <code class="language-plaintext highlighter-rouge">GETPOINTER</code> 指令获取数组的首地址，再用 <code class="language-plaintext highlighter-rouge">LOAD</code> 和 <code class="language-plaintext highlighter-rouge">STORE</code> 指令对数组内容进行存取。</p>

<h4 id="2-mem2reg">2. mem2reg</h4>

<p>mem2reg 需要将 load / store 形式的中间代码通过插入 phi 的方式转化为 phi 形式的 SSA。</p>

<blockquote>
  <p>需要注意的是，该步骤只针对局部 int 类型变量进行处理，而不考虑数组、全局变量等情况。</p>
</blockquote>

<h5 id="a-划分基本块">a. 划分基本块</h5>

<blockquote>
  <p><strong>基本块</strong>的程式有以下特点：</p>

  <ul>
    <li>单一入口点，其他程式中，没有任何一个分支指令的目标在这段程式基本块之内（基本块的第一行除外）。</li>
    <li>单一结束点，这段程式一定要执行完最后一行才会执行其他基本块的程式。</li>
  </ul>

  <p>因为上述特点，基本块中的程式，只要执行了第一行，后面的程式码就会依序执行，每一行程式都会执行一次。</p>
</blockquote>

<p>由基本块的特性，在划分基本块时只需关心跳转指令，并根据不同的跳转指令生成基本块的前驱、后继关系，其具体算法如下：</p>

<ul>
  <li>
    <p>由于在生成中间代码时，需要跳转到的地址前均有一个对应的 label，因此先针对每一个 label 新建其对应的基本块类，并初始化其前驱、后继基本块为空集。</p>
  </li>
  <li>
    <p>遍历所有中间代码，并记录当前基本块 <code class="language-plaintext highlighter-rouge">currentBasicBlock</code> 和上一个遍历完的基本块 <code class="language-plaintext highlighter-rouge">prevBasicBlock</code></p>

    <ul>
      <li>
        <p>当遇到一个新的 label 时</p>

        <ul>
          <li>
            <p>若 <code class="language-plaintext highlighter-rouge">prevBasicBlock</code> 为空，则说明当前基本块为程序第一个基本块，没有对应的前驱。</p>
          </li>
          <li>
            <p>否则，寻找上一个基本块中最后一条指令，并分类讨论</p>

            <p><img src="/assets/images/post/branch.png" alt="" /></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="b-建立深度优先搜索树">b. 建立深度优先搜索树</h5>

<p>根据基本块的定义，我们很容易联想到图论中的知识，我们可以把每个基本块当作一个节点，而基本块之间的跳转关系则为基本块之间的边。这样生成的图就是程序的控制流图 (CFG, Control Flow Graph)。可以发现，由于循环和跳转的存在，有些基本块无法被到达，而有些可以形成环路。但这样复杂的跳转关系不利于生成 phi 节点，因此我们需要在控制流图的基础上生成支配树。</p>

<p>从第一个基本块开始，依照深度优先的顺序遍历所有基本块，每遇到一个新的基本块时则将其的 dfn 更新为深度优先搜索树的遍历顺序。</p>

<h5 id="c-无用基本块删除">c. 无用基本块删除</h5>

<p>在深度优先遍历后，未被遍历到（dfn 未更新）的基本块是在程序中不可到达的，因此可以直接删除。</p>

<h5 id="d-计算半必经点">d. 计算半必经点</h5>

<h6 id="前置概念参考链接1-参考链接2-">前置概念（<a href="https://buaa-se-compiling.github.io/miniSysY-tutorial/challenge/mem2reg/help.html">参考链接1</a>, <a href="https://www.cnblogs.com/ZeonfaiHo/p/6594642.html">参考链接2</a> ）</h6>

<ul>
  <li><strong>定义</strong>：对变量进行初始化、赋值等改变变量的值的行为。</li>
  <li><strong>使用</strong>：在语句/指令中将变量的值作为参数的行为。</li>
  <li><strong>控制流图</strong>（Control Flow Graph, CFG）：一个程序中所有基本块执行的可能流向图，图中的每个节点代表一个基本块，有向边代表基本块间的跳转关系。</li>
  <li><strong>支配</strong>（dominate）：对于 CFG 中的节点 $n_1$ 和 $n_2$，$n_1$ 支配 $n_2$ 当且仅当所有从入口节点到 $n_2$ 的路径中都包含 $n_1$，即 $n_1$ 是从入口节点到 $n_2$ 的必经节点。需要特别注意的是，每个基本块都支配自身。</li>
  <li><strong>严格支配</strong>（strictly dominate）：$n_1$ 严格支配 $n_2$ 当且仅当 $n_1$ 支配 $n_2$ 且 $n_1\neq n_2$。</li>
  <li><strong>直接支配者</strong>（immediate dominator, idom）：节点 $n$ 的直接支配者严格支配 $n$，且不严格支配任何严格支配 $n$ 的节点的节点）. 入口节点以外的节点都有直接支配者. 节点之间的直接支配关系可以形成一棵<strong>支配树</strong>（dominator tree）。</li>
  <li><strong>必经点</strong>：若 $n_1$ 严格支配 $n_2$，则 $n_1$ 为 $n_2$ 的必经点</li>
  <li><strong>半必经点</strong>：对于一个节点 $n_2$，若存在某个点 $n_1$ 能够通过一系列点 $p_i$ （不包含 $n_1$ 和 $n_2$）到达且 $\forall p_i$ 都有 dfn[$p_i$] &gt; dfn[$n_2$]，则称 $n_1$ 是 $n_2$ 的半必经点，用 sdom 表示。</li>
</ul>

<p><img src="/assets/images/post/cfg.png" alt="" /></p>

<h6 id="算法流程-6">算法流程</h6>

<p>依据深度优先搜索的相反顺序遍历所有基本块，并通过下面的算法找出每个基本块的半必经点。</p>

<ul>
  <li>对于基本块 Y，对于它的每一个前驱基本块 X，若 dfn[X] &lt; dfn[Y]，则 X 是 Y 的一个半必经点。</li>
  <li>否则，对于 X 在深度优先搜索树中的祖先 Z （包括 X 自身），如果满足 dfn[Z] &gt; dfn[Y]，那么 Z 的半必经点也是 Y 的半必经点。</li>
</ul>

<h5 id="e-计算直接支配点">e. 计算直接支配点</h5>

<blockquote>
  <p>一个点的半必经点可能是也可能不是一个点的支配点。</p>
</blockquote>

<p>对于一个点 X，考虑深度优先搜索树上从 X 的 半必经点 X.sdom 到 X 路径上的所有点 $p_0, p_1, …, p_k$，对于所有的 $p_i:0&lt;i&lt; k$，记其中 dfn[$p_i$.sdom] 最小的一个 $p_i$ 为 Z。</p>

<ul>
  <li>若 Z.sdom = X.sdom，则 X.idom = X.sdom</li>
  <li>否则，X.idom = Z.idom</li>
</ul>

<p>由此，已经计算出所有基本块的直接支配者，也就是在支配树中的父节点。</p>

<h5 id="f-计算支配边界">f. 计算支配边界</h5>

<p>在完成上一步后，我们已经成功将控制流图转化为支配树，下一步需要计算出每个基本块的支配边界 (Dominance Frontier)，以便之后插入 phi 节点。</p>

<p>计算支配边界的算法如下：</p>

<p><img src="https://buaa-se-compiling.github.io/miniSysY-tutorial/pic/algorithm_compute_DF.png" alt="" /></p>

<h5 id="g-插入-phi-节点">g. 插入 phi 节点</h5>

<p>构建出支配树，求出各基本块的支配边界之后，我们终于可以向正规的 SSA 形式迈进了，这种实现从 STORE, LOAD 形式的代码向 SSA 转换的过程被称为 mem2reg，具体的实现方法则是插入 phi 节点。</p>

<p>插入 phi 节点需要计算出每个变量的定义、使用情况，其具体算法如下：</p>

<p><img src="https://buaa-se-compiling.github.io/miniSysY-tutorial/pic/algorithm_insert_phi.png" alt="" /></p>

<h5 id="h-变量重命名">h. 变量重命名</h5>

<p>在插入 phi 节点后，我们还需要对变量进行重命名，从而使其满足 SSA 的要求。</p>

<p>具体的来说，对于 STORE 指令，我们新产生一个变量，并将其转化为对该变量的赋值语句 (assign)；对于 LOAD 指令，我们将其转化为 move 指令；而对于 phi 指令，我们也新产生一个变量，并将 phi 指令中的 val 值相应的填充为变量号。</p>

<p>一个具体的例子如下：</p>

<p><img src="/assets/images/post/phi.png" alt="" /></p>

<p>通过上述一系列的操作，我们终于得到了含有 phi 语句，且符合 SSA 规范的程序了。</p>

<h3 id="难点分析-5">难点分析</h3>

<p>生成 SSA 形式的中间代码是整个编译器中较为复杂的一步，它设计到大量图论相关的知识，且在实现时也需要阅读很多的教材、文献。</p>

<p>笔者在最初生成中间代码时由于懒惰和过分自信，并没有阅读文献就自行编写 mem2reg 相关代码。编写出的编译器针对小型样例可以通过，但在编译大型程序时出现了时间复杂度过高的情况，因此不得不阅读论文并重构，在这一步走了不少弯路。事实证明，阅读文献是很重要的，文献中的方法不但经过了正确性的检验，算法的时间复杂度也较低，虽然阅读文献需要耗费时间和经历，但却能大大提高写码时的效率，也让 debug 变得简单。</p>

<h2 id="中间代码优化">中间代码优化</h2>

<p>下面简单介绍编译器中在中间代码中进行的优化，需要注意的是，在实现时对每一种优化均设置了开关，这样便于查看优化效果，也便于程序调试。</p>

<p>生成 SSA 形式的中间代码极大的简化了中间代码的优化难度。以下是一些笔者采用的代码优化：</p>

<h3 id="死代码删除">死代码删除</h3>

<h4 id="一般代码删除">一般代码删除</h4>

<p>生成 SSA 形式的代码后，死代码删除就很好实现了，只需要找到定义但未被使用的变量，将其相关语句删除即可。</p>

<h4 id="跳转代码删除">跳转代码删除</h4>

<p>对于 <code class="language-plaintext highlighter-rouge">BRTRUE</code> 与 <code class="language-plaintext highlighter-rouge">BRFALSE</code> 语句，当判断跳转的变量取固定值时，则只有一种跳转的可能，因此可删去无法跳转到的分支。</p>

<h3 id="常量折叠">常量折叠</h3>

<p>由于每个变量只被定义一次，因此若在定义时为常数，则变量始终为常数。特别的，当 phi 语句可取的值均为常数且相同时，phi 语句生成的变量也为常数。</p>

<h3 id="函数内联">函数内联</h3>

<h4 id="1-判断函数是否内联">1. 判断函数是否内联</h4>

<p>当函数不存在递归调用时，则可以内联。由于 SysY 语法中不包含函数声明语句，因此不需要生成函数调用关系图即可以判断函数是否可以内联。</p>

<p>具体的来说，在语法分析的过程中，若在函数定义中调用了自己，则存在递归调用；否则则为可以内联的函数。</p>

<h4 id="2-函数内联实现">2. 函数内联实现</h4>

<h5 id="返回语句">返回语句</h5>

<p>函数内联实现时，需要特别注意返回语句的处理。由于返回语句执行后将不再执行之后的语句，因此需要对每个内联的函数末尾生成一个 label，将返回语句转化为向相应 label 的跳转语句。</p>

<h5 id="返回值">返回值</h5>

<p>由于函数可能包含多条返回语句，且可能有多种可能的返回值，因此将返回值作为一个变量处理。</p>

<p>具体的来说，若函数的返回类型为 int，则在开始函数内联之前先声明一个变量，用于存储返回值。在遇到内联函数的返回语句时向该变量中填入相应的值。</p>

<h3 id="循环优化">循环优化</h3>

<p>循环是程序中很重要的组成部分，且虽然语句量不一定多，但占据了程序运行中的大量时间，因此针对循环的优化可以有效提高程序的运行效率。</p>

<h4 id="1-while---do-while">1. while -&gt; do-while</h4>

<p>将 <code class="language-plaintext highlighter-rouge">while</code> 语句改写为 <code class="language-plaintext highlighter-rouge">do-while</code> 形式，可以减少跳转次数。</p>

<p><img src="/assets/images/post/dowhile.png" alt="" /></p>

<h4 id="删除无用循环">删除无用循环</h4>

<p>当循环内部的变量在循环外不再使用时，可以将整个循环删除。判断循环内变量是否使用需要配合活跃变量分析。</p>

<h4 id="循环展开">循环展开</h4>

<p>将小循环体展开，配合跳转代码删除，可以有效减少循环所需要的判断。</p>

<h3 id="局部数组提升--标记常量数组">局部数组提升 &amp; 标记常量数组</h3>

<p>由于在全局中可直接用 <code class="language-plaintext highlighter-rouge">.word</code> 进行初始化且不需要占用运行时间。因此，若局部数组的值未被改变或原本就定义为常量数组，则可以将其提升为全局数组并在全局中初始化。</p>

<h3 id="全局转局部">全局转局部</h3>

<p>由于对全局变量的读写均需要直接进行内存的读写，占用程序运行时间，因此对于函数中不会直接引用到的全局变量，可将其转化为局部变量并对其分配寄存器，减少存取指令，提高运行效率。</p>

<h2 id="目标代码生成">目标代码生成</h2>

<p>下面介绍由中间代码生成目标代码的过程。</p>

<h3 id="数据结构-6">数据结构</h3>

<h4 id="registertype"><code class="language-plaintext highlighter-rouge">RegisterType</code></h4>

<p>为了能够更方便的表示各个寄存器，新建 <code class="language-plaintext highlighter-rouge">RegisterType</code> 枚举类，如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">RegisterType</span> <span class="p">{</span>
    <span class="n">REGZERO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">REGAT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">REGV0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">REGV1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">REGA0</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">REGA1</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">REGA2</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">REGA3</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="n">REGT0</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">REGT1</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">REGT2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">REGT3</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span> <span class="n">REGT4</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="n">REGT5</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span> <span class="n">REGT6</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span> <span class="n">REGT7</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">REGT8</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="n">REGT9</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
    <span class="n">REGS0</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">REGS1</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span> <span class="n">REGS2</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span> <span class="n">REGS3</span> <span class="o">=</span> <span class="mi">19</span><span class="p">,</span> <span class="n">REGS4</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">REGS5</span> <span class="o">=</span> <span class="mi">21</span><span class="p">,</span> <span class="n">REGS6</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span> <span class="n">REGS7</span> <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>
    <span class="n">REGK0</span> <span class="o">=</span> <span class="mi">26</span><span class="p">,</span> <span class="n">REGK1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">,</span>
    <span class="n">REGGP</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span> <span class="n">REGSP</span> <span class="o">=</span> <span class="mi">29</span><span class="p">,</span> <span class="n">REGFP</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">REGRA</span> <span class="o">=</span> <span class="mi">31</span><span class="p">,</span>
    <span class="n">REGDEFAULT</span> <span class="o">=</span> <span class="mi">32</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="mipscode"><code class="language-plaintext highlighter-rouge">MIPSCode</code></h4>

<p>构建 <code class="language-plaintext highlighter-rouge">MIPSCode</code> 类，用来表示 mips 代码。此外，为了更好的区别不同种类的 mips 代码，新建枚举类 <code class="language-plaintext highlighter-rouge">MIPSType</code>，如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">MIPSType</span> <span class="p">{</span>
    <span class="n">MIPSADD</span><span class="p">,</span> <span class="n">MIPSADDI</span><span class="p">,</span> <span class="n">MIPSDIV</span><span class="p">,</span> <span class="n">MIPSMULT</span><span class="p">,</span> <span class="n">MIPSSUB</span><span class="p">,</span> <span class="n">MIPSSUBI</span><span class="p">,</span> <span class="n">MIPSMUL</span><span class="p">,</span> <span class="n">MIPSMULU</span><span class="p">,</span>
    <span class="n">MIPSAND</span><span class="p">,</span> <span class="n">MIPSANDI</span><span class="p">,</span> <span class="n">MIPSOR</span><span class="p">,</span> <span class="n">MIPSORI</span><span class="p">,</span> <span class="n">MIPSNOT</span><span class="p">,</span>
    <span class="n">MIPSBEQ</span><span class="p">,</span> <span class="n">MIPSBGEZ</span><span class="p">,</span> <span class="n">MIPSBGTZ</span><span class="p">,</span> <span class="n">MIPSBLEZ</span><span class="p">,</span> <span class="n">MIPSBLTZ</span><span class="p">,</span> <span class="n">MIPSBNE</span><span class="p">,</span>
    <span class="n">MIPSSLT</span><span class="p">,</span> <span class="n">MIPSSLE</span><span class="p">,</span> <span class="n">MIPSSGT</span><span class="p">,</span> <span class="n">MIPSSGE</span><span class="p">,</span> <span class="n">MIPSSEQ</span><span class="p">,</span> <span class="n">MIPSSNE</span><span class="p">,</span>
    <span class="n">MIPSJ</span><span class="p">,</span> <span class="n">MIPSJAL</span><span class="p">,</span> <span class="n">MIPSJALR</span><span class="p">,</span> <span class="n">MIPSJR</span><span class="p">,</span>
    <span class="n">MIPSMFHI</span><span class="p">,</span> <span class="n">MIPSMFLO</span><span class="p">,</span>
    <span class="n">MIPSSLL</span><span class="p">,</span> <span class="n">MIPSSLLV</span><span class="p">,</span> <span class="n">MIPSSLTI</span><span class="p">,</span> <span class="n">MIPSSRA</span><span class="p">,</span> <span class="n">MIPSSRAV</span><span class="p">,</span> <span class="n">MIPSSRL</span><span class="p">,</span> <span class="n">MIPSSRLV</span><span class="p">,</span>
    <span class="n">MIPSSW</span><span class="p">,</span> <span class="n">MIPSLW</span><span class="p">,</span> <span class="n">MIPSLWLABEL</span><span class="p">,</span> <span class="n">MIPSSWLABEL</span><span class="p">,</span>
    <span class="n">MIPSSYSCALL</span><span class="p">,</span> <span class="n">MIPSLABEL</span><span class="p">,</span> <span class="n">MIPSDATA</span><span class="p">,</span> <span class="n">MIPSTEXT</span><span class="p">,</span> <span class="n">MIPSLI</span><span class="p">,</span> <span class="n">MIPSLA</span><span class="p">,</span>
    <span class="n">MIPSSPACE</span><span class="p">,</span> <span class="n">MIPSWORD</span><span class="p">,</span> <span class="n">MIPSASCIIZ</span><span class="p">,</span> <span class="n">MIPSMOVE</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MIPSCode</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MIPSType</span> <span class="n">op</span><span class="p">;</span> <span class="c1">// 操作符</span>
    <span class="n">RegisterType</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">REGDEFAULT</span><span class="p">;</span> <span class="c1">// rs 寄存器</span>
    <span class="n">RegisterType</span> <span class="n">rt</span> <span class="o">=</span> <span class="n">REGDEFAULT</span><span class="p">;</span> <span class="c1">// rt 寄存器</span>
    <span class="n">RegisterType</span> <span class="n">rd</span> <span class="o">=</span> <span class="n">REGDEFAULT</span><span class="p">;</span> <span class="c1">// rd 寄存器</span>
    <span class="kt">int</span> <span class="n">imm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 立即数</span>
    <span class="n">string</span> <span class="n">label</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="register"><code class="language-plaintext highlighter-rouge">Register</code></h4>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20211114221256460.png" alt="image-20211114221256460" /></p>

<p>为了能够更好的调度寄存器和存储寄存器的使用情况，构建 <code class="language-plaintext highlighter-rouge">Register</code> 类，用于存储各个寄存器是否被使用，已经分配空寄存器。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Register</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">RegisterType</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">registers</span><span class="p">;</span> <span class="c1">// 各个寄存器的标号及其使用情况</span>

    <span class="n">Register</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// initialize register</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">registers</span><span class="p">[(</span><span class="n">RegisterType</span><span class="p">)</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 初始化寄存器，将所有使用位标志为空闲 (true)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">freeRegister</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">registers</span><span class="p">[(</span><span class="n">RegisterType</span><span class="p">)</span> <span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 将指定 id 的寄存器标记为空闲</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">getFreeTRegister</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 获得空闲的 t 寄存器，若全部 t 寄存器均被使用，则返回 -1</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="算法流程-7">算法流程</h3>

<p>生成中间代码的主要算法流程用下图表示。</p>

<p><img src="/assets/images/post/mips.png" alt="" /></p>

<p>其中，需要特别注意的是在函数调用过程中的寄存器偏移和在退出基本块时的寄存器偏移。</p>

<p>此外，也需要在生成代码时记录下各个变量的地址，以便后续调用。</p>

<h3 id="难点分析-6">难点分析</h3>

<h4 id="函数调用">函数调用</h4>

<p>函数调用时需要对 s 寄存器和必要的 t 寄存器进行保存，为了程序实现的正确性以及规范性，需要区分调用者和被调用者，并分别保存相应的变量。</p>

<p>更具体的来说</p>

<ul>
  <li>调用者需要保存必要的临时变量</li>
  <li>被调用者需要保存所有 s 寄存器，函数的返回地址，传入参数，初始栈指针与帧指针</li>
</ul>

<h4 id="栈指针偏移">栈指针偏移</h4>

<p>目标代码生成时最重要也最容易出问题的部分就是栈指针偏移。</p>

<p>对于全局变量，可以直接用 la (load address) 从全局中获取变量地址并进行存取操作，而对于局部变量，则需要通过栈指针 sp 和帧指针 fp 来确定其相对地址。</p>

<p>在实现时，在进入函数时将原帧指针地址保存并将帧指针移动至此时栈指针所在的位置，并在整个函数体内部不再改变，直至函数体执行完毕后再将帧指针恢复。这样做的好处是，在栈指针地址不断变化时可以通过相对于帧指针的偏移来获取局部变量的地址。</p>

<h4 id="phi-函数的实现">phi 函数的实现</h4>

<p>phi 函数两种可能的实现方式，一是在遇到 phi 函数时用 move 指令将所有可能的取值移动到同一个寄存器上，而另一种相对简单的方法是在分配寄存器时即将属于同一个 phi 函数的变量分配同一个寄存器。笔者采用的是后者。因此在全局分配寄存器前，需要先根据 phi 函数对变量进行归类，再将同一类的多个变量看作一个变量，进行活跃、冲突分析和寄存器分配操作。</p>

<h2 id="目标代码优化">目标代码优化</h2>

<h4 id="寄存器分配">寄存器分配</h4>

<p>采用图着色寄存器分配法，先通过活跃变量分析得到各个变量之间的冲突图，再在图中不断移去变量，最终完成寄存器分配。</p>

<h3 id="乘除优化">乘除优化</h3>

<p>乘除法占据的指令周期数极大，尤其是除法指令，一条就可以占据 100 个时钟周期，因此乘除指令的优化效果也十分显著。</p>

<p>主要针对一个操作数为常数的乘除指令进行优化。</p>

<p>乘法的优化方式主要为：将乘法转化为左移和加法操作，需要注意正负号的问题。</p>

<p>除法的优化方式参照论文 Division by Invariant Integers using Multiplication，可以将除法指令转化为乘法指令。</p>

<p>余数也可以转化为乘除指令，再进行相应优化 (a % b = a - a / b)</p>

<h3 id="窥孔优化">窥孔优化</h3>

<h4 id="无用跳转指令删除">无用跳转指令删除</h4>

<p><img src="/assets/images/post/jump.png" alt="" /></p>

<h4 id="无用-move-指令删除">无用 move 指令删除</h4>

<p><img src="/assets/images/post/move.png" alt="" /></p>

<h2 id="结语">结语</h2>

<p>一学期的编译实验终于要告一段落了。</p>

<p>在学期开始之初，我无论如何也想象不到自己可以用并（没）不（有）熟（用）练（过）的 c++ 写出上万行的程序，并且取得还不错的性能。因此，编译对我的代码能力和设计能力都有着极大的提升。看到编译器正确运行并且输出目标代码，还是很有成就感的。</p>

<p>在编写大型系统时，一个清晰的设计尤其重要。因此，在编写代码前我都会给自己列出一个步骤清单，先把架构设计想清楚，从整体结构再到每步实现时的注意事项，然后严格按照之前书写的步骤进行编译器的书写。这样做虽然一开始进度可能会慢于周围的同学，但一个清晰的思路会让后面的工作轻松不少。</p>

<p>除此之外，代码风格和命名也十分重要。在编译器的规模逐渐增加时，一些具体的函数实现方法可能已经变得模糊，如果能有一个清晰的命名和辅助的注释，则可以让自己迅速理解函数的作用，并决定是否调用。</p>

<p>总的来说，虽然中间有过很痛苦的时候，但能自己写出一个基本的编译器还是很有趣的经历 : )</p>

<h2 id="参考文献">参考文献</h2>

<p>[1] 《编译技术》，张莉，史晓华等</p>

<p>[2]  <em>Modern Compiler Implementation in C</em>, Andrew W. Appel (2004)</p>

<p>[3] <em>Static Single Assignment Book</em>, 2018, Lots of authors</p>

<p>[4] <em>LLVM IR TUTORIAL</em>, LLVM Developers Conference, Vince Bridgers, Felipe de Azevedo Piovezan</p>

<p>[5] <em>LLVM Cookbook</em>, Mayur Pandey, Suyog Sarda</p>

<p>[6] A Linear Time Alogorithm for Placing $\phi$-Nodes, Vugranam C. Sreedhar, Guang R. Gap, School of Computer Science, McGill University</p>

<p>[7] Division by Invariant Integers using Multiplication., Granlund, Torbjorn &amp; Montgomery, Peter. (2004).</p>]]></content><author><name>ericaaaaaaaa</name></author><category term="ComputerArchitecture" /><category term="design-doc" /><category term="system" /><summary type="html"><![CDATA[编译实验课程设计文档]]></summary></entry><entry><title type="html">Computer Vision</title><link href="http://localhost:4000/artificialintelligence/2021/09/14/ComputerVision.html" rel="alternate" type="text/html" title="Computer Vision" /><published>2021-09-14T00:00:00+08:00</published><updated>2021-09-14T00:00:00+08:00</updated><id>http://localhost:4000/artificialintelligence/2021/09/14/ComputerVision</id><content type="html" xml:base="http://localhost:4000/artificialintelligence/2021/09/14/ComputerVision.html"><![CDATA[<h1 id="计算机视觉"><center>计算机视觉</center></h1>

<p>本文档主要针对图像分类问题，在第一部 分中整理了相关背景知识，包括人工神经网络相关术语——激活函数、损失函数，正向与逆向传播等；在第二部分中主要介绍了图像分类相关的知识，包括它的输入输出与常见的处理方法。</p>

<h1 id="一知识">（一）知识</h1>

<h2 id="1-拟合-fitting">1. 拟合 (Fitting)</h2>

<p>利用曲线描述样本，曲线应当具有良好的泛化能力 (generalization)。在拟合时可能出现两种可能的情况——<strong>过拟合</strong> (overfitting) 和<strong>欠拟合</strong> (underfitting)。其中，欠拟合反映在训练时模型效果良好，但测试时正确率较低的情况。它往往是由于过度依赖训练集数据，从而缺乏对更多数据良好的泛化性。一种可能的原因是模型过于复杂且训练集较小。欠拟合与过拟合相反，无法对样本给出较好的估计。一种可能的原因是模型过于简单，无法拟合或区分样本点。</p>

<h2 id="2-正则化-regularization">2. 正则化 (Regularization)</h2>

<p>正则化的引入是为了防止过拟合的发生。举例来说，在多项式拟合坐标点问题中，多项式的阶数越高，对于样本点的拟合情况越好，但由于可能出现过拟合问题，因此反而可能导致对于最终测试点的拟合情况较差。因此，正则化可以有效的评估模型的复杂程度，尽可能减少测试误差。</p>

<h2 id="3-激活函数-activation-function">3. 激活函数 (Activation Function)</h2>

<p>神经网络受人类神经元工作原理的启发，因此神经网络中很重要的一个部分是它的激活函数。激活函数负责将神经元的输入映射到输出端。常用的激活函数图像如下图所示：</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Gjl-t%28x%29.svg/320px-Gjl-t%28x%29.svg.png" alt="img" /></p>

<h3 id="a-sigmoid-函数-sigma">a. sigmoid 函数 ($\sigma$​​​)</h3>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Logistic-curve.svg/320px-Logistic-curve.svg.png" alt="img" /></p>

<p>sigmoid 函数[1]是饱和激活函数，其公式为 $S(x) = \frac{1}{1+\exp^{-x}} = \frac{\exp^x}{\exp^x+1}=1-S(-x)$​ ，可以将输入映射到 (0,1) 区间内。</p>

<h4 id="优点">优点</h4>

<p>可以将任何范围的输入映射到 (0,1) 区间内</p>

<h4 id="缺点">缺点</h4>

<ul>
  <li>
    <p>在输出接近 0 或 1 时梯度几乎为 0，对反向传输中的梯度下降运算不利</p>
  </li>
  <li>
    <p>会使得大量的数据集中在 (0, 1) 区间内，数据密度分配不均</p>
  </li>
  <li>
    <p>输出并不是以 0 为中心，可能导致后续的神经元计算结果分布出现问题</p>
  </li>
</ul>

<p>因此在现在的神经网络中很少使用。</p>

<h3 id="b-tanh-函数">b. tanh 函数</h3>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/76/Sinh_cosh_tanh.svg/300px-Sinh_cosh_tanh.svg.png" alt="Sinh cosh tanh.svg" /></p>

<p>tanh[2]是饱和激活函数，其公式为 $\tanh(x) = 2\sigma(2x)-1=\frac{\sinh(x)}{\cosh(x)} = \frac{\exp^x-\exp^{-x}}{\exp^x+\exp^{-x}}=\frac{\exp^{2x}-1}{\exp^{2x}+1}$​​</p>

<h3 id="c-relu-函数">c. ReLU 函数</h3>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/ReLU_and_GELU.svg/220px-ReLU_and_GELU.svg.png" alt="img" /></p>

<p>不同于上述两种激活函数，ReLU 函数[3]属于非饱和激活函数，它的全称是修正线性单元激活函数 (Recitified Linear Unit active function)，也可以成为 Rectifier，它的公式为 $ReLU(x) = x^+ = \max(0,x)$​​</p>

<h4 id="优点-1">优点</h4>

<p>相比于上述 Sigmoid 和 tanh 激活函数，ReLU 的计算量较小，计算速度较快</p>

<h4 id="缺点-1">缺点</h4>

<p>ReLU 可能造成神经网络中的有用信息丢失，因为所有小于 0 的输入都会映射到 0，因此这些神经元将不再工作，不再向下传播。</p>

<h4 id="变体">变体</h4>

<p>以下是 ReLU 的部分变体。</p>

<ul>
  <li>
    <p>Leaky ReLU</p>

    <p>$Leaky_ReLU(x)=\begin{cases}x&amp;&amp; x\gt 0\\ 0.01x&amp;&amp;x\le0\end{cases}$​</p>
  </li>
  <li>
    <p>含参 ReLU</p>

    <p>$Parameter_ReLU(x)=\begin{cases}x&amp;&amp; x\gt 0\\ ax&amp;&amp;x\le0\end{cases}$​​</p>
  </li>
  <li>
    <p>SiLU</p>

    <p>$SiLU(x) = x\cdot sigmoid(x) = x\cot\sigma(x)$​</p>
  </li>
  <li>
    <p>Softplus</p>

    <p>$Softplus(x)=\ln(1+\exp^x)$</p>
  </li>
  <li>
    <p>ELU</p>

    <p>$ELU(x) = \begin{cases}x&amp;&amp;x\gt0\\ a(\exp^x-1)&amp;&amp;x\le0\end{cases}$</p>
  </li>
  <li>
    <p>GELU</p>

    <p>$f(x)=x\cdot\Phi(x)$​</p>
  </li>
  <li>
    <p>Maxout</p>

    <p>$Maxout(x) = \max(w_1^Tx+b_1, w_2^Tx+b_2)$</p>
  </li>
</ul>

<h2 id="4-损失函数-loss-function">4. 损失函数 (Loss Function)</h2>

<p>损失函数反映了估计值与真实值之间的差距，即模型的估计效果和正确率，多用于反向传播，即通过损失函数的大小反向调整模型参数的大小。</p>

<p>损失函数通常由两部分组成，<strong>规则化项</strong>和<strong>惩罚项</strong>，其中规则化项反映了模型对于样例的拟合水平，而规则化项则反映了模型的复杂程度。</p>

<p>损失函数可以抽象的表示为：$L = \frac{1}{N}\sum_iL_i+\lambda R(W)$，其中 $L_i$ 为第 $i$ 个样本点的规则化损失，$N$ 为样本点总数，$R(W)$ 为正则化损失</p>

<p>模型的目标是尽可能减小损失函数，即保障正确率且尽可能简单。</p>

<h3 id="a-规则化项">a. 规则化项</h3>

<h4 id="支持向量机-multiclass-support-vector-machine-svm">支持向量机 (Multiclass Support Vector Machine, SVM)</h4>

<p>支持向量机是一种二分类模型，目标是将样本点尽可能的分成两类。在图片分类问题中，SVM 希望使正确类的估计值尽可能的高，错误类的估计值稳定在某个特定的范围 $\Delta$ 内。</p>

<p>$SVM_loss = L_i = \sum_{j\not=y_i}\max{(0, s_j-s_{y_i}+\Delta)}$</p>

<p>其中 $i$ 代表第 $i$ 个样本点，$y_i$ 是该样本点正确的类别，$j$ 代表所有可能的类别，$s_j$ 和 $s_{y_i}$ 分别代表模型对于第 $i$ 个样本点为 $j$ 类型和 $y_i$ 类型的估计值大小，$\Delta$ 为可接受范围。</p>

<h4 id="softmax">Softmax</h4>

<p>$Softmax_loss = L_i = -\log{(\frac{\exp^{f_{y_i}}}{\sum_j\exp^{f_j}})}-f_{y_j}+\log{\sum_j\exp^{f_j}}$，其中 $i$ 代表第 $i$ 个样本，$y_i$ 是该样本点正确的类别，$j$ 代表所有可能的类别，$s_j$ 和 $s_{y_i}$ 分别代表模型对于第 $i$ 个样本点为 $j$ 类型和 $y_i$ 类型的估计值大小，$\frac{e^{f_{y_j}}}{\sum_je^{f_j}}$ 相当于估计正确发生的标准化概论。</p>

<blockquote>
  <p>SVM vs Softmax</p>

  <p>SVM 与样本点的各个类别的估计值大小有关，而 Softmax 只关系其相对大小关系。</p>

  <p>SVM 相比于 Softmax 在计算上相对简单。</p>
</blockquote>

<h3 id="b-惩罚项">b. 惩罚项</h3>

<p>模型的复杂程度应该控制在合理的范围内，过于简单的模型从理论上就无法解决复杂的问题，而过于复杂的网络又可能导致训练时间的延长或出现过拟合的情况，反而使得模型的准确度降低。我们追求的模型应当在保障正确性的同时尽可能的简单，惩罚项反映了模型的复杂程度，模型越复杂，惩罚项的取值就越大，是损失函数中的一部分。</p>

<p>以下为两个常见的惩罚项的表达式，其中 $W$ 为权重矩阵，$W_{k,l}$ 为其中的元素</p>

<h4 id="l1">L1</h4>

<table>
  <tbody>
    <tr>
      <td>L1 是一个常见的惩罚项，它的值为 $R(W) = \sum_k\sum_l</td>
      <td>W_{k,l}</td>
      <td>$​​</td>
    </tr>
  </tbody>
</table>

<h4 id="l2">L2</h4>

<p>L2 是一个常见的惩罚项，它的值为 $R(W) = \sum_k\sum_lW_{k,l}^2$​</p>

<h2 id="5-优化-optimization">5. 优化 (optimization)</h2>

<p>优化模型的目的是寻找适当的模型参数，使得损失函数最低。</p>

<h3 id="梯度下降-gradient-descent">梯度下降 (gradient descent)</h3>

<p>梯度下降是一种常用的优化方法，可以用来寻找局部最优点。它的思路是对现有模型的估计值计算梯度，找到下降最快的方向，根据损失函数 (loss function) 和学习率 (learning rate) 来决定参数的调整方向和大小，在一次次的迭代计算中找到模型参数的局部最优解。</p>

<blockquote>
  <p>梯度下降需要涉及到求偏导等数学计算，在实际应用中可以用到求导的链式法则。</p>
</blockquote>

<h2 id="6-反向传播-backpropagation">6. 反向传播 (backpropagation)</h2>

<blockquote>
  <p><strong>正向传播</strong>是获得输入，将输入通过构建的模型计算后得到输出。</p>
</blockquote>

<p>反向传播是根据模型的输出结果，根据计算出的损失函数去反向改变模型的参数，从而调整模型，使其更好的对样本进行拟合。</p>

<h1 id="二图像分类">（二）图像分类</h1>

<h2 id="1-输入">1. 输入</h2>

<h3 id="图像"><strong>图像</strong></h3>

<ul>
  <li>
    <p>像素 (pixel)</p>

    <p>取值范围 0 ~ 255，0 表示黑色，255 表示白色</p>
  </li>
  <li>
    <p>通道 (channel)</p>

    <p>彩色图像通常用 3 通道表示，分别为红色 (R)，绿色 (G) 和蓝色 (B)，简称为 RGB</p>

    <p>而黑白图像则只由单通道表示</p>
  </li>
</ul>

<h2 id="2-输出">2. 输出</h2>

<p>给出各类别的估计值</p>

<h2 id="3-难点">3. 难点</h2>

<p>图像识别对于多数人来说是极其自然的能力，但对于计算机而言却有着诸多困难，对于同一类物体而言，视角、尺度、形态的不同可能使其呈现完全不同的形态，此外，遮挡、光影等因素也会影响物体的呈现状态。另外，由于物体常常会在某个背景中出现，因此当物体与背景十分类似时，识别的困难也会增加。因此，图像处理对于计算机是较为复杂的工作。</p>

<h2 id="4-步骤">4. 步骤</h2>

<p>图像识别主要有三个步骤，如下：</p>

<ol>
  <li>
    <p><strong>获取输入</strong></p>

    <p>获取 N 个图片作为输入，每个图片分别对应一个类别，共 k 个类别，称上述输入为<strong>训练集</strong> (training set)</p>
  </li>
  <li>
    <p><strong>学习训练集，训练模型</strong></p>
  </li>
  <li>
    <p><strong>评估效果</strong></p>

    <p>利用<strong>不属于</strong>训练集的数据（测试集，testing set）测试模型的准确率</p>
  </li>
</ol>

<h2 id="5-方法">5. 方法</h2>

<p>由于上述分析中提到的，图像识别对于计算机而言有着诸多困难，因此，不同于一般的算法问题，图片分类难以有固定的解法，在实际应用中常常采用<strong>数据驱动</strong>方法，即通过学习大量真实的样例对未知的图片进行分类。下文中将按照由简到繁的顺序介绍图像处理中应用到的各类方法。</p>

<h3 id="a-最近邻分类">a. 最近邻分类</h3>

<p>最近邻分类是解决图片分类问题中思路最为简单，也最为直观的方案。它在数据维度低的时候较为适宜，但由于图片普遍维度较高，尺寸较大，因此最近邻分类算法的准确度较低，在实际工程中也很少使用。此外，传统的最近邻分类器和 k-最近邻分类器虽然训练时间极短，但测试时间较长，与实际工程需求相悖。</p>

<h4 id="i-最近邻分类器-nearest-neighbor-classifier">i. 最近邻分类器 (Nearest Neighbor Classifier)</h4>

<h5 id="思想">思想</h5>

<p>最近邻分类器首先获取并存储所有的训练数据，之后对应每一个待测试的数据，将其与存储的训练数据一一比较距离，距离最近的训练数据对应的类别则为最近邻分类器给出的该测试类的估计类别。</p>

<h5 id="距离">距离</h5>

<p>最近邻分类器以<strong>距离</strong>作为度量图片相似度的标准，常用的距离公式如下（其中 $I_1$​ 与 $I_2$​ 分别为训练集和测试集中的一张图片，$d$​​ 为两幅图片的距离）：</p>

<h6 id="l1-距离-l1-distance">L1 距离 (L1 distance)</h6>

<table>
  <tbody>
    <tr>
      <td>$d_1(I_1, I_2)=\sum_p{</td>
      <td>I_1^p-I_2^p</td>
      <td>}$</td>
    </tr>
  </tbody>
</table>

<p>该距离算法算出两幅图片相同位置上像素值的差并将其取绝对值再求和，从而得到两幅图片之间的距离。</p>

<h6 id="l2-距离-l2-distance">L2 距离 (L2 distance)</h6>

<p>$d_2(I_1, I_2) = \sqrt{\sum_p{(I_1^p-I_2^p)^2}}$</p>

<p>该距离算法算出两幅图片相同位置上像素值的差并将其求平方之后加和，在开根号作为两幅图片之间的距离</p>

<blockquote>
  <p><strong>L1</strong> 与 <strong>L2</strong> 距离的区别：</p>

  <ul>
    <li>极端数据对 L1 的影响程度小于 L2，因为 L2 会将数据进行平方运算。</li>
    <li>计算复杂度：L2 &gt; L1，因为涉及到平方与根号运算</li>
  </ul>
</blockquote>

<h5 id="优点-2">优点</h5>

<p>最近邻分类器的训练时间短（仅仅需要保存数据），且思路简单，便于实现。</p>

<h5 id="缺点-2">缺点</h5>

<p>正确率较低，且测试时需要与全部训练数据进行匹配，耗时较长，因此在实际工程中几乎不使用。</p>

<h4 id="ii-k-最近邻分类器-k-nearest-neighbor-classifier">ii. k-最近邻分类器 (k-Nearest Neighbor Classifier)</h4>

<h5 id="思想-1">思想</h5>

<p>由于最近邻分类器可能产生过拟合的现象，k-最近邻分类器[4]在上述分类器的基础上进行改进，选出与测试样例最接近的 k 个训练样本，并取在 k 个样本中数量最多的样本类型为最终分类结果</p>

<h5 id="优点-3">优点</h5>

<p>k-最近拥有最近邻分类器训练时间短且思路简单的优点，且能在传统最近邻分类器上做到对于部分噪声 (noise) 的忽略，因此可以取得比传统做法更优秀的正确率。</p>

<h5 id="缺点-3">缺点</h5>

<p>和传统做法一样，k-NN 的测试时间长，且与训练集的大小成正比，且相比于之后提到的分类算法，k-NN 的正确率依然较低。</p>

<h5 id="超参数调试-hyperparameter-tuning">超参数调试 (Hyperparameter tuning)</h5>

<p>由于在 k-最近邻分类器中 k 值属于变量，无法通过直观的方法决定 k 的最佳取值，因此引入超参数调试方法，将 k 作为<strong>超参数</strong> (hyperparameter)。</p>

<p>超参数调试的思路是选取不同的参数取值，并测试每个参数的准确率。但需要注意的是，用测试集 (test set) 作为衡量参数正确性的标准是不合理的，测试集应当放在研究的最后阶段，理论上应当仅使用一次，用来衡量网络的效果。</p>

<p>在网络形成过程中，为了更好的进行参数调试工作，从训练集 (training set) 中划分一部分作为验证集 (validation set)，在网络尚未完全搭建完成时利用验证集的完成情况进行超参数调试工作。</p>

<h5 id="交叉验证-cross-validation">交叉验证 (Cross-validation)</h5>

<p>考虑到验证集的规模可能导致对于准确率判断出现误差，因此不固定验证集，而是从训练集中随机或者按照一定的规模动态选择一部分作为训练集。</p>

<p>一个可能的做法是，将训练集随机等分成 n 份，每次验证时候从训练集中按照从前往后的顺序循环取出一份作为验证集。(1, 2, …, n, 1, 2, …)</p>

<blockquote>
  <p>尽管交叉验证可以得到更加客观的模型正确性结果，但由于动态调整验证集耗费计算资源，在实际问题中，面对数量巨大的训练集，一般很少使用。</p>
</blockquote>

<h4 id="iii-近似最近邻分类器-approximate-nearest-neighbor">iii. 近似最近邻分类器 (Approximate Nearest Neighbor)</h4>

<h5 id="树方法">树方法</h5>

<ul>
  <li>
    <p>Kd-tree</p>

    <p>划分空间维度，通过缩小检索范围加速检索速度</p>
  </li>
  <li>
    <p>annoy</p>

    <p>以二叉树为数据结构的近似最近邻搜索库</p>
  </li>
</ul>

<h5 id="哈希方法">哈希方法</h5>

<p>通过哈希函数将空间内的向量以 0，1 的二进制值进行编码</p>

<ul>
  <li>
    <p>局部敏感哈希 (Local Sensitive Hashing)</p>

    <p>通过哈希函数将所有样本点映射到不同桶中，将对于全体样本的比对搜索化简为对某一特定桶的比对搜索</p>
  </li>
</ul>

<h5 id="矢量量化方法">矢量量化方法</h5>

<p>将样本点分成若干类，每一类用其中心点表示。</p>

<h5 id="近邻图方法">近邻图方法</h5>

<p>建立图结构，图的顶点是样本点，边的权重为样本点之间的距离。利用图论算法在途中搜索得到最近邻</p>

<h4 id="iv-快速最近邻分类器-fast-nearest-neighbor">iv. 快速最近邻分类器 (Fast Nearest Neighbor)</h4>

<h3 id="b-主成分分析法-principal-component-analysis">b. 主成分分析法 (Principal Component Analysis)</h3>

<p>与特征分析方法类似，主成分分析法[5]基于多元素特征值分析，是一种降维度的分析方法，将高维样本降维，只关注样本点的主要成分。</p>

<p>主成分分析法的原则是在降低分析指标（维度）的同时保留样本点的基本信息，保障其差异性。</p>

<p>坐标系的选择原则：</p>

<ul>
  <li>体现样本点之间的差异</li>
  <li>相互垂直</li>
</ul>

<h3 id="c-近邻成分分析法-neighborhood-component-analysis">c. 近邻成分分析法 (Neighborhood Component Analysis)</h3>

<p>邻近成分分析法属于受监督的机器学习方法，与 k-最近邻算法相类似，不同之处在于 NCA 会通过学习样本数数据确定适合的距离测度算法。</p>

<h3 id="d-随机投射-random-projection">d. 随机投射 (Random Projection)</h3>

<p>随即投射[6]的目的在于降低欧氏空间样本点的维度。通过随机生成的 $d\times k$​​ 矩阵将原有 $d$​​ 维数据投影到 $k$​​ 维空间内（注意：随机选择的矩阵各个行、列向量<strong>可以</strong>不满足正交关系，但需要经过归一化处理）。Johnson 的论文中用数学方法论证了随机投射方法的可行性。</p>

<h3 id="e-线性分类器-linear-classification">e. 线性分类器 (Linear Classification)</h3>

<p>线性分类器通过线性函数将样本点分类，它主要由两部分构成：</p>

<ul>
  <li>
    <p><strong>评分函数</strong> (score function)</p>

    <p>评分函数反映了各个因素的重要程度</p>

    <p>$f(x_i, W, b) = Wx_i + b$</p>

    <p>上式中，$x_i$ 为输入的图片样例（矩阵形式），$W$​​​​​ 为权重函数，意味着图片的各个部分在图片分类问题中的重要程度。</p>
  </li>
  <li>
    <p><strong>损失函数</strong> (loss function)</p>

    <p>损失函数是用来度量模型效果的函数，损失越小意味着模型越准确。</p>
  </li>
</ul>

<p>线性分类器的目的在于寻找最佳的权重函数，使损失函数降到最低。</p>

<h3 id="f-人工神经网络-artificial-neural-network">f. 人工神经网络 (Artificial Neural Network)</h3>

<p>人工神经网络模仿动物神经网络，是一种常用的数学模型。神经网络包括输入层、隐藏层和输出层，其中，隐藏层可以有多层</p>

<h1 id="三参考文献">（三）参考文献</h1>

<p>[1] sigmoid 激活函数，https://en.wikipedia.org/wiki/Sigmoid_function</p>

<p>[2] tanh 激活函数，https://en.wikipedia.org/wiki/Hyperbolic_functions</p>

<p>[3] ReLU 激活函数，https://en.wikipedia.org/wiki/Rectifier_(neural_networks)</p>

<p>[4]  Fix, Evelyn; Hodges, Joseph L. (1951). Discriminatory Analysis. Nonparametric Discrimination: Consistency Properties (PDF) (Report). USAF School of Aviation Medicine, Randolph Field, Texas.</p>

<p>[5] Pearson, K. (1901). “On Lines and Planes of Closest Fit to Systems of Points in Space”. Philosophical Magazine. 2 (11): 559–572. doi:10.1080/14786440109462720.</p>

<p>[6] Johnson, William B.; Lindenstrauss, Joram (1984). “Extensions of Lipschitz mappings into a Hilbert space”. Conference in Modern Analysis and Probability (New Haven, Conn., 1982). Contemporary Mathematics. 26. Providence, RI: American Mathematical Society. pp. 189–206. doi:10.1090/conm/026/737400. ISBN 9780821850305. MR 0737400</p>]]></content><author><name>ericaaaaaaaa</name></author><category term="ArtificialIntelligence" /><category term="note" /><category term="artificial-intelligence" /><category term="computer-vision" /><summary type="html"><![CDATA[计算机视觉]]></summary></entry><entry><title type="html">Discrete Mathematics</title><link href="http://localhost:4000/mathematics/2021/06/29/DiscreteMathematics.html" rel="alternate" type="text/html" title="Discrete Mathematics" /><published>2021-06-29T00:00:00+08:00</published><updated>2021-06-29T00:00:00+08:00</updated><id>http://localhost:4000/mathematics/2021/06/29/DiscreteMathematics</id><content type="html" xml:base="http://localhost:4000/mathematics/2021/06/29/DiscreteMathematics.html"><![CDATA[<h1 id="图论">图论</h1>

<h2 id="基本概念">基本概念</h2>

<h3 id="绘图程序">绘图程序</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="n">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">drawgraph</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
<span class="c1">#    G = nx.Graph() # 无向图
</span>    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="n">DiGraph</span><span class="p">()</span> <span class="c1"># 有向图
</span>    <span class="n">G</span><span class="p">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="n">nx</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_size</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span> <span class="n">node_color</span> <span class="o">=</span> <span class="s">'k'</span><span class="p">,</span> 
            <span class="n">with_lables</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">font_color</span> <span class="o">=</span> <span class="s">'w'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span>

<span class="n">V</span> <span class="o">=</span> <span class="p">{</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">,</span> <span class="s">'f'</span><span class="p">,</span> <span class="s">'g'</span><span class="p">}</span>
<span class="n">E</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">),</span> <span class="p">(</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'f'</span><span class="p">),</span> <span class="p">(</span><span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">),</span> <span class="p">(</span><span class="s">'b'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">),</span> <span class="p">(</span><span class="s">'b'</span><span class="p">,</span> <span class="s">'f'</span><span class="p">),</span> <span class="p">(</span><span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">),</span>
     <span class="p">(</span><span class="s">'c'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">),</span> <span class="p">(</span><span class="s">'c'</span><span class="p">,</span> <span class="s">'f'</span><span class="p">),</span> <span class="p">(</span><span class="s">'f'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">)]</span>
<span class="n">drawgraph</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/post/image-20210528102258319.png" alt="image-20210528102258319" /></p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210528102310190.png" alt="image-20210528102310190" /></p>

<h3 id="基本概念-1">基本概念</h3>

<h4 id="无序偶和有序偶">无序偶和有序偶</h4>

<h5 id="无序偶">无序偶</h5>

<p>$V$ 是非空集合，$x\in V$ 并且 $y\in V$，称 $(x,y)$ 是无序偶</p>

<h5 id="有序偶">有序偶</h5>

<p>$V$ 是非空集合，$x\in V$ 并且 $y\in V$，称 $&lt;x,y&gt;$ 是有序偶</p>

<h4 id="有向图和无向图">有向图和无向图</h4>

<h5 id="无向图">无向图</h5>

<p>无向图是由无序偶构成的边的集合</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Cartesianproduct</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span> <span class="c1"># 笛卡尔乘积
</span>    <span class="n">XY</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
            <span class="n">XY</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">XY</span>

<span class="k">def</span> <span class="nf">creategraph</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span> <span class="c1"># 随机生成 m 点, n 边图
</span>    <span class="k">global</span> <span class="n">V</span><span class="p">,</span> <span class="n">XY</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">XY</span> <span class="o">=</span> <span class="n">Cartesianproduct</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">XY</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span>
</code></pre></div></div>

<h5 id="有向图">有向图</h5>

<p>有向图是由有序偶构成的边的集合</p>

<h4 id="带权图">带权图</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Cartesianproductweight</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span> <span class="c1"># 带权笛卡尔乘积
</span>    <span class="n">XY</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">XY</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">XY</span>

<span class="k">def</span> <span class="nf">weightedgraph</span><span class="p">(</span><span class="n">V0</span><span class="p">,</span> <span class="n">E0</span><span class="p">,</span> <span class="n">W0</span><span class="p">):</span> <span class="c1"># 随机生成带权图
</span>    <span class="n">V</span> <span class="o">=</span> <span class="n">V0</span>
    <span class="n">E</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E0</span><span class="p">:</span>
        <span class="n">w</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">W0</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">|</span> <span class="p">{(</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="图判断">图判断</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isgraph</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span> <span class="c1"># 是否为图
</span>    <span class="n">tv</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
        <span class="n">tv</span> <span class="o">=</span> <span class="n">tv</span> <span class="ow">and</span> <span class="p">(</span><span class="n">u</span> <span class="ow">in</span> <span class="n">V</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tv</span>
</code></pre></div></div>

<h3 id="基本结构">基本结构</h3>

<h4 id="关系">关系</h4>

<p><strong>图的基本结构</strong>是指图和顶点之间，边之间以及边与顶点之间的连接关系</p>

<ul>
  <li><strong>邻接关系</strong>：顶点之间</li>
  <li><strong>关联关系</strong>：顶点与边之间</li>
  <li><strong>相邻关系</strong>：边与边之间</li>
</ul>

<h4 id="度">度</h4>

<h5 id="入度-diu">入度 $di(u)$</h5>

<p>以 $u$ 为终点的边数称为点 $u$ 的入度。</p>

<h5 id="出度-dou">出度 $do(u)$</h5>

<p>以 $u$ 为起点的边数称为点 $u$ 的入度。</p>

<h5 id="度-degu">度 $deg(u)$</h5>

<h6 id="顶点的度">顶点的度</h6>

<p>$deg(u) = di(u) + do(u)$</p>

<h6 id="图的度">图的度</h6>

<p>$deg(V) = \sum_{u\in V}deg(u)$</p>

<h4 id="握手定理">握手定理</h4>

<p>设 $G = &lt;V, E&gt;$ 是 $(n, m)$ 图，则 $\sum_{u\in V}d(u) = 2m$</p>

<h4 id="同构-isomorphism">同构 (isomorphism)</h4>

<p>设无向图 $G = &lt;V, E&gt;$ 和 $G’ = &lt;V’, E’&gt;$, 如果存在<strong>双射函数</strong> $f: v\rightarrow v’$, 并且当且仅当 $e = (u_i, u_j)\in E$, 有 $e’ = (f(u_i), f(u_j))\in E’$, 则称 $G$ 和 $G’$ <strong>同构</strong></p>

<h3 id="子图及算法">子图及算法</h3>

<h4 id="子图-subgraph">子图 (subgraph)</h4>

<h5 id="定义">定义</h5>

<p>设 $G = &lt;V, E&gt;$ 和 $G_s = &lt;V_s, E_s&gt;$ 是两个图，若</p>

<ul>
  <li>$V_s \subseteq V$</li>
  <li>$E_s \subseteq E$</li>
</ul>

<p>则称 $G_s$ 为 $G$ 的子图，记为 $G_s \subseteq G$</p>

<h5 id="判断子图算法">判断子图算法</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">issubgraph</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">Vs</span><span class="p">,</span> <span class="n">Es</span><span class="p">):</span>
    <span class="n">tv</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vs</span> <span class="o">&lt;=</span> <span class="n">V</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Es</span> <span class="o">&lt;=</span> <span class="n">E</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tv</span>
</code></pre></div></div>

<h4 id="真子图-proper-subgraph">真子图 (proper subgraph)</h4>

<h5 id="定义-1">定义</h5>

<ul>
  <li>$G_s \subseteq G$</li>
  <li>$V_s \subset V$</li>
  <li><strong>或</strong></li>
  <li>$E_s \subset E$</li>
</ul>

<p>则称 $G_s$ 为 $G$ 的真子图，记为 $G_s \subset G$</p>

<h5 id="判断真子图算法">判断真子图算法</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ispropersubgraph</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">Vs</span><span class="p">,</span> <span class="n">Es</span><span class="p">):</span>
    <span class="n">tv</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vs</span> <span class="o">&lt;=</span> <span class="n">V</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Es</span> <span class="o">&lt;=</span> <span class="n">E</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">Vs</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">Es</span> <span class="o">&lt;</span> <span class="n">E</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tv</span>
</code></pre></div></div>

<h4 id="生成子图-spanning-subgraph">生成子图 (spanning subgraph)</h4>

<h5 id="定义-2">定义</h5>

<ul>
  <li>$G_s \subseteq G$</li>
  <li>$V_s = V$</li>
</ul>

<p>则称 $G_s$ 为 $G$ 的生成子图</p>

<h5 id="判断生成子图算法">判断生成子图算法</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isspanningsubgraph</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">Vs</span><span class="p">,</span> <span class="n">Es</span><span class="p">):</span>
    <span class="n">tv</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vs</span> <span class="o">&lt;=</span> <span class="n">V</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Es</span> <span class="o">&lt;=</span> <span class="n">E</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">Vs</span> <span class="o">==</span> <span class="n">V</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Es</span> <span class="o">&lt;=</span> <span class="n">E</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tv</span>
</code></pre></div></div>

<h4 id="导出子图-induced-subgraph">导出子图 (induced subgraph)</h4>

<h5 id="定义-3">定义</h5>

<ul>
  <li>$G_s \subseteq G$</li>
  <li><code class="language-plaintext highlighter-rouge">\forall (v; v in V_s; \forall (u; u in V_s; (u, v) in E ==&gt; (u, v) in E_s))</code></li>
</ul>

<p>则称 $G_s$ 为 $G$ 的导出子图</p>

<h5 id="判断导出子图算法">判断导出子图算法</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isinducedsubgraph</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">Vs</span><span class="p">,</span> <span class="n">Es</span><span class="p">):</span>
    <span class="n">tv</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vs</span> <span class="o">&lt;=</span> <span class="n">V</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Es</span> <span class="o">&lt;=</span> <span class="n">E</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
        <span class="n">tv</span> <span class="o">=</span> <span class="n">tv</span> <span class="ow">and</span> <span class="p">((</span><span class="ow">not</span><span class="p">((</span><span class="n">u</span> <span class="ow">in</span> <span class="n">Vs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">Vs</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">Es</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tv</span>
</code></pre></div></div>

<h3 id="特殊图及算法">特殊图及算法</h3>

<h4 id="补图">补图</h4>

<p>设 $G = &lt;V, E&gt;$ 是 $n$ 阶无向简单图</p>

<ul>
  <li>以 $V$ 为顶点</li>
  <li>以所有使 $G$ 称为 <strong>完全图</strong> $K_n$ 的添加边所组成的集合为边</li>
</ul>

<p>的图称为 $G$ 的子图，记为 $\sim G$</p>

<h4 id="相对补图">相对补图</h4>

<p>$G_1$ 是 $G_2$ 相对于 $G$ 的补图</p>

<h2 id="连通问题">连通问题</h2>

<h3 id="连通问题-1">连通问题</h3>

<h4 id="通路-path">通路 (path)</h4>

<p>若 $u_k\in V, (u_k, u_{k+1}) \in E, k = 0, 1,…,n-1$，则顶点 $u_0$ 与顶点 $u_{n-1}$ 之间存在通路，记为 $u_0\Rightarrow u_{n-1}$</p>

<h4 id="简单通路-simple-path">==简单==通路 (simple path)</h4>

<p>每条 <strong>边</strong> 的出现不超过一次</p>

<h4 id="基本通路-basic-path">==基本==通路 (basic path)</h4>

<p>每个 <strong>顶点</strong> 的出现不超过一次</p>

<h4 id="回路-circuit">回路 (circuit)</h4>

<p>设有向图 $D = &lt;V,A&gt;$，若 $u\in V$，从 $u$ 出发并返回 $u$ 的通路，称为回路，记为 $u\Rightarrow u$</p>

<h4 id="简单回路-simple-circuit">简单回路 (simple circuit)</h4>

<p>每条 <strong>边</strong> 的出现不超过一次</p>

<h4 id="基本回路-basic-circuit">基本回路 (basic circuit)</h4>

<p>每个 <strong>顶点</strong> 的出现不超过一次</p>

<h4 id="圈-acyclic">圈 (acyclic)</h4>

<h4 id="定理">定理</h4>

<p>设 $G = &lt;V, E&gt;$ 是 $n$ 阶图，若顶点 $u, v$ 存在通路，则存在小于等于 $n-1$ 的通路</p>

<h3 id="通路算法">通路算法</h3>

<h5 id="初始通路">初始通路</h5>

<table>
  <tbody>
    <tr>
      <td>$path0 = {(u0, v)</td>
      <td>(u0, v)\in E\or (v, u0)\in E}$</td>
    </tr>
  </tbody>
</table>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pathset0</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">u0</span><span class="p">):</span>
    <span class="c1"># 找到所有从 u0 出发的路径
</span>    <span class="n">path1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">u0</span><span class="p">):</span>
            <span class="n">path1</span> <span class="o">=</span> <span class="n">path1</span> <span class="o">|</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">path1</span>
</code></pre></div></div>

<p>$(\omega, x, y) \in path(n) \rightarrow (\omega,x,y,v)\in path(n+1)$</p>

<ul>
  <li>$u == y\and v\ not\ in\ path(n) \rightarrow(\omega, x,y,v)\in path(n+1) $</li>
  <li>$v == y\and v\ not\ in\ path(n) \rightarrow(\omega, x,y,u)\in path(n+1) $</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pathset</span><span class="p">(</span><span class="n">path0</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="n">p0</span> <span class="ow">in</span> <span class="n">path0</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">p0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">y</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">v</span><span class="p">])</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">|</span> <span class="p">{</span><span class="n">p</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">path</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">basicpathset</span><span class="p">(</span><span class="n">path0</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="n">pk</span> <span class="ow">in</span> <span class="n">path0</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pk</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">x</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pk</span><span class="p">)):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">v</span><span class="p">])</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">|</span> <span class="p">{</span><span class="n">p</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">path</span>
</code></pre></div></div>

<h3 id="连通图">连通图</h3>

<h4 id="连通图的构建">连通图的构建</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">connectedgraph</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">V0</span><span class="p">,</span> <span class="n">E0</span><span class="p">):</span>
    <span class="c1"># 连通图
</span>    <span class="n">Vc</span> <span class="o">=</span> <span class="n">V0</span>
    <span class="n">Ec</span> <span class="o">=</span> <span class="n">E0</span>
    <span class="k">while</span> <span class="n">E</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">({}):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ec</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Ec</span> <span class="ow">and</span> <span class="p">(</span><span class="n">u</span> <span class="ow">in</span> <span class="n">Vc</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Vc</span><span class="p">):</span>
                <span class="n">Vc</span> <span class="o">=</span> <span class="n">Vc</span> <span class="o">|</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">}</span>
                <span class="n">Ec</span> <span class="o">=</span> <span class="n">Ec</span> <span class="o">|</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ec</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Vc</span><span class="p">,</span> <span class="n">Ec</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="连通图判断">连通图判断</h4>

<p>[Vc, Ec] 是图 G = &lt;V, E&gt; 的连通子图，若 Ec == E，则 G 为连通图，否则不然</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isconnectedgraph</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="c1"># 判断是否为连通图
</span>    <span class="n">V</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">V0</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">}</span>
    <span class="n">E0</span> <span class="o">=</span> <span class="p">{(</span><span class="n">U</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
    <span class="p">[</span><span class="n">Vc</span><span class="p">,</span> <span class="n">Ec</span><span class="p">]</span> <span class="o">=</span> <span class="n">connectedgraph</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">V0</span><span class="p">,</span> <span class="n">E0</span><span class="p">)</span>
    <span class="n">tv</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">Vc</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">Ec</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tv</span>
</code></pre></div></div>

<h2 id="图的矩阵表示">图的矩阵表示</h2>

<h3 id="邻接矩阵">邻接矩阵</h3>

<table>
  <tbody>
    <tr>
      <td>设$G=&lt;V,E&gt;$是简单图，$</td>
      <td>V</td>
      <td>=n$，矩阵$An\times n=[ai,j]$，若边$(vi,vj)\in E$，则$a_{i,j}=1$，否则，$a_{i,j}=0$，称矩阵$An\times n$是邻接矩阵。</td>
    </tr>
  </tbody>
</table>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">graph2array</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s">'int'</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">A</span>
</code></pre></div></div>

<h3 id="多重边图邻接矩阵">多重边图邻接矩阵</h3>

<p>邻接矩阵$An×n=[ai,j]$，也可以表示有自环以及有多重边的图，其中，$a_{i,j}$表示顶点$v_i$和$v_j$邻接的边数目。</p>

<h3 id="有向图邻接矩阵">有向图邻接矩阵</h3>

<p>邻接矩阵也可以表示有向图。矩阵$An×n=[a_{i,j}]$，若边$&lt;v_i,v_j&gt;\in E$，则$a_{i,j}=1$，否则，$a_{i,j}=0$。</p>

<h3 id="无向图关联矩阵">无向图关联矩阵</h3>

<table>
  <tbody>
    <tr>
      <td>设$G=&lt;V,E&gt;$是简单无向图，$</td>
      <td>V</td>
      <td>=n$，$</td>
      <td>E</td>
      <td>=m$，矩阵$An×m=[a_{i,j}]$，若顶点$v_i\in V$，$e_j\in E$，$e_j=(v_i,u)$或$e_j=(u,v_i)$，则$a_{i,j}=1$，否则，$a_{i,j}=0$，称矩阵$A_n×m$是关联矩阵。</td>
    </tr>
  </tbody>
</table>

<h3 id="有向图的关联矩阵">有向图的关联矩阵</h3>

<table>
  <tbody>
    <tr>
      <td>设$G=&lt;V,E&gt;$是简单有向图，$</td>
      <td>V</td>
      <td>=n$，$</td>
      <td>E</td>
      <td>=m$，矩阵$A_n×m=[a_{i,j}]$，顶点$u_i\in V$，$e_j\in E$，若$e_j=&lt;u_i,v&gt;$则$a_{i,j}=1$，若$e_j=&lt;v,u_i&gt;$，则$a_{i,j}=-1$，否则，$a_{i,j}=0$，称矩阵$A_n×m$是关联矩阵。</td>
    </tr>
  </tbody>
</table>

<h3 id="可达矩阵">可达矩阵</h3>

<p>设A是相邻矩阵，I是单位矩阵，B是布尔矩阵，R是可达矩阵，则$R=B(I+A+A^2+…+A^{n-1})=B[(I+A)^{n-1}]$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reachabilityarray</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c1"># 可达矩阵
</span>    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">eye</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s">'int'</span><span class="p">))</span> <span class="c1"># 自身可达
</span>    <span class="n">Ai</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="n">A</span>
    <span class="n">An</span> <span class="o">=</span> <span class="n">Ai</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span> <span class="p">,</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s">'int'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">An</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">R</span>
</code></pre></div></div>

<h2 id="穿程问题">穿程问题</h2>

<h3 id="欧拉图">欧拉图</h3>

<h4 id="欧拉链">欧拉链</h4>

<p>（欧拉链、欧拉圈、欧拉图）：设G＝&lt;V,E&gt;是连通无向图，经过G中每条<strong>边</strong>一次且仅一次的非闭合链称为欧拉链（通路）</p>

<h4 id="欧拉圈">欧拉圈</h4>

<p>经过G中每条边一次且仅一次的闭合链称为欧拉圈</p>

<h4 id="欧拉图-1">欧拉图</h4>

<p>具有欧拉圈的图称为欧拉图</p>

<h4 id="判定定理">判定定理</h4>

<h5 id="定理1">定理1</h5>

<p>设G是无向连通图，则如下三个命题等价</p>

<ul>
  <li>G是欧拉图。</li>
  <li>G中所有顶点的度数是偶数。</li>
  <li>G是若干不重边圈的并。</li>
</ul>

<h5 id="定理2">定理2</h5>

<p>无向图G为欧拉图，当且仅当G是连通图，并且G的每一个顶点都是偶顶点。</p>

<h4 id="图的度入度出度">图的度、入度、出度</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">degreeset</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="c1"># 获得图的度，入度，出度
</span>    <span class="n">V</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>  <span class="c1"># 度
</span>    <span class="n">di</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span> <span class="c1"># 入度
</span>    <span class="n">do</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span> <span class="c1"># 出度
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">V</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">V</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">di</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">do</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="n">do</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="欧拉通路">欧拉通路</h4>

<p>无向图G中有连接$u_i$和$u_j$的欧拉通路，当且仅当G是连通图，并且G中只有$u_i$和$u_j$ 是奇顶点。</p>

<h4 id="欧拉图的构建方法">欧拉图的构建方法</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 欧拉图的构建算法
</span><span class="k">def</span> <span class="nf">subEulercircuit</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">v0</span><span class="p">):</span>
    <span class="c1"># 返回边 E 中以 v0 作为起点和终点的回路 circuit
</span>    <span class="c1"># 返回回路中所经过的点集 S
</span>    <span class="n">circuit</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">v0</span><span class="p">])</span>
    <span class="n">S</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">circuit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">circuit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">y</span><span class="p">):</span>
                <span class="n">circuit</span> <span class="o">=</span> <span class="n">circuit</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">v</span><span class="p">])</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">|</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">circuit</span><span class="p">,</span> <span class="n">S</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">set2V</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
    <span class="c1"># edges to vertexes
</span>    <span class="n">V</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span> <span class="o">|</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">V</span>

<span class="k">def</span> <span class="nf">Eulercircuit</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">v0</span><span class="p">):</span>
    <span class="p">[</span><span class="n">circuit</span><span class="p">,</span> <span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="n">subEulercircuit</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">v0</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">S</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">E</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">({})):</span>
        <span class="n">V1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
        <span class="n">V2</span> <span class="o">=</span> <span class="n">set2V</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">V1V2</span> <span class="o">=</span> <span class="n">V1</span> <span class="o">&amp;</span> <span class="n">V2</span>
        <span class="k">for</span> <span class="n">v0</span> <span class="ow">in</span> <span class="n">V1V2</span><span class="p">:</span>
            <span class="p">[</span><span class="n">subcircuit</span><span class="p">,</span> <span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="n">subEulercircuit</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">v0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">S</span> <span class="o">==</span> <span class="nb">set</span><span class="p">({}):</span>
                <span class="c1"># 在现有边集 E 中无法找到 v0 开头的回路
</span>                <span class="k">continue</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
            <span class="c1"># 将找到的回路添加到原回路的适当位置
</span>            <span class="n">circuit</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">subcircuit</span> <span class="o">+</span> <span class="n">circuit</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">circuit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">S</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">circuit</span>
</code></pre></div></div>

<h4 id="一笔画问题格雷码">一笔画问题（格雷码）</h4>

<h4 id="构建偶数度顶点图">构建偶数度顶点图</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 构建偶数度顶点图
# 对于圈图，任取顶点 [u0, v0]，用 v0 替换 u0，并且 V = V - {u0}
# 重复 n 次
</span><span class="k">def</span> <span class="nf">replacevertex</span><span class="p">(</span><span class="n">V0</span><span class="p">,</span><span class="n">E0</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="p">[</span><span class="n">u0</span><span class="p">,</span> <span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span> <span class="o">-</span> <span class="p">{</span><span class="n">u0</span><span class="p">}</span>
        <span class="n">E</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">u0</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">|</span> <span class="p">{(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="n">u0</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">|</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v0</span><span class="p">)}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">|</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
        <span class="n">E0</span> <span class="o">=</span> <span class="n">E</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="哈密尔顿图">哈密尔顿图</h3>

<h4 id="哈密尔顿图-1">哈密尔顿图</h4>

<p>无向图G中穿过每个<strong>顶点</strong>一次且仅一次的圈，称为哈密顿圈,具有哈密顿圈的图称为哈密顿图。</p>

<h4 id="哈密尔顿通路">哈密尔顿通路</h4>

<p>无向图G中穿过每个顶点一次且仅一次的非闭合链，称为哈密顿链. 有向图D中穿过每个顶点一次且仅一次的非闭合通路，称为哈密顿通路。</p>

<h4 id="定理-1">定理</h4>

<ul>
  <li>设G是具有n个顶点的连通无向图。若G中每一对顶点的次数之和大于或等于n-1，则G中存在一条哈密顿链。</li>
  <li>若G中每一对顶点的次数之和大于或等于n，则G中存在一条哈密顿圈。</li>
  <li>在一个有向完全图中必存在一条哈密顿通路。</li>
</ul>

<h4 id="构建邻接表">构建邻接表</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">adjacentlist</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">):</span>
    <span class="c1"># 返回与美国顶点直接相连的点集
</span>    <span class="n">Ea</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
        <span class="n">e0</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="p">]</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">w</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">e1</span><span class="p">):</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="n">e1</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">w</span> <span class="ow">and</span> <span class="p">(</span><span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">e1</span><span class="p">):</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="n">e1</span> <span class="o">+</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="n">e0</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">+</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e1</span><span class="p">)]</span>
        <span class="n">Ea</span> <span class="o">=</span> <span class="n">Ea</span> <span class="o">+</span> <span class="p">[</span><span class="n">e0</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Ea</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="哈密尔顿图周游算法">哈密尔顿图周游算法</h4>

<p><strong>程序tourpath0算法：</strong>
（1）取路径path的末尾顶点path[-1]为w。
（2）取顶点w的邻接表E2。
（3）若邻接表E2中顶点u不在path上，则u加入path，否则，返回。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tourpath0</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">V</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">E1</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">E2</span> <span class="o">=</span> <span class="n">E1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">E2</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">):</span>
                <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">if</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">w</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">path</span>
</code></pre></div></div>

<p><strong>程序tourpath1算法：</strong>
（1）取路径path的末尾顶点v=path.pop( )为v。
（2）若 path非空，取路径path的末尾顶点path[-1]为u。
（3）从顶点u的邻接表从顶点v以后依次检查k=E2.index(v)。
（4）若v=E2[k]不在path，则v为path的新末尾顶点，直至邻接表结束。
（5）若path有新顶点，则结束，否则，path弹出末尾顶点。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tourpath1</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">V</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">E1</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">E2</span> <span class="o">=</span> <span class="n">E1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">E2</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span><span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">):</span>
                <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">if</span><span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">break</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span>
</code></pre></div></div>

<p><strong>程序tourpath算法：</strong>
（1）若len(path) == m，则求新的周游通路，即tourpath1(V,E,path,m)。
（2）若len(path) != 0，依次迭代执行tourpath0与tourpath1。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tourpath</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">tourpath1</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">tourpath0</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">tourpath1</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span>
</code></pre></div></div>

<h4 id="哈密尔顿图算法">哈密尔顿图算法</h4>

<ul>
  <li>构建邻接表</li>
  <li>设置初始顶点 v0</li>
  <li>搜寻一条路径</li>
  <li>若 <code class="language-plaintext highlighter-rouge">len(path) == len(V)</code>，则搜寻下一条路径</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Hamiltonpath</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">v0</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">Ea</span><span class="p">,</span> <span class="n">paths</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">Ea</span> <span class="o">=</span> <span class="n">adjacentlist</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">v0</span><span class="p">]</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">tourpath</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Ea</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="n">paths</span> <span class="o">|</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">path</span><span class="p">)}</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">tourpath</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Ea</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">paths</span> <span class="o">|</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">path</span><span class="p">)}</span>
            <span class="k">print</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">paths</span>
</code></pre></div></div>

<h4 id="彼得森图-pertersen-graph">彼得森图 (Pertersen Graph)</h4>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210617090501213.png" alt="image-20210617090501213" /></p>

<h4 id="完全图哈密尔顿圈">完全图哈密尔顿圈</h4>

<blockquote>
  <p>完全图G=&lt;V,E&gt;非重复边的哈密尔顿圈数为多少？</p>
</blockquote>

<h3 id="骑士周游问题">骑士周游问题</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Knighttouregraph</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">P8</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="n">E</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="n">n</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="ow">in</span> <span class="n">P8</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">|</span> <span class="p">{(</span><span class="n">k</span><span class="p">,(</span><span class="n">i</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">v</span><span class="p">))}</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span>
</code></pre></div></div>

<blockquote>
  <p>骑士周游图是欧拉图吗？</p>
</blockquote>

<h3 id="完全图哈密尔顿圈-1">完全图哈密尔顿圈</h3>

<ul>
  <li>完全图有哈密尔顿圈</li>
  <li>寻找不重复的哈密尔顿圈</li>
  <li>完全图的哈密尔顿圈数为 <code class="language-plaintext highlighter-rouge">int(len(v)/2)</code></li>
</ul>

<h3 id="旅行商问题">旅行商问题</h3>

<h2 id="通路问题">通路问题</h2>

<h3 id="最短路径">最短路径</h3>

<p>在带权有向图G中，给定一个称为始点的顶点u和一个称为终点的顶点v，如果P是从u到v的通路中<strong>权值最小的通路</strong>，则称P为从u到v的最短通路。</p>

<h4 id="djikstra-最短通路算法">Djikstra 最短通路算法</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">shortpath</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="n">Hx</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">zn</span><span class="p">):</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">Pm</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">vn</span> <span class="o">==</span> <span class="n">zn</span><span class="p">:</span>
            <span class="n">Pm</span> <span class="o">=</span> <span class="n">Pm</span> <span class="o">+</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">di</span><span class="p">[</span><span class="n">V</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">vn</span><span class="p">)]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Pm</span> <span class="o">=</span> <span class="n">Pm</span> <span class="o">+</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">vn</span><span class="p">:</span>
                <span class="n">kv</span> <span class="o">=</span> <span class="n">V</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">di</span><span class="p">[</span><span class="n">kv</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">di</span><span class="p">[</span><span class="n">kv</span><span class="p">]</span> <span class="o">=</span> <span class="n">di</span><span class="p">[</span><span class="n">kv</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">vw</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span>
                <span class="k">if</span> <span class="n">vw</span> <span class="o">&lt;=</span> <span class="n">Hx</span><span class="p">[</span><span class="n">kv</span><span class="p">]:</span>
                    <span class="n">Hx</span><span class="p">[</span><span class="n">kv</span><span class="p">]</span> <span class="o">=</span> <span class="n">vw</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="n">vw</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                    <span class="n">Pm</span> <span class="o">=</span> <span class="n">Pm</span> <span class="o">+</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">di</span><span class="p">,</span> <span class="n">Hx</span><span class="p">,</span> <span class="n">Pm</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">shortestpath</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">vn</span><span class="p">):</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="n">do</span><span class="p">]</span> <span class="o">=</span> <span class="n">degreesetw</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="n">Pm0</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Pm</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="n">v0</span><span class="p">]]</span>
    <span class="n">inf</span> <span class="o">=</span> <span class="mi">10000</span>
    <span class="n">Hx</span> <span class="o">=</span> <span class="p">[</span><span class="n">inf</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">))]</span>
    <span class="n">Hx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">Pm0</span> <span class="o">!=</span> <span class="n">Pm</span><span class="p">:</span>
        <span class="n">Pm0</span> <span class="o">=</span> <span class="n">Pm</span>
        <span class="p">[</span><span class="n">di</span><span class="p">,</span> <span class="n">Hx</span><span class="p">,</span> <span class="n">Pm</span><span class="p">]</span> <span class="o">=</span> <span class="n">shortpath</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="n">Hx</span><span class="p">,</span> <span class="n">Pm0</span><span class="p">,</span> <span class="n">vn</span><span class="p">)</span>
    <span class="n">Pm</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Pm</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Hx</span><span class="p">,</span> <span class="n">Pm</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="关键路径">关键路径</h3>

<h4 id="最早完成时间算法">最早完成时间算法</h4>

<h4 id="最晚完成时间算法">最晚完成时间算法</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 入度为 0
</span><span class="k">def</span> <span class="nf">stepu0v</span><span class="p">(</span><span class="n">di0</span><span class="p">,</span><span class="n">E</span><span class="p">):</span>
    <span class="n">S</span><span class="o">=</span><span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="n">u0</span> <span class="ow">in</span> <span class="n">di0</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">u0</span><span class="p">:</span>
                <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="o">|</span><span class="p">{(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">S</span>

<span class="c1"># 出度为 0
</span><span class="k">def</span> <span class="nf">stepuv0</span><span class="p">(</span><span class="n">do0</span><span class="p">,</span><span class="n">E</span><span class="p">):</span>
    <span class="n">S</span><span class="o">=</span><span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="n">v0</span> <span class="ow">in</span> <span class="n">do0</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v0</span><span class="p">:</span>
                <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="o">|</span><span class="p">{(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">S</span>

<span class="c1"># 最早时间路径
</span><span class="k">def</span> <span class="nf">TEpath</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">Hx</span><span class="p">,</span><span class="n">di</span><span class="p">):</span>
    <span class="n">di0</span><span class="o">=</span><span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Hx</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Hx</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">+</span><span class="n">w</span><span class="p">:</span>
            <span class="n">Hx</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">Hx</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">+</span><span class="n">w</span>
        <span class="k">if</span> <span class="n">di</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">di</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">di</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">di</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">di0</span><span class="o">=</span><span class="n">di0</span> <span class="o">|</span> <span class="p">{</span><span class="n">v</span><span class="p">}</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Hx</span><span class="p">,</span><span class="n">di</span><span class="p">,</span><span class="n">di0</span><span class="p">]</span>

<span class="c1"># 最晚时间路径
</span><span class="k">def</span> <span class="nf">TLpath</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">Hy</span><span class="p">,</span><span class="n">do</span><span class="p">):</span>
    <span class="n">do0</span><span class="o">=</span><span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Hy</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Hy</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-</span><span class="n">w</span><span class="p">:</span>
            <span class="n">Hy</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">Hy</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-</span><span class="n">w</span>
        <span class="k">if</span> <span class="n">do</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">do</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">do</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">do</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">do0</span><span class="o">=</span><span class="n">do0</span> <span class="o">|</span> <span class="p">{</span><span class="n">u</span><span class="p">}</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Hy</span><span class="p">,</span><span class="n">do</span><span class="p">,</span><span class="n">do0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">craticalTE</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">vn</span><span class="p">):</span>
    <span class="n">Hx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">di0</span> <span class="o">=</span> <span class="p">{</span><span class="n">v0</span><span class="p">}</span>
    <span class="k">while</span> <span class="n">vn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">di0</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">stepu0v</span><span class="p">(</span><span class="n">di0</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
        <span class="p">[</span><span class="n">Hx</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="n">di0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TEpath</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Hx</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">S</span>
    <span class="k">return</span> <span class="n">Hx</span>

<span class="k">def</span> <span class="nf">craticalTL</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">do</span><span class="p">,</span><span class="n">Hn</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">vn</span><span class="p">):</span>
    <span class="n">Hy</span><span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">Hy</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">Hn</span>
    <span class="n">do0</span><span class="o">=</span><span class="p">{</span><span class="n">vn</span><span class="p">}</span>
    <span class="k">while</span> <span class="n">v0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">do0</span><span class="p">:</span>
        <span class="n">S</span><span class="o">=</span><span class="n">stepuv0</span><span class="p">(</span><span class="n">do0</span><span class="p">,</span><span class="n">E</span><span class="p">)</span>
        <span class="p">[</span><span class="n">Hy</span><span class="p">,</span><span class="n">do</span><span class="p">,</span><span class="n">do0</span><span class="p">]</span><span class="o">=</span><span class="n">TLpath</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">Hy</span><span class="p">,</span><span class="n">do</span><span class="p">)</span>
        <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="o">-</span><span class="n">S</span>
    <span class="k">return</span> <span class="n">Hy</span>
</code></pre></div></div>

<h4 id="关键路径算法">关键路径算法</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 关键通路
</span><span class="k">def</span> <span class="nf">craticalpath</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">di</span><span class="p">,</span><span class="n">do</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">vn</span><span class="p">):</span>
    <span class="n">Hx</span><span class="o">=</span><span class="n">craticalTE</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">di</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">vn</span><span class="p">)</span>
    <span class="n">Hn</span><span class="o">=</span><span class="n">Hx</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Hy</span><span class="o">=</span><span class="n">craticalTL</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">do</span><span class="p">,</span><span class="n">Hn</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">vn</span><span class="p">)</span>
    <span class="n">V</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">C</span><span class="o">=</span><span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">Hx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">Hy</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="o">|</span><span class="p">{</span><span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">]}</span>
    <span class="n">Pc</span><span class="o">=</span><span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">C</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
            <span class="n">Pc</span><span class="o">=</span><span class="n">Pc</span><span class="o">|</span><span class="p">{(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">Pc</span>
</code></pre></div></div>

<h2 id="树">树</h2>

<h3 id="引论">引论</h3>

<h3 id="树概念">树概念</h3>

<h4 id="树的定义">树的定义</h4>

<p>设G=&lt;V, E&gt;是无向图，若G 连通且无圈，则称为树，记为GT=&lt;V, E&gt;。</p>

<h4 id="定理-2">定理</h4>

<ul>
  <li>设 T 是树，则在 T 的任何两个不同顶点之间存在唯一的一条基本链。若在 T 的两个不相邻顶点之间加上一条边 e，则图 T+e 仅有一个圈</li>
  <li>设树 T 是一个 (n, m) 图，则 m = n - 1</li>
  <li>非平凡树 T 中至少存在两个次数为 1 的顶点</li>
  <li>设 T 是非平凡 (n, m) 无向图，则下面五个命题等价
    <ul>
      <li>T 是树</li>
      <li>T 连通且无圈</li>
      <li>T 的每一对顶点之间有唯一的一条基本链</li>
      <li>T 连通且 m = n - 1</li>
      <li>T 无圈且 m = n - 1</li>
    </ul>
  </li>
</ul>

<h4 id="树的构建">树的构建</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">graph2tree</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="n">E</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Vt</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">}</span>
    <span class="n">Et</span> <span class="o">=</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
    <span class="n">E</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Et</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Vt</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">u</span> <span class="ow">in</span> <span class="n">Vt</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Vt</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Vt</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Vt</span><span class="p">)):</span>
                <span class="n">Vt</span> <span class="o">=</span> <span class="n">Vt</span> <span class="o">|</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">}</span>
                <span class="n">Et</span> <span class="o">=</span> <span class="n">Et</span> <span class="o">|</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">Et</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">Vt</span><span class="p">)):</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Vt</span><span class="p">,</span> <span class="n">Et</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="树的判断">树的判断</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">istree</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="n">tv</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">E</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Vt</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">}</span>
    <span class="n">E</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">-</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
    <span class="n">Et</span> <span class="o">=</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">E</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">({})):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="ow">in</span> <span class="n">Vt</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">Vt</span><span class="p">):</span>
                <span class="n">tv</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">u</span> <span class="ow">in</span> <span class="n">Vt</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Vt</span><span class="p">))</span> <span class="ow">or</span> <span class="p">((</span><span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Vt</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">Vt</span><span class="p">)):</span>
                <span class="n">Vt</span> <span class="o">=</span> <span class="n">Vt</span> <span class="o">|</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">}</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
                <span class="n">Et</span> <span class="o">=</span> <span class="n">Et</span> <span class="o">|</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tv</span> <span class="o">==</span> <span class="bp">False</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Vt</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Et</span><span class="p">)):</span>
        <span class="n">tv</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">tv</span>
</code></pre></div></div>

<h3 id="各类树">各类树</h3>

<h4 id="根树">根树</h4>

<p>若一个<strong>有向树</strong>有一个引入次数为0的顶点，而所有其他顶点的引入次数都为1，则称该有向树为<strong>根树</strong>。引入次数为0的顶点称为<strong>树根</strong>。</p>

<h4 id="m-元树">m 元树</h4>

<p>若根树中的每个顶点的引出次数都<strong>小于或等于</strong> m，则称这种根树为 m 元树。</p>

<h5 id="完全-m-元树">完全 m 元树</h5>

<p>每个顶点的引出次数等于 m 或 0</p>

<h5 id="位置-m-元树">位置 m 元树</h5>

<p>任何顶点的 m 个子结点都有位置</p>

<h5 id="二叉树">二叉树</h5>

<p>m = 2</p>

<h4 id="有序树">有序树</h4>

<p>设T=&lt;V,E&gt;是根树，并且每个顶点的子顶点是<strong>有序</strong>的，则称为有序树。</p>

<p>&lt;u,v,k&gt;表示u的第k个子</p>

<h3 id="二叉树-1">二叉树</h3>

<h4 id="定义-4">定义</h4>

<p>设T=&lt;V,E&gt;是有序树，并且每个顶点的最多有2个子顶点，则称为二叉树。</p>

<h4 id="递归定义">递归定义</h4>

<p>定义：设 $T = &lt;V, E&gt;$</p>

<ol>
  <li>$[\ ]$ 是二叉树。</li>
  <li>$a\in V$，$[a]$是二叉树。</li>
  <li>若$a\in V$，$R_t$ 和 $L_t$ 是二叉树，则 $[a,L_t, R_t]$ 是二叉树。</li>
</ol>

<h4 id="二叉树构建算法-set-list-结构">二叉树构建算法 (set, list 结构)</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createbitree</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span> <span class="o">-</span> <span class="p">{</span><span class="n">a</span><span class="p">}</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Lnodes</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">Lnodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">Lnodes</span><span class="p">)</span>
    <span class="n">Rnodes</span> <span class="o">=</span> <span class="n">nodes</span> <span class="o">-</span> <span class="n">Lnodes</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">createbitree</span><span class="p">(</span><span class="n">Lnodes</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">createbitree</span><span class="p">(</span><span class="n">Rnodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">bitree</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nodes</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">Lnodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">k</span><span class="p">]</span>
    <span class="n">Rnodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">:]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">bitree</span><span class="p">(</span><span class="n">Lnodes</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">bitree</span><span class="p">(</span><span class="n">Rnodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="二叉树与图">二叉树与图</h4>

<h5 id="从树结构变换为图结构">从树结构变换为图结构</h5>

<ol>
  <li>若<code class="language-plaintext highlighter-rouge">len(tree)=0</code>或<code class="language-plaintext highlighter-rouge">len(tree)=1</code>，则为空集。</li>
  <li>tree有左子树，则<code class="language-plaintext highlighter-rouge">L=tree2graph(tree[1])</code>, <code class="language-plaintext highlighter-rouge">gtree=gtree | {(tree[0],tree[1][0])} | L</code></li>
  <li>tree有右子树，则<code class="language-plaintext highlighter-rouge">R=tree2graph(tree[2])</code>, <code class="language-plaintext highlighter-rouge">gtree=gtree | {(tree[0],tree[2][0])} | R</code></li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tree2graph</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="n">gtree</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">|</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gtree</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">tree2graph</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">gtree</span> <span class="o">=</span> <span class="n">gtree</span> <span class="o">|</span> <span class="p">{(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])}</span> <span class="o">|</span> <span class="n">L</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">tree2graph</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">gtree</span> <span class="o">=</span> <span class="n">gtree</span> <span class="o">|</span> <span class="p">{(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])}</span> <span class="o">|</span> <span class="n">R</span>
    <span class="k">return</span> <span class="n">gtree</span>
</code></pre></div></div>

<h4 id="二叉树结构">二叉树结构</h4>

<p>从有序树生成二叉树</p>

<h4 id="遍历">遍历</h4>

<p>设G=&lt;E,V&gt;是二叉树，访问G的每个顶点的过程称为遍历。</p>

<p>设 $G=&lt;E,V&gt;$ 是二叉树，$r$ 根顶点，若 $V={r}$ ，则 $r$ 是前序遍历，否则，若 $T_1$ 和 $T_2$ 是 $r$ 的左右子树，则先访问顶点 $r$，而后分别前序遍历子树 $T_1$ 和 $T_2$ 。</p>

<h5 id="前序遍历">前序遍历</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">preordertraversal</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">preordertraversal</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">preordertraversal</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</code></pre></div></div>

<h5 id="中序遍历">中序遍历</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">inordertraversal</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">preordertraversal</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">preordertraversal</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</code></pre></div></div>

<h5 id="后序遍历">后序遍历</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">postordertraversal</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">preordertraversal</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">preordertraversal</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</code></pre></div></div>

<h4 id="表达式树">表达式树</h4>

<h3 id="霍夫曼编码">霍夫曼编码</h3>

<h4 id="二元前缀码">二元前缀码</h4>

<p>用0-1字符串作为代码表示字符，要求<strong>任何字符的代码都不能作为其他字符代码的前缀</strong>；</p>

<p>对于位置二叉树，可以采用二元前缀编码，使得每一个顶点都与唯一的一个取自字符表 {0,1} 的字符串对应</p>

<ol>
  <li>树根对应空串</li>
  <li>字符串为 a 的顶点，左子结点的为 0，右子节点为 1</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>位置字符串的前缀编码 = {a</td>
          <td>a 的树叶对应的字符串}</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h4 id="霍夫曼编码-1">霍夫曼编码</h4>

<ol>
  <li>假设顶点集合为 $S$, $u_1$ 和 $u_2$ 是权值最低的两个顶点</li>
  <li>构造一个新的顶点 $w$，令 $w$ 的左侧子结点为 $u_1$，右侧子结点为 $u_2$，权值为 $u_1$, $u_2$ 之和</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$S\leftarrow(S-{u_1,u_2})\cup{w}$, 返回步骤 1，直至 $</td>
          <td>S</td>
          <td>= 1$</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h4 id="霍夫曼树的构建与编码熵">霍夫曼树的构建与编码熵</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">codingentropy</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="c1"># 求得编码熵
</span>    <span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">W</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">W</span><span class="p">)):</span>
        <span class="n">r0</span> <span class="o">-=</span> <span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">log2</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">r0</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">floor</span><span class="p">((</span><span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">floor</span><span class="p">((</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">r0</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">Huffmantree</span><span class="p">(</span><span class="n">W</span><span class="p">):</span>
    <span class="c1"># 构建霍夫曼树
</span>    <span class="n">W0</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span> <span class="ow">in</span> <span class="n">W</span><span class="p">:</span>
        <span class="n">W0</span> <span class="o">=</span> <span class="n">W0</span> <span class="o">+</span> <span class="p">[[</span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">]]</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">W0</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="p">[[</span><span class="n">w</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">Huffmantree2graph</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="n">gtree</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gtree</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">Huffmantree2graph</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">Huffmantree2graph</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span>
    <span class="n">gtree</span> <span class="o">=</span> <span class="p">{(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">)}</span> <span class="o">|</span> <span class="p">{(</span><span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">)}</span> <span class="o">|</span> <span class="n">L</span> <span class="o">|</span> <span class="n">R</span>
    <span class="k">return</span> <span class="n">gtree</span>


<span class="k">def</span> <span class="nf">htree2graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span> <span class="o">|</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">}</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">E</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
    <span class="k">for</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">|</span> <span class="p">{(</span><span class="n">V</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">V</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">))}</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">huffmancoding</span><span class="p">(</span><span class="n">subtree</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">subtree</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">code</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">node0</span> <span class="o">=</span> <span class="n">subtree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">node1</span> <span class="o">=</span> <span class="n">subtree</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">huffmancoding</span><span class="p">(</span><span class="n">node0</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s">'0'</span><span class="p">)</span> <span class="o">+</span> <span class="n">huffmancoding</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s">'1'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">code</span>


<span class="k">def</span> <span class="nf">HuffmanCoding</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="n">code0</span> <span class="o">=</span> <span class="n">huffmancoding</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">'0'</span><span class="p">)</span>
    <span class="n">code1</span> <span class="o">=</span> <span class="n">huffmancoding</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">'1'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">code0</span> <span class="o">+</span> <span class="n">code1</span>
</code></pre></div></div>

<h3 id="生成树">生成树</h3>

<h4 id="生成树-spanning-trees">生成树 (Spanning Trees)</h4>

<p>如果无向图 G 的一个生成子图 T 是树，则称 T 是图 G 的一个生成树</p>

<h4 id="最小生成树-minimum-spanning-trees-mst">最小生成树 (Minimum Spanning Trees, MST)</h4>

<p>对于一个<strong>带权无向连通</strong>图，最小生成树是其生成树中边的权重之和最小的那个</p>

<p><strong>最小生成树可能不唯一</strong></p>

<h4 id="安全边-save-edge">安全边 (save edge)</h4>

<p>对于边的集合 $A\subseteq T$, 其中 $T$ 是一棵最小生成树，如果集合 $A\cup{(u, v)}$ 同样属于 $T$，则 $(u,v)$ 是集合 $A$ 的安全边</p>

<blockquote>
  <p>若每一步都向集合中增加一条安全边，就可以找到图 G 的最小生成树</p>
</blockquote>

<h4 id="分割-cut">分割 (Cut)</h4>

<p>表示为 $(S, V-S)$ 是图 $(V, E)$ 的一个划分，划分之和，一部分节点 $\in S$，其他节点 $\not\in S \Rightarrow \in {V-S}$</p>

<h4 id="横跨-cross">横跨 (Cross)</h4>

<p>如果边 $(u, v)\in E$ 的一个端点在集合 $S$ 中，另一个端点在集合 $(V-S)$ 中，则称边 $(u,v)$ 是分割的横跨边</p>

<h4 id="尊重-respect">尊重 (Respect)</h4>

<p>如果集合 A 中不存在横跨该分割的边，则称该分割 <strong>尊重</strong> 集合 $A$</p>

<h4 id="轻边-light-edge">轻边 (Light Edge)</h4>

<p>在横跨一个分割的所有边中，权重最小的边，称为 <strong>轻边</strong></p>

<h4 id="定理寻找安全边">定理（寻找安全边）</h4>

<ol>
  <li>对于 <strong>带权无向连通图</strong> $G(V, E, W)$</li>
  <li>假设边的集合 $A$ 为一棵最小生成树的子集</li>
  <li>$(S, V-S)$ 为任意尊重 $A$ 的分割</li>
  <li>$(u,v)$ 是横跨分割 $(S, V-S)$ 的轻边</li>
</ol>

<p>那么，边 $(u, v)$ 是 $A$ 的一条安全边</p>

<h4 id="kruskal-算法">Kruskal 算法</h4>

<h5 id="算法思路">算法思路</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">将图看作离散的点和一堆边</span>
<span class="n">dot</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="n">num</span><span class="p">(</span><span class="n">边</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">从未选择的边中找到满足</span><span class="err">：</span><span class="o">&lt;</span><span class="n">m</span> <span class="p">,</span><span class="n">n</span><span class="o">&gt;</span>
    <span class="mf">1.</span> <span class="n">权重最小</span>
    <span class="mf">2.</span> <span class="n">两个端点不同时出现在已连接的点中</span>
    <span class="n">dot</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">dot</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">将边从未选择中删除</span>
    <span class="n">num</span><span class="p">(</span><span class="n">边</span><span class="p">)</span> <span class="o">++</span>
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>![img](https://upload-images.jianshu.io/upload_images/3755117-2656ffcd5cdb097d.png?imageMogr2/auto-orient/strip</td>
      <td>imageView2/2/w/1200/format/webp)</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>![img](https://upload-images.jianshu.io/upload_images/3755117-8392698e3388fece.png?imageMogr2/auto-orient/strip</td>
      <td>imageView2/2/w/1200/format/webp)</td>
    </tr>
  </tbody>
</table>

<h4 id="prim-算法">Prim 算法</h4>

<table>
  <tbody>
    <tr>
      <td>![img](https://upload-images.jianshu.io/upload_images/3755117-4491cf0d977af08c.png?imageMogr2/auto-orient/strip</td>
      <td>imageView2/2/w/1200/format/webp)</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>![img](https://upload-images.jianshu.io/upload_images/3755117-ac654c5400c4a97e.png?imageMogr2/auto-orient/strip</td>
      <td>imageView2/2/w/1200/format/webp)</td>
    </tr>
  </tbody>
</table>

<h3 id="平面图及着色">平面图及着色</h3>

<h4 id="平面图">平面图</h4>

<p>所有边在顶点以外没有任何交叉的图称为 <strong>平面图</strong></p>

<h4 id="非平面图">非平面图</h4>

<h5 id="k_33">$K_{3,3}$</h5>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619181532731.png" alt="image-20210619181532731" /></p>

<ul>
  <li>$k_{3,3}$ 是边数最少的非平面图</li>
</ul>

<h5 id="k_5">$k_{5}$</h5>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619181621676.png" alt="image-20210619181621676" /></p>

<ul>
  <li>$k_5$ 是顶点数最少的非平面图</li>
</ul>

<p>$k_{3,3}$ 和 $k_{5}$ 删除任意一条边就是平面图</p>

<h4 id="平面图的面">平面图的面</h4>

<p>当把一个连通平面图 G 画在平面上，使它的边在顶点之外没有任何交叉时，G 的边把平面分割成许多区域，这样的一个区域称为图 G 的面。</p>

<h5 id="有限面">有限面</h5>

<p>平面图内部的各个有限区域</p>

<h5 id="无限面">无限面</h5>

<p>平面图外部的无限区域</p>

<h4 id="周界">周界</h4>

<p>围成一个面的各边构成的闭合链，称为 <strong>周界</strong></p>

<h4 id="次数">次数</h4>

<p>一个平面图所有面的次数之和等于边的数量的两倍</p>

<h4 id="欧拉公式">==欧拉公式==</h4>

<p>具有 $n$ 个顶点，$m$ 条边， $k$ 个面的 $(m,n)$ 连通平面图 $G$，等式（欧拉公式）恒成立：$n-m+k=2$</p>

<h4 id="极大平面图">极大平面图</h4>

<p>设图 G 是一个平面图，如果连接 G 的任意两个不邻接顶点 $u$ 和 $v$ ，都会使 $G+(u,v)$ 变成非平面图，则称图 $G$ 是极大平面图</p>

<h5 id="定理-3">定理</h5>

<p>设 G 是具有至少三个顶点的极大平面图，则 G 的任何一个面都是 $k_3$，$3k=2m$</p>

<h5 id="极大平面图的欧拉公式">极大平面图的欧拉公式</h5>

<ul>
  <li>若一个图的极大平面图，则 $m = 3n-6$</li>
  <li>若一个图是平面图，则 $m\le 3n-6$，尚可加边</li>
</ul>

<h4 id="同胚">同胚</h4>

<p>反复插入和（或）除去次数为 2 的顶点，它们能变成同构的图</p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619202100986.png" alt="image-20210619202100986" /></p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619202104794.png" alt="image-20210619202104794" /></p>

<h5 id="库拉图斯基-kuratowski-定理">库拉图斯基 (Kuratowski) 定理</h5>

<p>图 G 是平面图，当且仅当它不包含同胚于 $k_{3,3}$ 或 $k_5$ 的子图</p>

<h4 id="着色问题">着色问题</h4>

<p>给定一个无向图 $G(V, E)$，其中 $V$ 为顶点集合，$E$ 为边集合。图着色问题为：将 $V$ 分成 $K$ 个颜色组，没有相邻顶点同色，取最小的 $K$ 值</p>

<h4 id="对偶图">对偶图</h4>

<p>设 $G$ 是一个平面图，有 $k$ 个面，记为 $F_1, F_2, …, F_k$，其中包括无限面，按如下方式构造的图 $G^*$ 称为图 $G$ 的对偶图：</p>

<ul>
  <li>将每个面 $F_i$ 作为 $G^*$ 的一个顶点 $f_j$</li>
  <li>对于两个面 $F_i$ 和 $F_j$ 的公共边，对应图 $G^*$ 中的边 $(f_i, f_j)$</li>
  <li>对于仅属于一个面的边（如悬挂边和桥边），则对应图 $G^*$ 中的自环</li>
</ul>

<p><em>对偶图将地图的着色问题转换为一般图的顶点着色问题</em></p>

<h4 id="平面图的着色">平面图的着色</h4>

<ul>
  <li>对给定的无向图 G 的顶点进行涂色，如果每个顶点只涂一种颜色并且任何两个邻接的顶点颜色不同，则称为图的一个正常着色。正常着色所需要的最少颜色数，称为图 G 的 <strong>着色数</strong>，记为 $\chi(G)$</li>
  <li>对于不是零图的无向图 G，以下三个说法等价：
    <ul>
      <li>图 G 的着色数 $\chi(G) = 2$</li>
      <li>图 G 是二分图</li>
      <li>图 G 的所有圈的长度都是偶数</li>
    </ul>
  </li>
  <li>对以下图的着色数容易计算
    <ul>
      <li>对于 <strong>零图</strong>，$\chi(G) = 1$</li>
      <li>对于具有 n 个顶点的完全图 $K_N$，着色数 $\chi(G) = n$</li>
      <li>对于两个或两个以上节点的树 $T$，着色数 $\chi(G) = 2$</li>
    </ul>
  </li>
</ul>

<h4 id="韦尔奇-鲍威尔算法">韦尔奇-鲍威尔算法</h4>

<ul>
  <li>将图 G 的顶点按次数递减的顺序排序</li>
  <li>用一种颜色涂染序列中的第一个顶点，以及与该顶点不相邻的每一个顶点</li>
  <li>余下的节点重新排序，按照上述方法重新着色</li>
</ul>

<blockquote>
  <p>此算法不保证能用最少色数</p>
</blockquote>

<h4 id="五色定理">五色定理</h4>

<p>对任意一个平面图 G，都有 $\chi(G) \le 5$</p>

<h5 id="证明">证明</h5>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619204950520.png" alt="image-20210619204950520" /></p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619204955910.png" alt="image-20210619204955910" /></p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619205224413.png" alt="image-20210619205224413" /></p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619205229157.png" alt="image-20210619205229157" /><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619205244631.png" alt="image-20210619205244631" /><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619205233370.png" alt="image-20210619205233370" /></p>

<h3 id="二分图与匹配">二分图与匹配</h3>

<h4 id="二分图">二分图</h4>

<p>设 $G = &lt;V, E&gt;$ 是一个无向图，如果可以把 $V$ 划分成两个子集 $X$ 和 $Y$，使得同一个子集中的任何两个顶点都不邻接，则称图 $G$ 为 <strong>二分图</strong>。$X$ 和 $Y$ 称为 $G$ 的互补顶点子集</p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619205612678.png" alt="image-20210619205612678" /></p>

<h4 id="完全二分图">完全二分图</h4>

<p>$X$ 中的每个顶点都与 $Y$ 中的所有顶点邻接。若 $#X=p, #Y = q$，则将其记为 $K_{p,q}$</p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619205800704.png" alt="image-20210619205800704" /></p>

<h4 id="定理-4">定理</h4>

<ul>
  <li>$G$ 是一个二分图，当且仅当非平凡无向图 $G$ 的所有圈的长度都是偶数</li>
</ul>

<h4 id="二分图匹配">二分图匹配</h4>

<h5 id="匹配">匹配</h5>

<p>设  $G = &lt;V, E&gt;$ 是一个二分图，如果 $E$ 的一个子集 $M$ 中的任何两条边都不相邻，则称 $M$ 为二分图 $G$ 的一个匹配</p>

<h5 id="饱和顶点--非饱和顶点">饱和顶点 &amp; 非饱和顶点</h5>

<p>此时，$M$ 中的边所关联的顶点称为 $M$ 的 <strong>饱和顶点</strong>，而 $G$ 的其他顶点为 <strong>非饱和顶点</strong></p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619210401708.png" alt="image-20210619210401708" /></p>

<h5 id="最大匹配">最大匹配</h5>

<p>在二分图 $G$ 的所有匹配中， <strong>边数</strong> 最多的匹配称为 $G$ 的 <strong>最大匹配</strong></p>

<h5 id="交错链">交错链</h5>

<p>设 $M$ 是二分图 $G$ 的一个匹配。如果 $G$ 中有这样一条基本链， <strong>链中任何相邻的两条边中恰好有一条属于 $M$</strong>，则称这样的链为关于 $M$ 的 <strong>交错链</strong></p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619210708537.png" alt="image-20210619210708537" /></p>

<h5 id="可扩充链">可扩充链</h5>

<p>若一条交错链的两个端点是 $M$ 的非饱和顶点，则称该交错链为关于 $M$ 的 <strong>可扩充链</strong> (M-augmenting path)</p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619210919683.png" alt="image-20210619210919683" /></p>

<h5 id="最大匹配相关定理">最大匹配相关定理</h5>

<p>设 $M$ 是二分图 $G$ 的一个匹配，当且仅当 $G$ 中不存在关于 $M$ 的可扩充链时，$M$ 是 $G$ 的最大匹配</p>

<h5 id="匈牙利算法">匈牙利算法</h5>

<ol>
  <li>任取一个匹配 $M$ （可以冲空集或一条边开始）</li>
  <li>令 $S$ 是非饱和顶点（尚未匹配的点）的集合</li>
  <li>若 $S=\empty$，则 $M$ 已经是最大匹配</li>
  <li>否则，从 $S$ 中取出一个非饱和顶点 $u_0$ 作为起点，从 $u_0$ 开始找到交错链 $P$</li>
  <li>如 $P$ 是可扩充链，则令 $M = (M\cup P)-(M\cap P)$</li>
  <li>如 $P$ 不是可扩充链，则去掉 $u_0$，回到第 3 步</li>
</ol>

<h5 id="从-x-到-y-的匹配">从 $X$ 到 $Y$ 的匹配</h5>

<p>如有二分图 $G$ 的匹配 $M$，使得 $X$ 的每一个顶点都是饱和的，则称 $M$ 为从 $X$ 到 $Y$ 的匹配</p>

<ul>
  <li>若存在从 $X$ 到 $Y$ 的匹配，则应该满足 $#X\le#Y$</li>
  <li>若 $M$ 为从 $X$ 到 $Y$ 的匹配，则 $M$ 是二分图 $G$ 的最大匹配</li>
</ul>

<p><strong>判断从 $X$ 到 $Y$ 的匹配定理</strong></p>

<p>设 $G$ 是一个具有互补顶点子集 $X$ 和 $Y$ 的二分图。当且仅当对于 $X$ 的任意子集 $U$，$#\Gamma(U)\ge#U$ 被满足时，存在 $G$ 的从 $X$ 到 $Y$ 的匹配</p>

<p>其中，$U$ 表示 $X$ 的子集，$\Gamma(U)$ 表示 $U$ 的邻域，即与 $U$ 中顶点邻接的所有顶点的集合，$\Gamma(U)\subseteq Y$</p>

<h6 id="相异性条件">相异性条件</h6>

<p>上述条件被称为 <strong>相异性条件</strong></p>

<h6 id="从-x-到-y-匹配的算法">从 $X$ 到 $Y$ 匹配的算法</h6>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619213305111.png" alt="" /></p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619213331044.png" alt="" /></p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210619213337469.png" alt="image-20210619213337469" /></p>

<h6 id="t-条件">t 条件</h6>

<p>设 $G$ 是具有互补顶点子集 $X$ 和 $Y$ 的二分图，如果能找到一个正整数 t，使得对 $X$ 中的任意顶点 $x$ 有 $d(x)\ge t$，对 $Y$ 的任意顶点有 $d(y)\le t$，则图 $G$ 存在从 $X$ 到 $Y$ 的匹配。定理中的条件称为 “t 条件”</p>

<h5 id="二分图的稳定匹配问题">二分图的稳定匹配问题</h5>

<h6 id="问题定义--描述">问题定义 &amp; 描述</h6>

<h6 id="gale-shapley-算法">Gale-Shapley 算法</h6>

<h1 id="代数系统">代数系统</h1>

<h2 id="知识回顾">知识回顾</h2>

<h3 id="集合">集合</h3>

<h4 id="集合-1">集合</h4>

<p>集合是一些能够<strong>明确区分</strong>的对象构成的整体，集合一般用<em>大写英文字母</em>表示</p>

<ul>
  <li>集合是一组无序对象</li>
  <li>在集合中没有重复出现的元素</li>
</ul>

<h4 id="元素">元素</h4>

<p>如果对象a在集合A中，则称a是A的<strong>元素</strong></p>

<h4 id="集合与元素的关系">集合与元素的关系</h4>

<ul>
  <li>$a属于A, 记为a\in A$</li>
  <li>$a不属于A, 记为a\notin A$</li>
  <li>在数理逻辑中，属于关系$\in$看作是一个谓词：$a\in A, \neg(a\in A$)</li>
</ul>

<h4 id="集合示例">集合示例</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$N={x</td>
          <td>x是自然数}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$I={x</td>
          <td>x是整数}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$Q={x</td>
          <td>x是有理数}$</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="集合运算">集合运算</h4>

<table>
  <thead>
    <tr>
      <th>运算名称</th>
      <th>集合表示</th>
      <th>内涵定义</th>
      <th>谓词逻辑表示</th>
      <th>python文字描述</th>
      <th>python表示</th>
      <th>python 意义</th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>并运算</td>
      <td>$A\cup B$</td>
      <td>${x</td>
      <td>x\in A\vee x\in B}$</td>
      <td>$\forall x(x\in A\cap B\leftrightarrow x\in A\wedge x\in B$)</td>
      <td>A.union(B)</td>
      <td>A$</td>
      <td>$B</td>
      <td>x in A$</td>
      <td>$B==(x in A) or (x in B)</td>
    </tr>
    <tr>
      <td>交运算</td>
      <td>$A\cap B$</td>
      <td>${x</td>
      <td>x\in A\wedge x\in B}$</td>
      <td>$\forall x(x\in A\cup B\leftrightarrow x\in A\vee x\in B$)</td>
      <td>A.intersection(B)</td>
      <td>A&amp;B</td>
      <td>x in A&amp;B==x in A and x in B</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>差运算</td>
      <td>$A-B$</td>
      <td>${x</td>
      <td>x\in A\wedge x\notin B}$</td>
      <td>$\forall x(x\in A-B\leftrightarrow x\in A\wedge\neg x\in B$)</td>
      <td>A.difference(B)</td>
      <td>A-B</td>
      <td>x in A-B==x in A and not(x in B)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>对称差运算</td>
      <td>$A\oplus B$</td>
      <td>${x</td>
      <td>x\in A\oplus x\in B}$</td>
      <td>$\forall x(x\in A\oplus B\leftrightarrow x\in A\oplus x\in B$)</td>
      <td>A.symmetric_difference(B)</td>
      <td>A^B</td>
      <td>x in A^B==x in A$\oplus$x in B</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>补运算</td>
      <td>~$A$</td>
      <td>{$x</td>
      <td>x\notin A$}</td>
      <td>$\forall x(x\in$~$A\leftrightarrow x\notin A)$</td>
      <td>U.differnce(A)</td>
      <td>U-A</td>
      <td>x in ~A==not x in A</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="集合之间的关系">集合之间的关系</h4>

<h5 id="包含关系子集">包含关系（子集）</h5>

<h6 id="定义-5">定义</h6>

<p>若集合A的元素都是集合B的元素，则称A是B的子集，也称A包含于B，或者B包含A，记为A$\subseteq$B</p>

<h6 id="谓词逻辑表示">谓词逻辑表示</h6>

<ul>
  <li>$A\subseteq B\Leftrightarrow\forall x(x\in A\rightarrow x\in B$)</li>
  <li>$A\subset B\Leftrightarrow\forall x(x\in A\rightarrow x\in B$)$\wedge\exists x(x\in B\wedge x\notin A$)</li>
  <li>$A\subset B\Leftrightarrow\forall x(x\in A\rightarrow x\in B$)$\wedge A\cap B\neq\varnothing$</li>
  <li>$A\not\subseteq B\Leftrightarrow\exists x(x\in A\wedge x\notin B$)</li>
</ul>

<h5 id="相等关系">相等关系</h5>

<h6 id="定义外延性公理">定义(外延性公理)：</h6>

<p>如果集合A和B含有相同的元素，则称A和B相等，记为A=B</p>

<h6 id="谓词逻辑表示-1">谓词逻辑表示</h6>

<ul>
  <li>$A=B\Leftrightarrow\forall x(x\in A\leftrightarrow x\in B$)</li>
  <li>$A=B\Leftrightarrow\forall x(x\in A\leftrightarrow x\in B$)$\wedge\forall x(x\in B\rightarrow x\in A$)</li>
</ul>

<h4 id="集合运算性质">集合运算性质</h4>

<table>
  <thead>
    <tr>
      <th>定律</th>
      <th>描述1</th>
      <th>描述2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>结合律</td>
      <td>($A\cup B)\cup C=A\cup(B\cup C$)</td>
      <td>($A\cap B)\cap C=A\cap(B\cap C$)</td>
    </tr>
    <tr>
      <td>交换律</td>
      <td>$A\cup B=B\cup A$</td>
      <td>$A\cap B=B\cap A$</td>
    </tr>
    <tr>
      <td>分配律</td>
      <td>$A\cup(B\cap C$)=($A\cup B)\cap(A\cup C$)</td>
      <td>$A\cap(B\cup C$)=($A\cap B)\cup(A\cap C$)</td>
    </tr>
    <tr>
      <td>德·摩根律</td>
      <td>$\neg(A\cup B)=$$(\neg A)\cap(\neg B)$</td>
      <td>$\neg (A\cap B)=$$(\neg A)\cup (\neg B)$</td>
    </tr>
    <tr>
      <td>幂等律</td>
      <td>$A\cup A=A$</td>
      <td>$A\cap A=A$</td>
    </tr>
    <tr>
      <td>吸收率</td>
      <td>$A\cup(A\cap B$)$=A$</td>
      <td>$A\cap(A\cup B$)$=A$</td>
    </tr>
    <tr>
      <td>对合律</td>
      <td>~~$A=A$</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="函数">函数</h3>

<h4 id="满射单射和双射">满射、单射和双射</h4>

<p>$设函数f:X\rightarrow Y$</p>

<h5 id="满射">满射</h5>

<p>若对于每个 y$\in$Y，都存在 x$\in$X使得 f (x) = y，则称f为满射，即</p>

<ul>
  <li>$\forall y(y\in Y\rightarrow\exists x(x\in X\wedge f(x$$)=y))$</li>
</ul>

<h5 id="单射">单射</h5>

<p>若对于任意 x1$\in$X, x2$\in$X， 若 f (x$_1$) = f (x$_2$)则x1=x2，称 f 为单射，即</p>

<ul>
  <li>$\forall x_1\forall x_2(x_1\in X\wedge x_2\in X\wedge f(x_1$$)=f(x_2$$)\rightarrow x_1=x_2$</li>
</ul>

<h5 id="双射">双射</h5>

<p>$f$既是单射又是满射，则$f$是双射函数。</p>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210628124603445.png" alt="image-20210628124603445" /></p>

<h3 id="关系-1">关系</h3>

<h4 id="关系的定义">关系的定义</h4>

<p>设X,Y是集合，若R$\subseteq$X × Y, 则称R为从X到Y的关系，简称为关系R</p>

<ul>
  <li>将&lt;x,y&gt;$\in$R表示为x$R$y, 读作“x和y有关系R”</li>
  <li>将&lt;x,y&gt;$\not\in$R表示为x$\underline{R}$y, 读作“x和y没有关系R”</li>
</ul>

<p>若R是从X到Y的关系，就是集合X中元素与集合Y中元素之间的对应</p>

<ul>
  <li>从集合X中选择一个元素x, 对应地再集合Y中选择一个元素y</li>
  <li>x和y组成一个有序偶(x,y)</li>
  <li>有序偶(x,y)$\in$R</li>
</ul>

<h4 id="定义域和值域">定义域和值域</h4>

<h5 id="定义域">定义域</h5>

<p>关系R中所有有序偶的第一元组成的集合称为R的定义域，记为<strong>dom(R)</strong></p>

<table>
  <tbody>
    <tr>
      <td>dom(R)={x</td>
      <td>$\exists$y(&lt;x,y$\in$R&gt;)}</td>
    </tr>
  </tbody>
</table>

<h5 id="值域">值域</h5>

<p>关系R中所有有序偶的第二元组成的集合称为R的值域，记为<strong>ran(R)</strong></p>

<table>
  <tbody>
    <tr>
      <td>ran(R)={y</td>
      <td>$\exists$x(&lt;x,y&gt;$\in$R)}</td>
    </tr>
  </tbody>
</table>

<h4 id="特殊关系">特殊关系</h4>

<h5 id="空关系varnothing">空关系$\varnothing$</h5>

<h5 id="恒等关系">恒等关系</h5>

<table>
  <tbody>
    <tr>
      <td>$I_x={&lt;x,x&gt;</td>
      <td>x\in X}$</td>
    </tr>
  </tbody>
</table>

<h5 id="全域关系">全域关系</h5>

<table>
  <tbody>
    <tr>
      <td>$U_x={&lt;x,y&gt;</td>
      <td>x\in X\wedge y\in X}$</td>
    </tr>
  </tbody>
</table>

<p>$\varnothing\subseteq I_x\subseteq U_x$</p>

<h4 id="关系的集合运算">关系的集合运算</h4>

<p>设关系$R$和$S$是从$X$到$Y$的两个关系，则运算为$R\cap S,R\cup S,R-S,R$^$S,$~$R$</p>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$R\cap S={(x,y)</td>
          <td>(x,y)\in R\wedge&lt;x,y&gt;\in S}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$R\cup S={(x,y)</td>
          <td>(x,y)\in R\vee&lt;x,y&gt;\in S}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$R-S={(x,y)</td>
          <td>(x,y)\in R\wedge&lt;x,y&gt;\not\in S}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$R$^$S={(x,y)</td>
          <td>(x,y)\in R\oplus&lt;x,y&gt;\in S}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>~$R={(x,y)</td>
          <td>(x,y)\not\in R}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>python运算符
    <ul>
      <li>&amp; 交
* | 并</li>
      <li>$-$ 差</li>
      <li>^ 对称差</li>
    </ul>
  </li>
</ul>

<h4 id="复合运算">复合运算</h4>

<p>关系$R\subseteq X×Y$和关系$S\subseteq Y×Z$的复合</p>

<table>
  <tbody>
    <tr>
      <td>$R\circ S={&lt;x,z&gt;</td>
      <td>\exists y(&lt;x,y&gt;\in R\wedge&lt;y,z&gt;\in S$$)}$</td>
    </tr>
  </tbody>
</table>

<h4 id="逆运算">逆运算</h4>

<p>定义$R\subseteq X×Y$的逆关系</p>

<table>
  <tbody>
    <tr>
      <td>$R^-$$^1={&lt;y,x&gt;</td>
      <td>&lt;x,y&gt;\in R}$</td>
    </tr>
  </tbody>
</table>

<p>将R中每个有序偶的第一元与第二元对调就得到$R$的逆关系$R^-$$^1$</p>

<h4 id="幂运算">幂运算</h4>

<p>设$R$是$X$上关系，$n$是自然数，$R^n$定义如下:</p>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$R^0=I_x\qquad\qquad\</td>
          <td>X</td>
          <td>=m$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>$R^n$$^+$$^1=R^n\circ R\qquad R^m$$^+$$^1=?$</li>
</ul>

<h4 id="关系运算性质">关系运算性质</h4>

<p>若R和S都是从X到Y的关系，则$R\cap S,R\cup S,R-S,R+S,$~$R$仍然是从X到Y的关系</p>

<ul>
  <li>$R\subseteq X×Y,\ S\subseteq X×Y\vDash R\cap\ S\subset X×Y$</li>
  <li>$R\subseteq X×Y,\ S\subseteq X×Y\vDash R\cup\ S\subset X×Y$</li>
  <li>$R\subseteq X×Y,\ S\subseteq X×Y\vDash R-S \subset X×Y$</li>
  <li>$R\subseteq X×Y,\ S\subseteq X×Y\vDash R+S \subset X×Y$</li>
  <li>$R\subseteq X×Y\vDash$~$R\subseteq X×Y$</li>
</ul>

<h4 id="复合性质">复合性质</h4>

<p>若$R$是从$X$到$Y$的关系，$S$是从$Y$到$Z$的关系，则$R\circ S\subseteq X×Z$</p>

<p>即$R\subseteq X×Y,\ S\subseteq Y×Z \vDash R\circ S\subseteq X×Z$</p>

<ul>
  <li>$(R_1\circ R_2$$)\circ R_3=R_1\circ(R_2\circ R_3$)</li>
  <li>$R\circ I_A=I_A\circ R=R$</li>
  <li>$(R_1\cap R_2$$)\circ R_3\subseteq R_1\circ R_3\cap R_2\circ R_3$</li>
  <li>$R_1\circ($$R_2\cap R_3)\subseteq R_1\circ R_2\cap R_1\circ R_3$</li>
  <li>$(R_1\cup R_2$$)\circ R_3\subseteq R_1\circ R_3\cup R_2\circ R_3$</li>
  <li>$R_1\circ($$R_2\cup R_3)\subseteq R_1\circ R_2\cup R_1\circ R_3$</li>
  <li>
    <font color="red">注意：一般不满足交换律</font>
  </li>
</ul>

<h4 id="逆运算性质">逆运算性质</h4>

<ul>
  <li>($R_1\cup R_2$)$^-$$^1$$=R_1$$^-$$^1$$\cup\ R_2$$^-$$^1$</li>
  <li>($R_1\cap R_2$)$^-$$^1$$=R_1$$^-$$^1$$\cap\ R_2$$^-$$^1$</li>
  <li>($R_1-R_2$)$^-$$^1$$=R_1$$^-$$^1$$-R_2$$^-$$^1$</li>
  <li>(~$\ R_1$)$^-$$^1$$=$$\ $~$\ R_1$$^-$$^1$</li>
  <li>
    <font color="red">($R_1\circ R_2$)$^-\$\$^1\$\$=R_2$$^-\$\$^1\$\$\circ\\ R_1\$\$^-\$\$^1$</font>
  </li>
</ul>

<h4 id="幂运算性质">幂运算性质</h4>

<ul>
  <li>$R^mR^n=R^m$$^+$$^n$</li>
  <li>($R^m$)$^n=R^m$$^n$</li>
</ul>

<h4 id="关系特性">关系特性</h4>

<ul>
  <li>集合X上的有一些重要的关系R
    <ul>
      <li>自反的($reflexive$)
        <ul>
          <li>矩阵的主对角线均为1，关系图中每个节点都有自环</li>
        </ul>
      </li>
      <li>反自反的($irreflexive$)
        <ul>
          <li>矩阵的主对角线均为0，关系图中每个节点都没有自环</li>
        </ul>
      </li>
      <li>对称的($symmetric$)
        <ul>
          <li>矩阵的所有元素关于主对角线对称，关系图中任意两个节点间或者没有边或者是双向边</li>
        </ul>
      </li>
      <li>反对称的($antisymmetric$)
        <ul>
          <li>矩阵关于主对角线对称位置至多有一个为1，关系图中任意两个节点间或者没有边或者单边。</li>
        </ul>
      </li>
      <li>传递的($transitive$)
        <ul>
          <li>任意两个节点间有路径，节点间一定有边。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>构建特性关系
    <ul>
      <li>自反关系</li>
      <li>对称关系</li>
      <li>传递关系</li>
    </ul>
  </li>
</ul>

<h4 id="自反">自反</h4>

<ul>
  <li>定义设R是集合X上的关系</li>
  <li>若对于每个x$\in X$都有$&lt;x,x&gt;\in R$, 则称R为自然的，即</li>
  <li>$\forall x(x\in X\rightarrow&lt;x,x&gt;\in R$)</li>
</ul>

<h4 id="反自反">反自反</h4>

<ul>
  <li>定义设R是集合X上的关系</li>
  <li>若对于每个$x\in X$都有$&lt;x,x&gt;\not\in R$, 则称R为反自反的，即</li>
  <li>$\forall x($$x\in X\rightarrow&lt;x,x&gt;\not\in R)$</li>
  <li>$\forall x($$x\in X\rightarrow\neg&lt;x,x&gt;\in R)$</li>
</ul>

<h4 id="对称">对称</h4>

<ul>
  <li>定义设$R$是集合$X$上的关系</li>
  <li>若对于$x,y\in X$, 以及($x,y$)$\in R$, 就称R是对称的, 即</li>
  <li>$\forall x\forall y(x\in X\wedge y\in X\wedge(x,y$)$\in\rightarrow(y,x$)$\in R)$</li>
</ul>

<h4 id="反对称">反对称</h4>

<ul>
  <li>定义设R是集合X上的关系</li>
  <li>若对于每个$x,y\in X$, 以及$(x,y)\in R$, 且$(y,x)\in R$, 则有$x=y$, 就称$R$是反对称的，即</li>
  <li>$\forall x\forall y(x\in X\wedge y\in X\wedge (x,y$$)\in R\wedge(y,x$$)\in R\rightarrow x=y$</li>
</ul>

<h4 id="传递">传递</h4>

<ul>
  <li>定义设$R是集合X$上的关系</li>
  <li>若对于每个$x,y,x\in X$, 以及$(x,y)\in R$且$&lt;y,z&gt;\in R$, 则有$&lt;x,z&gt;\in R$, 就称$R$是传递的，即</li>
  <li>$\forall x\forall y\forall z(x\in X\wedge y\in X\wedge z\in X\wedge(x,y)\in R\wedge&lt;y,z&gt;\in R\rightarrow&lt;x,z&gt;\in R)$</li>
</ul>

<h4 id="构造特征关系">构造特征关系</h4>

<ul>
  <li>自反
    <ul>
      <li>设 R是集合 X 上的关系，则 R’ 是自反的，其中 $R’=R\cup I_x$</li>
    </ul>
  </li>
  <li>反自反
    <ul>
      <li>设 R是集合 X 上的关系，则 R’ 是反自反的，其中 $R’=R-I_x$</li>
    </ul>
  </li>
  <li>对称
    <ul>
      <li>设 R是集合 X 上的关系，则 R’ 是对称的，其中 $R’=R\cup R^-$$^1$</li>
    </ul>
  </li>
  <li>反对称
    <ul>
      <li>设 R是集合 X 上的关系，则 R’是反对称的，其中 $R’=(R-(R\cap R^-$$^1))\cup R\cap I_x$</li>
    </ul>
  </li>
  <li>传递
* 设 R是集合 X 上的关系，|X|=m，则 R’是传递的，其中，$R’=\cup_n$$_=$$_1$$_,$$_m$$R^n$</li>
</ul>

<h4 id="关系特性的性质">关系特性的性质</h4>

<h5 id="定理-5">定理：</h5>

<p>设R是集合X上的关系</p>

<ul>
  <li>$R是自反的当且仅当R=I_x\cup R$</li>
  <li>$R的反自反的当且仅当I_x\cap R=\varnothing$</li>
  <li>$R是对称的当且仅当R^-$$^1=R$</li>
  <li>$R是反对称的当且仅当R\cap R^-$$^1\subseteq I_x$</li>
  <li>$R是传递的当且仅当R\circ R\subseteq R$</li>
</ul>

<h5 id="关系特性与集合运算的性质探究">关系特性与集合运算的性质探究</h5>

<p>设$R_1, R_2\subseteq X×X$, 若$R_1, R_2$是自反的, 则$R_1\cup R_2$是自反的</p>

<table>
  <thead>
    <tr>
      <th>\</th>
      <th>$R_1\cup R_2$</th>
      <th>$R_1\cap R_2$</th>
      <th>$R_1-$$R_2$</th>
      <th>~$R_1$</th>
      <th>$R_1\circ R_2$</th>
      <th>$R_1^-$$^1$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>自反性</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>-</td>
      <td>-</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
    </tr>
    <tr>
      <td>反自反性</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>-</td>
      <td>-</td>
      <td>$\surd$</td>
    </tr>
    <tr>
      <td>对称性</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>-</td>
      <td>$\surd$</td>
    </tr>
    <tr>
      <td>反对称性</td>
      <td>-</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>-</td>
      <td>-</td>
      <td>$\surd$</td>
    </tr>
    <tr>
      <td>传递性</td>
      <td>-</td>
      <td>$\surd$</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
      <td>$\surd$</td>
    </tr>
  </tbody>
</table>

<h2 id="代数系统-1">代数系统</h2>

<h3 id="代数运算">代数运算</h3>

<h4 id="概念">概念</h4>

<p>设 $X$ 是一个集合，$\psi$ 是 $X\times X\rightarrow X$ 的映射，则称 $\psi$ 是 $X$ 的一个 <strong>代数运算</strong></p>

<p>在集合 $X$ 中，任意两个有次序的元素 $a$ 与 $b$，依据一个法则，都有<strong>唯一确定</strong>的元素 $d$ 与它们对应，则称这个法则是集合 $X$ 的一个代数运算，称集合 $X$ 关于运算 $\psi$ 是<strong>封闭的</strong>。可记为 $a\circ b=d$</p>

<p><strong>特点</strong></p>

<ul>
  <li>唯一性</li>
  <li>封闭性</li>
</ul>

<h4 id="代数运算实例">代数运算实例</h4>

<p>$\N,\ \Z,\ \Q,\ \R$ 分别为自然数、整数、有理数、实数集</p>

<p>$M_n(\R)$ 为 $n$ 阶实矩阵（实数矩阵）集合，$n\ge 2$</p>

<p>$P(B)$ 为幂集</p>

<table>
  <tbody>
    <tr>
      <td>$X^X$ 为从 $X$ 到 $X$ 的函数集, $</td>
      <td>X</td>
      <td>\ge 2$</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>集合</th>
      <th>运算</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$\N,\ \Z,\ \Q,\ \R$</td>
      <td>$+,\ \times$</td>
    </tr>
    <tr>
      <td>$M_n(\R)$</td>
      <td>$+$(矩阵加法)$,\ \times$(矩阵乘法)</td>
    </tr>
    <tr>
      <td>$P(B)$</td>
      <td>$\cup,\ \cap$</td>
    </tr>
    <tr>
      <td>${0,1}$</td>
      <td>$\and,\ \or$</td>
    </tr>
    <tr>
      <td>$X^X$</td>
      <td>$\circ$(函数复合)</td>
    </tr>
  </tbody>
</table>

<p>$N_n$ 是有穷自然数集合</p>

<ul>
  <li>$&lt;N_n, \oplus&gt;$
    <ul>
      <li>$N_n = {0, 1,…,n-1}$</li>
      <li>$x\oplus y = (x+y) \mod{n}$</li>
    </ul>
  </li>
  <li>$&lt;N_n,\otimes&gt;$
    <ul>
      <li>$N_n = {1, …,n}$</li>
      <li>$x\otimes y = (x\times y)\mod{n}$</li>
    </ul>
  </li>
</ul>

<h4 id="运算表">运算表</h4>

<p>表示有穷集上的一元运算和二元运算</p>

<table>
  <thead>
    <tr>
      <th>$\circ$</th>
      <th>$a_1$</th>
      <th>$a_2$</th>
      <th>…</th>
      <th>$a_n$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$a_1$</td>
      <td>$a_1\circ a_1$</td>
      <td>$a_1\circ a_2$</td>
      <td>…</td>
      <td>$a_1\circ a_n$</td>
    </tr>
    <tr>
      <td>$a_2$</td>
      <td>$a_2\circ a_1$</td>
      <td>$a_2\circ a_2$</td>
      <td>…</td>
      <td>$a_2\circ a_n$</td>
    </tr>
    <tr>
      <td>…</td>
      <td> </td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>$a_n$</td>
      <td>$a_n\circ a_1$</td>
      <td>$a_n\circ a_2$</td>
      <td>…</td>
      <td>$a_n\circ a_n$</td>
    </tr>
  </tbody>
</table>

<h3 id="结合律交换律分配律">结合律、交换律、分配律</h3>

<h4 id="结合律">结合律</h4>

<p>设 $X$ 是集合，$X$ 上有代数运算 $\circ$，如果对 $X$ 中任意元素 $x,y,z$ 都有 $x\circ(y\circ z)=(x\circ y)\circ z$</p>

<h4 id="交换律">交换律</h4>

<p>$x\circ y=y\circ x$</p>

<h4 id="分配律">分配律</h4>

<p>$x\circ (y\oplus z) = (x\circ y)\oplus (x\circ z)$</p>

<h3 id="幂等律吸收律">幂等律、吸收律</h3>

<h4 id="幂等律">==幂等律==</h4>

<p>设X是集合，$X$上有代数运算$\circ$，$e$是$X$上的单位元，如果对$X$中任意元素$x$都有 $x\circ x = e$，则称运算在$X$上满足<strong>幂等律</strong></p>

<h4 id="吸收律">==吸收律==</h4>

<p>设$X$是集合，$X$上有代数运算$\circ$，如果对$X$中任意元素$x$都有 $x\circ x=x$，则称运算在$X$上满足<strong>吸收律</strong></p>

<table>
  <thead>
    <tr>
      <th>集合</th>
      <th>运算</th>
      <th>交换律</th>
      <th>结合律</th>
      <th>幂等律</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$\N, \Z,\Q,\R$</td>
      <td>$+$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>$\times$</td>
    </tr>
    <tr>
      <td> </td>
      <td>$\times$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>$\times$</td>
    </tr>
    <tr>
      <td>$M_n(R)$</td>
      <td>$+$(矩阵加法)</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>$\times$</td>
    </tr>
    <tr>
      <td> </td>
      <td>$\times$(矩阵乘法)</td>
      <td>$\times$</td>
      <td>$\surd$</td>
      <td>$\times$</td>
    </tr>
    <tr>
      <td>$P(S)$</td>
      <td>$\cup$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
    </tr>
    <tr>
      <td> </td>
      <td>$\cap$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
    </tr>
    <tr>
      <td>${0,1}$</td>
      <td>$\and$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
    </tr>
    <tr>
      <td> </td>
      <td>$\or$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
      <td>$\surd$</td>
    </tr>
    <tr>
      <td>$X^X$</td>
      <td>$\circ$ （函数复合）</td>
      <td>$\times$</td>
      <td>$\surd$</td>
      <td>$\times$</td>
    </tr>
  </tbody>
</table>

<h3 id="克莱恩-klein-四元集合及运算">克莱恩 (Klein) 四元集合及运算</h3>

<table>
  <thead>
    <tr>
      <th>$\circ$</th>
      <th>e</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>e</td>
      <td>e</td>
      <td>a</td>
      <td>b</td>
      <td>c</td>
    </tr>
    <tr>
      <td>a</td>
      <td>a</td>
      <td>e</td>
      <td>c</td>
      <td>b</td>
    </tr>
    <tr>
      <td>b</td>
      <td>b</td>
      <td>c</td>
      <td>e</td>
      <td>a</td>
    </tr>
    <tr>
      <td>c</td>
      <td>c</td>
      <td>b</td>
      <td>a</td>
      <td>e</td>
    </tr>
  </tbody>
</table>

<h3 id="特殊元">特殊元</h3>

<h4 id="单位元">单位元</h4>

<p>设$\circ$为$X$上的二元运算,如果存在$e\in X$，使得对任意 $x\in X$ 都有 $e\circ x = x$，则称 $e$ 是 $X$ 中关于$\circ$运算的左单位元。（同理定义右单位元）</p>

<blockquote>
  <p>$e$ 既为左单位元又为右单位元 $\Rightarrow$ $e$ 为 $X$ 上关于 $\circ$ 运算的单位元</p>
</blockquote>

<h4 id="零元">零元</h4>

<p>设$\circ$为$X$上的二元运算,如果存在$0\in X$，使得对任意 $x\in X$ 都有 $0\circ x = 0$，则称 $0$ 是 $X$ 中关于$\circ$运算的左零元。（同理定义右零元）</p>

<blockquote>
  <p>$0$ 既为左零元又为右零元 $\Rightarrow$ $0$ 为 $X$ 上关于 $\circ$ 运算的单位元</p>
</blockquote>

<h4 id="逆元">逆元</h4>

<p>关于 $\circ$ 运算，若 $y\in X$ 既是 $x$ 的左逆元又是 $x$ 的右逆元则称 $y$ 为 $x$ 的逆元，表示为 $x^{-1}$ 。</p>

<blockquote>
  <p>如果 $x$ 的逆元存在，就称 $x$ 是可逆的。</p>
</blockquote>

<h4 id="幂等元">幂等元</h4>

<p>设 $\circ$ 为X上的二元运算,若 $x\in X$ 且 $x \circ x=x$，则称 $x$ 是 $X$ 中关于运算 $\circ$ 的幂等元。</p>

<p><strong>特殊元实例</strong></p>

<table>
  <thead>
    <tr>
      <th>集合</th>
      <th>运算</th>
      <th>单位元</th>
      <th>零元</th>
      <th>逆元</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$\N,\ \Z,\ \Q,\ \R$</td>
      <td>$+$</td>
      <td>$0$</td>
      <td>$\times$</td>
      <td>$-x$</td>
    </tr>
    <tr>
      <td> </td>
      <td>$\times$</td>
      <td>$1$</td>
      <td>$0$</td>
      <td>$x^{-1}$</td>
    </tr>
    <tr>
      <td>$M_n(\R)$</td>
      <td>$+$ (矩阵加法)</td>
      <td>$0$ 矩阵</td>
      <td>$\times$</td>
      <td>$-X$</td>
    </tr>
    <tr>
      <td> </td>
      <td>$\times$ (矩阵乘法)</td>
      <td>单位矩阵</td>
      <td>$0$ 矩阵</td>
      <td>$X^{-1}$</td>
    </tr>
    <tr>
      <td>$P(S)$</td>
      <td>$\cup$</td>
      <td>$\empty$</td>
      <td>$S$</td>
      <td>$\empty$ 的逆元为 $\empty$</td>
    </tr>
    <tr>
      <td> </td>
      <td>$\cap$</td>
      <td>$S$</td>
      <td>$\empty$</td>
      <td>$S$ 的逆元为 $S$</td>
    </tr>
  </tbody>
</table>

<h2 id="代数系统-2">代数系统</h2>

<p>设 $X$ 是非空集合，$X$上有 $m$ 个代数运算 $\psi_1, \psi_2, …, \psi_m$，集合 $X$ 及其代数运算组成的系统称为一个代数系统，简称代数，记为 $&lt;X, {\psi_1,\psi_2,…,\psi_m}&gt;$，其中，$m&gt;0$。</p>

<p>在代数中，对象是抽象的而不是具体的，对象上的运算也是抽象的，其含义由一组给定公理规定。</p>

<h3 id="公理">公理</h3>

<p>代数运算所具有的性质作为公理，并用方程的形式表示出来。如：结合律、交换律</p>

<h3 id="代数常量">代数常量</h3>

<p>特殊元素：如单位元、零元等等</p>

<h3 id="代数系统实例">代数系统实例</h3>

<p>&lt;对象集合、运算集合、常量集合&gt;</p>

<p>&lt;$\N$，+，*，0，1&gt;</p>

<p>$\forall a,b,c\in \N$</p>

<ul>
  <li>(a+b)+c = a+(b+c), (a*b)*c = a*(b*c)</li>
  <li>a+b =b +a , a*b=b*a</li>
  <li>a+0 =0+a =a, a+(-a)=0, a*1 =1*a =a</li>
  <li>(a+b)*c = a*c+b*c</li>
</ul>

<h3 id="同态">同态</h3>

<h4 id="定义-6">定义</h4>

<p>设集合 $X$ 与 $Y$ 各有代数运算 $\circ$ 及 $\bullet$ ，且 $\psi$ 是 $X$ 到 $Y$ 的一个映射，如果 $\psi$ 满足以下条件：在 $\psi$ 之下：$\psi(a\circ b)=\psi(a)\bullet\psi(b)$，称 $\psi$ 为代数系统 $&lt;X,\circ&gt;$ 与 $&lt;Y,\bullet&gt;$ <strong>同态</strong>。记为 $&lt;X,\circ&gt;\sim&lt;Y,\bullet&gt;$</p>

<p>若 $\psi$ 是满射，则 $\psi$ 称为代数系统 $&lt;X,\circ&gt;$ 到 $&lt;Y,\bullet&gt;$ 的同态满射。简称 $&lt;X,\circ&gt;$ 与 $&lt;Y,\bullet&gt;$ <strong>满同态</strong></p>

<h4 id="性质">性质</h4>

<ul>
  <li>若代数系统 $&lt;X,\circ&gt;$ 与 $&lt;Y,\bullet&gt;$ 满同态，则对代数运算 $\circ$ 及 $\bullet$
    <ul>
      <li>若 $\circ$ 满足结合律，则 $\bullet$ 也满足结合律</li>
      <li>若 $\circ$ 满足交换律，则 $\bullet$ 也满足交换律</li>
    </ul>
  </li>
  <li>若代数系统 $&lt;X, {\circ,\oplus }&gt;$，$&lt;Y, {\bullet,\otimes }&gt;$ 满同态，若代数运算 $\circ, \oplus$ 满足分配律，则 $\bullet,\otimes$ 也满足分配律</li>
</ul>

<h3 id="同构">同构</h3>

<h4 id="定义-7">定义</h4>

<p>设集合 $X$ 与 $Y$ 各有代数运算 $\circ$ 及 $\bullet$，且 $\psi$ 是 $X$ 到 $Y$ 的一个一一映射，如果 $\psi$ 满足以下条件：$\psi(a\circ b)=\psi(a)\bullet\psi(b)$，称 $\psi$ 为代数系统 $&lt;X, \circ&gt;$ 到 $&lt;Y,\bullet&gt;$ 的一个 <strong>同构映射</strong>，简称 $&lt;X, \circ&gt;$ 与 $&lt;Y,\bullet&gt;$ <strong>同构</strong>。记为  $&lt;X, \circ&gt;\cong&lt;Y,\bullet&gt;$</p>

<h4 id="性质-1">性质</h4>

<ul>
  <li>保持运算的所有性质</li>
  <li>从抽象角度，两个代数系统完全相同</li>
</ul>

<h3 id="子代数">子代数</h3>

<h4 id="定义-8">定义</h4>

<p>设 $A=&lt;X,\bullet&gt;$ 是一个代数系统，若 $Y\not=\empty$ , $Y\in X$，并且对于代数 $A$ 的运算 $\bullet$ 封闭，则称代数系统 $A_s=&lt;Y,\bullet&gt;$ 是代数系统 $A$ 的子代数</p>

<h4 id="性质-2">性质</h4>

<p>子代数保留原来代数系统中相关运算性质</p>

<h3 id="商代数">商代数</h3>

<h4 id="定义-9">定义</h4>

<table>
  <tbody>
    <tr>
      <td>设 $R$ 是 $X$ 上的等价关系，$A=&lt;X,\bullet&gt;$ 是一代数系统，则 $A_q=&lt;X/\R,\circ&gt;$ 是一代数系统，称为 $A$ 的<strong>商代数</strong>。其中，$X/R={[x]_\R</td>
      <td>x\in X}$ ，$\circ$ 定义为对任意的 $[x]<em>\R,\ [y]</em>\R\in X/\R,\ [x]<em>\R\circ[y]</em>\R=[x\bullet y]_\R$</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>等价关系定义为：设R是非空集合A上的二元关系，若R是自反的、对称的、传递的，则称R是A上的等价关系。</p>
</blockquote>

<h4 id="性质-3">性质</h4>

<ul>
  <li>一个代数系统 $&lt;X, \bullet&gt;$ 与其商代数 $&lt;Y, \circ&gt;$ 满同态。</li>
  <li>商代数保留原代数系统的运算性质</li>
</ul>

<h3 id="积代数">积代数</h3>

<h4 id="定义-10">定义</h4>

<p>代数系统 $&lt;X, \bullet&gt;$ , $&lt;X, \circ&gt;$ 的积代数定义为 $&lt;X\times Y,\otimes&gt;$ ，其中 $\times$ 为笛卡尔积，运算 $\otimes$ 定义为：</p>

<p>对任意 $(x_1, y_1)$, $(x_2, y_2)\in X\times Y,\ (x_1,y_1)\otimes(x_2,y_2)=((x_1\bullet x_2),\ (y_1\circ y_2))$</p>

<h4 id="性质-4">性质</h4>

<p>积代数保持两个代数运算共有的运算性质</p>

<h2 id="半群">半群</h2>

<h3 id="半群-1">半群</h3>

<h4 id="定义-11">定义</h4>

<p>对代数系统 $&lt;S,\circ&gt;$ ，若对任意 $a,b,c\in S$，有 $(a\circ b)\circ c=a\circ(b\circ c)$，则称 $&lt;S,\circ&gt;$ 为<strong>半群</strong></p>

<h4 id="性质-5">性质</h4>

<ul>
  <li>$&lt;S, \circ&gt;$ 为半群，若 $S$ 有限，则必有 $a\in S$ 使得 $a\circ a=a$</li>
  <li><strong>半群导出定理</strong>：设 $&lt;S,*&gt;$ 是半群，$&lt;T,\odot&gt;$ 是一个代数系统，若有一同态满射 $\psi:S\rightarrow T$，则 $&lt;T,\odot&gt;$ 也是半群</li>
  <li>设 $&lt;S,<em>&gt;$ , $&lt;T,\odot&gt;$ 是半群满同态，若 $&lt;S,</em>&gt;$ 是幺半群，则 $&lt;T,\odot&gt;$ 也是幺半群，满同态映射作用于 $S$ 的单位元的象是 $T$ 的单位元</li>
  <li>设 $\psi$ 是半群 $(S,\circ)$ 到 $(T,\odot)$ 的同态，$\mu$ 是半群 $(T,\odot)$ 到 $(U,*)$ 的同态，则 $\mu$ 到 $\psi$ 的复合映射 $\mu\cdot\psi$ 是一个 $(S,\circ)$ 到 $(T,\odot)$ 的同态</li>
</ul>

<h3 id="交换半群">交换半群</h3>

<p>对代数系统 $&lt;S,\circ&gt;$ ，若对任意 $a,b,c\in S$，有 $(a\circ b)\circ = a\circ (b\circ c)$ 且 $a\circ b=b\circ a$ ，则称 $&lt;S,\circ&gt;$ 为<strong>交换半群</strong></p>

<h3 id="独异点--幺半群">独异点 | 幺半群</h3>

<h4 id="定义-12">定义</h4>

<p>若 $&lt;S, \circ&gt;$ 为半群，并且存在一个单位元 $e\in S$，对任意 $a\in S$ ，有 $a\circ e=e\circ a$ ，则 $&lt;S,\circ,e&gt;$ 为 <strong>独异点</strong> 或称 <strong>幺半群</strong></p>

<h4 id="定理-6">定理</h4>

<ul>
  <li>$&lt;S,\circ, e&gt;$ 为独异点或幺半群，则关于 $\circ$ 运算的运算表中，任何两行或两列都不相同</li>
  <li>$&lt;S,\circ, e&gt;$ 为独异点或幺半群，若对任意 $a,b\in S$ ，都有逆元，则
    <ul>
      <li>$(a^{-1})^{-1}=a$</li>
      <li>$a\circ b$ 有逆元且 $(a\circ b)^{-1}=b^{-1}\circ a^{-1}$</li>
    </ul>
  </li>
</ul>

<h3 id="循环独异点--循环幺半群">循环独异点 | 循环幺半群</h3>

<h4 id="定义-13">定义</h4>

<p>一个独异点 $&lt;S,\circ, e&gt;$ 称为 <strong>循环独异点</strong> 或 <strong>循环幺半群</strong>，若存在一个元素 $a\in S$ ，使得 $S$ 中每个元素 $b$ 都可以表示为：$a=a\circ a\circ a…\circ a=a^n,\ a^0=e$</p>

<p>也称 $&lt;S,\circ&gt;$ 是由元素 $a$ 生成的，$a$ 称为 $&lt;S,\circ, e&gt;$ 的生成元</p>

<h4 id="性质-6">性质</h4>

<p>对循环独异点 $&lt;S,\circ,e&gt;,\ &lt;S,\circ&gt;$ 为交换半群</p>

<h3 id="子半群">子半群</h3>

<h4 id="定义-14">定义</h4>

<p>设 $&lt;S,\circ&gt;$ 为一个半群，若</p>

<ul>
  <li>$S^{‘}\subseteq S$</li>
  <li>$&lt;S^{‘},\circ&gt;$ 是半群</li>
</ul>

<p>则称 $&lt;S^{‘},\circ&gt;$ 是 $&lt;S,\circ$ 的 <strong>子半群</strong></p>

<h4 id="定理-7">定理</h4>

<p>$&lt;S,\circ&gt;$ 是一个半群，若 $S^{‘}\subseteq S$，且 $S^{‘}$ 关于 $\circ$ 运算封闭，则 $&lt;S^{‘},\circ&gt;$ 是 $&lt;S,\circ&gt;$ 的子半群</p>

<h3 id="半群同态和同构">半群同态和同构</h3>

<h4 id="定义-15">定义</h4>

<p>设 $&lt;S,<em>&gt;$, $&lt;T,\odot&gt;$ 是半群，若存在一个映射 $\Psi:S\rightarrow T$，对任意 $a,b\in S$，都有 $\Psi(a</em>b)=\Psi(a)\odot\Psi(b)$，则称 $\Psi$ 为 <strong>半群同态</strong></p>

<p>若 $\Psi$ 是满射，则称 $\Psi$ 是 <strong>半群满同态</strong></p>

<p>若 $\Psi$ 是一一映射，则称 $\Psi$ 是 <strong>半群同构</strong></p>

<p>若 $S$, $T$ 相同，则称 $\Psi$ 为 <strong>自同态/自同构</strong></p>

<h3 id="商半群">商半群</h3>

<h4 id="定义-16">定义</h4>

<p>对半群 $&lt;S,<em>&gt;$，若 $R$ 是 $S$ 上的等价关系，则称 $&lt;S/R,\oplus&gt;$  为 $&lt;S,</em>&gt;$ 的商半群，运算 $\oplus$ 为 $*/R$</p>

<h4 id="定理-8">定理</h4>

<p>半群和它的商半群满同态</p>

<h3 id="半群直积">半群直积</h3>

<h4 id="定义-17">定义</h4>

<p>设 $&lt;S,<em>&gt;$ , $&lt;T,\odot&gt;$ 是两个半群，其上的代数系统直积 $&lt;S\times T,\otimes&gt;$，其中 $\times$ 为 $S, T$ 的笛卡尔积，$\otimes$ 定义为对任意 $A_1,a_2\in S$, $b_1,b_2\in T$, $(a_1, b_1)\otimes (a_2,b_2)=((a_1</em>a_2),(b_1\odot b_2))$ 称为半群直积</p>

<h4 id="定理-9">定理</h4>

<ul>
  <li>半群直积也称为半群</li>
  <li>交换半群的直积也是交换半群</li>
  <li>幺半群的直积也是幺半群，并且其独异点（单位元） 是两个半群单位元的笛卡尔积</li>
  <li>有零元的半群直积的零元是两个半群零元的笛卡尔积</li>
  <li>有逆元的半群直积的逆元是两个半群逆元的笛卡尔积</li>
</ul>

<h2 id="群">群</h2>

<h3 id="群-1">群</h3>

<h4 id="定义-18">定义</h4>

<p>设 $G$ 是一个非空集合， $\times$ 是儿园代数运算，如果满足以下条件：</p>

<ul>
  <li>代数运算 $\times$ 满足结合律，即对 $G$ 中的任意元素 $a,b,c$ 都有 $(a\times b)\times c=a\times(b\times c)$</li>
  <li>$G$ 中有 <strong>左</strong> 单位元 $e$，对于 $G$ 中的每个元素 $a$ 都有 $e\times a=a\times e=a$</li>
  <li>对 $G$ 中每个元素 $a$，都有 <strong>左</strong> 逆元 $a^{-1}$，使得 $a^{-1}\times a=a\times a^{-1}=e$</li>
</ul>

<p>则称 $G$ 对代数运算 $\times$ 作成一个 <strong>群</strong></p>

<blockquote>
  <p>群 $\subseteq$ 独异点 $\subseteq$ 半群 $\subseteq$ 代数系统</p>
</blockquote>

<h4 id="公理-1">公理</h4>

<p>群理论可以采用数理逻辑方法表示，它有三条公理</p>

<ul>
  <li>
    <p>满足结合律</p>

    <p>$\forall x\in G,y\in G,z\in G$，有 $\forall x\forall y\forall z ((x\times y)\times z=x\times (y\times z))$</p>
  </li>
  <li>
    <p>有单位元</p>

    <p>$\forall x\in G$，有 $\forall x(e\times x=x\times e = x)$</p>
  </li>
  <li>
    <p>有逆元</p>

    <p>$\forall x\in G$，存在元素 $y\in G$ 使得 $\forall x\exists y(y\times x=x\times y=e)$</p>
  </li>
</ul>

<h4 id="性质-7">性质</h4>

<ul>
  <li>群 $&lt;G,\times&gt;$ 的左单位元也是有单位元，单位元唯一</li>
  <li>群 $&lt;G,\times&gt;$ 中元素的左逆元也是右逆元，逆元唯一</li>
  <li>群 $&lt;G,\times&gt;$ 无零元</li>
  <li><strong>消去律</strong>：群 $&lt;G,\times&gt;$ 的运算 $\times$ 满足
    <ul>
      <li>如果 $a\times x=a\times x^{‘}$，则 $x=x^{‘}$</li>
      <li>如果 $x\times a=x^{‘}\times a$，则 $a=x^{‘}$</li>
    </ul>
  </li>
  <li><strong>唯一解</strong>： 群 $&lt;G,\times&gt;$ ，$\forall a,b\in G$，必存在唯一的一个 $x\in G$，使得 $a\times x=b$，$x\times a=b$</li>
  <li>群 $&lt;G,\times&gt;$ 中只有单位元是幂等元</li>
  <li>群中运算满足消去律
    <ul>
      <li>$a\circ b=a\circ c\rightarrow b=c$</li>
      <li>$a\circ c=b\circ c\rightarrow a=b$</li>
    </ul>
  </li>
  <li>群的每一行每一列都是群元素的双射</li>
  <li>群 $G$，对任意 $a,b\in G$，都有：
    <ul>
      <li>$(a^{-1})^{-1}=a$</li>
      <li>$(ab)^{-1}=b^{-1}a^{-1}$</li>
    </ul>
  </li>
</ul>

<h4 id="元素幂的性质">元素幂的性质</h4>

<p>设 $G$ 为群，对于任意 $a,b\in G，有</p>

<ul>
  <li>$a^ma^n=a^{m+n}$</li>
  <li>$(a^m)^n=a^{mn}$</li>
</ul>

<h4 id="元素的阶">元素的阶</h4>

<table>
  <tbody>
    <tr>
      <td>$</td>
      <td>a</td>
      <td>=k$，使得 $a^k=e$ 成立的最小正整数 $k$</td>
    </tr>
  </tbody>
</table>

<p>有限群元素的阶一定是有限阶，且是群的阶的因子</p>

<h4 id="群的阶">群的阶</h4>

<p>一般情况下，群 $G$ 的阶 = 其因子的个数</p>

<p>当群 $G$ 为循环群时，群 $G$ 的阶为其生成元的阶</p>

<table>
  <tbody>
    <tr>
      <td>设有限群 $G$ 的阶是 $</td>
      <td>G</td>
      <td>$，任意元素 $a\in G$，$a$ 的阶是 $</td>
      <td>a</td>
      <td>$，则 $</td>
      <td>a</td>
      <td>$ 整除 $</td>
      <td>G</td>
      <td>$，即 $</td>
      <td>a</td>
      <td>\</td>
      <td>\</td>
      <td>G</td>
      <td>$</td>
    </tr>
  </tbody>
</table>

<h3 id="特殊群">特殊群</h3>

<h4 id="有限群">有限群</h4>

<table>
  <tbody>
    <tr>
      <td>给定群 $&lt;G,\times&gt;$ ，若 $G$ 是有限集，则称 $&lt;G,\times&gt;$ 是 <strong>有限群</strong>。元素个数称为群的阶，表示为 $</td>
      <td>G</td>
      <td>$</td>
    </tr>
  </tbody>
</table>

<h4 id="无穷群">无穷群</h4>

<p>若集合 $G$ 是无穷的，则称 $&lt;G,\times&gt;$ 为 <strong>无穷群</strong>；阶无穷大</p>

<h4 id="平凡群">平凡群</h4>

<p>只含单位元的群称为 <strong>平凡群</strong></p>

<h4 id="可交换群-abel-群">可交换群 (Abel 群)</h4>

<p>给定群 $&lt;G,\times&gt;$ ，若 $\times$ 满足交换律，则称 $&lt;G,\times&gt;$ 是 <strong>可交换群</strong> 或 <strong>Abel 群</strong></p>

<h4 id="克莱恩-klein-四元集">克莱恩 (Klein) 四元集</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">**$\circ$**</th>
      <th style="text-align: center">e</th>
      <th style="text-align: center">a</th>
      <th style="text-align: center">b</th>
      <th style="text-align: center">c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">**e**</td>
      <td style="text-align: center">e</td>
      <td style="text-align: center">a</td>
      <td style="text-align: center">b</td>
      <td style="text-align: center">c</td>
    </tr>
    <tr>
      <td style="text-align: center">**a**</td>
      <td style="text-align: center">a</td>
      <td style="text-align: center">e</td>
      <td style="text-align: center">c</td>
      <td style="text-align: center">b</td>
    </tr>
    <tr>
      <td style="text-align: center">**b**</td>
      <td style="text-align: center">b</td>
      <td style="text-align: center">c</td>
      <td style="text-align: center">e</td>
      <td style="text-align: center">a</td>
    </tr>
    <tr>
      <td style="text-align: center">**c**</td>
      <td style="text-align: center">c</td>
      <td style="text-align: center">b</td>
      <td style="text-align: center">a</td>
      <td style="text-align: center">e</td>
    </tr>
  </tbody>
</table>

<h4 id="模-n-集">模 N 集</h4>

<p>$&lt;I_N,\oplus&gt;$ 称为模 N 整数加群，其中，$x\oplus y=(x+y)\mod{N}$</p>

<h4 id="交换群-abel-群">交换群 (Abel 群)</h4>

<h5 id="定义-19">定义</h5>

<p>若群 $G$ 的运算满足交换律，则称群 $G$ 为<strong>交换群</strong>，又称<strong>阿贝尔群</strong></p>

<h5 id="定理-10">定理</h5>

<ul>
  <li>群 $G$ 是阿贝尔群 $\Leftrightarrow$ 对任意元素 $a,b\in G$，有 $(ab)^2=a^2b^2$</li>
</ul>

<h4 id="循环群">循环群</h4>

<h5 id="定义-20">定义</h5>

<p>群 $G$，存在一个 $a\in G$，使得群中任意元素可以表示为 $a$ 的幂，则群 $G$ 称为 <strong>循环群</strong>，$a$ 称为 $G$ 的生成元，记为 $G=(a)$</p>

<h5 id="循环群的阶">循环群的阶</h5>

<ul>
  <li>生成元的阶是无限的，则 $G$ 是无限循环群</li>
  <li>生成元的阶是 $n$，则 $G$ 为 $n$ 阶群</li>
</ul>

<h5 id="性质-8">性质</h5>

<ul>
  <li>循环群的生成元不一定是唯一的</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>有限群 $G=(a)$，若 $</td>
          <td>G</td>
          <td>=n$，则 $a^n=e$ 且 $G={a,a^2,…,a^n=e}$，其中 $e$ 是群 $G$ 的单位元</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h5 id="定理-11">定理</h5>

<ul>
  <li>任何一个循环群必是交换群</li>
  <li>群 $G=(a)$
    <ul>
      <li>若 $G$ 是无限循环群，则 $G$ 的生成元是 $a$ 或 $a^{-1}$</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>若 $</td>
              <td>G</td>
              <td>=n$，则 $G$ 有 $\phi(n)$ 个生成元，$\phi(n)$ 为 <strong>欧拉函数</strong></td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>在群 $G$ 中，$</td>
          <td>a</td>
          <td>=n$，则 $</td>
          <td>a^k</td>
          <td>=\frac{n}{(n,k)}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>任何一个循环群的子群也是循环群</li>
  <li>无限循环群 $G$ 的子群除 ${e}$ 之外也是无限的</li>
  <li>有限循环群 $G$，其子群的阶是群 $G$ 的因子，且 $G$ 有且仅有一个子群，其阶为该因子</li>
</ul>

<h4 id="变换群">变换群</h4>

<h5 id="定义-21">定义</h5>

<table>
  <tbody>
    <tr>
      <td>$A$ 为非空集合，$F(A)={f</td>
      <td>f:A\rightarrow A 上的双射}$，关于函数复合构成的群称为 <strong>变换群</strong></td>
    </tr>
  </tbody>
</table>

<h5 id="性质-9">性质</h5>

<p>任何群 $G$ 都和一个变换群 $S$ 同构</p>

<h4 id="置换群">置换群</h4>

<h5 id="定义-22">定义</h5>

<p>有限群的变换群称为 <strong>置换群</strong></p>

<h5 id="定理-12">定理</h5>

<p>每一个有限群都和一个置换群同构</p>

<h3 id="置换与变换">置换与变换</h3>

<h4 id="置换">置换</h4>

<h5 id="定义-23">定义</h5>

<p>置换 $\sigma$ 把 $a_1$ 变成 $\sigma(a_1)$，把 $a_2$ 变成 $\sigma(a_2)$，…，是一个一对一映射</p>

<h5 id="表示方式">表示方式</h5>

<p>$\begin{pmatrix}1 &amp; 2&amp;…&amp;n\ \sigma(1)&amp;\sigma(2)&amp;…&amp;\sigma(n)\end{pmatrix}$</p>

<h4 id="轮换">轮换</h4>

<p>置换 $\begin{pmatrix}i_1 &amp; i_2&amp;…&amp;i_{k-1}&amp;i_k&amp;i_{k+1}&amp;…&amp;i_n\ i_2&amp;i_3&amp;…&amp;i_k&amp;i_1&amp;i_{k+1}&amp;…&amp;i_n\end{pmatrix}$ 称为 <strong>k-轮换</strong></p>

<h4 id="恒等变换">恒等变换</h4>

<p>k = 1 的 k-轮换称为 <strong>恒等变换</strong></p>

<h4 id="对换">对换</h4>

<p>k = 2 的 k-轮换称为 <strong>对换</strong></p>

<h4 id="定理-13">定理</h4>

<ul>
  <li>有限置换可表示为不相交的轮换积</li>
  <li>不相交轮换可以表示为对换积</li>
</ul>

<h3 id="陪集">陪集</h3>

<h4 id="定义-24">定义</h4>

<table>
  <tbody>
    <tr>
      <td>设 $H$ 是群 $G$ 的子群，$a\in G$，有 $aH={ax</td>
      <td>x\in G},\ Ha={xa</td>
      <td>x\in G}$ 则 $aH,Ha$ 分别称为群 $G$ 关于子群 $H$ 的一个左陪集，右陪集</td>
    </tr>
  </tbody>
</table>

<h4 id="性质-10">性质</h4>

<ul>
  <li>$a\in aH$</li>
  <li>$a\in H\Leftrightarrow aH=H$</li>
  <li>$b\in aH\Leftrightarrow aH=bH$</li>
  <li>$aH=bH\Leftrightarrow a^{-1}b\in H$ 或 $b^{-1}a\in H$</li>
  <li>$b\in aH\Leftrightarrow aH=bH\Leftrightarrow a^{-1}b\in H$ 或 $b^{-1}a\in H$</li>
  <li>若 $aH\cap bH\not=\empty$，则 $aH=bH$</li>
  <li>群 $G$ 上全体不同的左陪集构成群 $G$ 的元素分类，对任意 $a,b$ 若同属一类，当且仅当 $a^{-1}b\in H$ （或 $b^{-1}a\in H$）</li>
  <li>对于右陪集，上条同理</li>
</ul>

<h4 id="定理-14">定理</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$H$ 是 $G$ 的子群，则 $R={&lt;a,b&gt;</td>
          <td>a\in G,b\in G 且 a^{-1}b\in H}$ 是 $G$ 中一个等价关系，对于 $a\in G$，记为 $[a]_R={x</td>
          <td>x\in G 且 &lt;a,x&gt;\in R}$，则有 $[a]_R=aH$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>一个子群 $H$ 的所有陪集都与 $H$ 等势</p>

    <blockquote>
      <p>等势是数学术语，集合里的等势是指两个集合之间一一对应。</p>
    </blockquote>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><strong>拉格朗日定理</strong>：$H$ 是 $G$ 的子群，若 $G$ 是有限群，$</td>
          <td>G</td>
          <td>=n,\</td>
          <td>H</td>
          <td>=m,\ (G:H)=k$，则 $n=km$</td>
        </tr>
      </tbody>
    </table>

    <blockquote>
      <p>群 $G$ 的阶为质数，则群 $G$ 无非平凡子群 / 真子群</p>
    </blockquote>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>群 $</td>
          <td>G</td>
          <td>=n$ ，对于任意 $a\in G,</td>
          <td>a</td>
          <td>$ 是 $n$ 的因子，且必有 $a$，$a^n=e$。若 $n$ 是质数，则群 $G$ 是循环群。</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="指数">指数</h4>

<p>群 $G$ 的子群 $H$ 的所有不同左陪集（右陪集）的个数称为 $H$ 在 $G$ 里的指数，可表示为 $(G:H)$</p>

<h3 id="不变子群">不变子群</h3>

<h4 id="定义-25">定义</h4>

<p>$G$ 的子群 $N$，若对于任意 $a\in G$，都有 $aN=Na$，则称 $N$ 为<strong>不变子群</strong>或正规子群。记为 $N\trianglelefteq G$，若 $N\not= G$，则记为 $N\triangleleft G$</p>

<h4 id="定理-15">定理</h4>

<p>若对任意 $a\in G$，$a^{-1}Na=aNa^{-1}=N$，则 $N\trianglelefteq G$</p>

<h3 id="半群与群">半群与群</h3>

<ul>
  <li>对半群 $G$，若对任意 $a,b\in G$， 方程 $a x = b，x a = b$ 在 $G$ 中有解，则 $G$ 为群。</li>
  <li>对有限半群 $G$ 无零元，若满足消去律，则 $G$ 为群</li>
</ul>

<h3 id="子群">子群</h3>

<h4 id="定义-26">定义</h4>

<p>$&lt;S,\times&gt;$ 称为群 $&lt;G,\times&gt;$ 的子群，若</p>

<ul>
  <li>$S\subseteq G$</li>
  <li>$&lt;S,\times&gt;$ 是一个群</li>
</ul>

<p>记为 $S\le G$</p>

<h4 id="性质-11">性质</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>若 $</td>
          <td>G</td>
          <td>\gt1$ ，则群 $&lt;G,\times&gt;$ 至少有两个子群：</td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>$&lt;{e},\times&gt;$</li>
      <li>$&lt;G,\times&gt;$</li>
    </ul>

    <p>称为 $G$ 的 <strong>平凡子群</strong>，其他子群称为 <strong>真子群 / 非平凡子群</strong>，记为 $S\lt G$</p>
  </li>
  <li>$&lt;S, \times&gt;$ 是群 $&lt;G, \times &gt;$ 的非空子群，则群 $S$ 的单位元就是群 $G$ 的单位元，$S$ 中任意元素 $a$ 的逆元也是 $a$ 在群 $G$ 中的逆元。</li>
</ul>

<h4 id="定理-16">定理</h4>

<ul>
  <li>群 $G$ 的非空子集 $S$ 构成子群的充要条件是
    <ul>
      <li>若 $a,b\in S$，则 $ab\in S$</li>
      <li>若 $a\in S$，则 $a$ 在 $G$ 中逆元 $a^{-1}\in G$</li>
    </ul>
  </li>
  <li>群 $G$ 的非空子集 $S$ 构成子群的充要条件是
    <ul>
      <li>若 $a,b\in S$，则 $ab^{-1}\in S$</li>
    </ul>
  </li>
  <li>群 $G$ 的非空 <strong>有限</strong> 子集 $S$ 构成子群的充要条件是
    <ul>
      <li>若 $a,b\in S$，则 $ab\in S$</li>
    </ul>
  </li>
</ul>]]></content><author><name>ericaaaaaaaa</name></author><category term="Mathematics" /><category term="discrete-mathematics" /><category term="math" /><category term="note" /><category term="graph-theory" /><summary type="html"><![CDATA[图论]]></summary></entry><entry><title type="html">Operating System</title><link href="http://localhost:4000/computerarchitecture/2021/06/10/OperatingSystem.html" rel="alternate" type="text/html" title="Operating System" /><published>2021-06-10T00:00:00+08:00</published><updated>2021-06-10T00:00:00+08:00</updated><id>http://localhost:4000/computerarchitecture/2021/06/10/OperatingSystem</id><content type="html" xml:base="http://localhost:4000/computerarchitecture/2021/06/10/OperatingSystem.html"><![CDATA[<h1 id="操作系统">操作系统</h1>

<h2 id="引论">引论</h2>

<h3 id="基本概念">基本概念</h3>

<h4 id="计算机体系结构中的接口">计算机体系结构中的接口</h4>

<ul>
  <li>UI
    <ul>
      <li>用户接口 User Interface</li>
    </ul>
  </li>
  <li>API
    <ul>
      <li>应用程序界面 Application Program Interface</li>
    </ul>
  </li>
  <li>ABI
    <ul>
      <li>应用程序二进制接口 Application Binary Interface</li>
    </ul>
  </li>
  <li>ISA
    <ul>
      <li>工业标准结构 Industry Standard Architecture</li>
    </ul>
  </li>
</ul>

<h3 id="历史">历史</h3>

<p><code class="language-plaintext highlighter-rouge">史前阶段</code>-&gt; <code class="language-plaintext highlighter-rouge">批处理</code>-&gt;<code class="language-plaintext highlighter-rouge">分时</code>-&gt;<code class="language-plaintext highlighter-rouge">现代 OS</code>-&gt;<code class="language-plaintext highlighter-rouge">网络化 OS /分布式 OS</code></p>

<h4 id="批处理系统">批处理系统</h4>

<p>加载在计算机上的一个系统软件，使得计算机能够<strong>自动</strong>的，<strong>成批</strong>的处理一个或多个用户的作业。</p>

<h5 id="联机批处理系统">联机批处理系统</h5>

<p>作业的输入 / 输出由<strong>CPU</strong>来处理</p>

<blockquote>
  <p>克服人机矛盾，提高计算机利用率</p>

  <p>存在高速主机与慢速外设的矛盾</p>
</blockquote>

<h5 id="脱机批处理系统">脱机批处理系统</h5>

<p>作业的输入 / 输出<strong>脱离主机控制</strong></p>

<blockquote>
  <p>克服高速主机与慢速外设的矛盾</p>

  <p>等待 IO 时 CPU 处于空闲状态</p>
</blockquote>

<h4 id="多道程序系统">多道程序系统</h4>

<p>允许多个程序同时放入内存并运行</p>

<blockquote>
  <p>使 CPU 得到充分利用，改善 I/O 设备和内存的利用率，提高整个系统的资源利用率和内存的利用率</p>
</blockquote>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202104/2324053-20210426104110847-2086237697.png" alt="image" /></p>

<p><strong>宏观上并行，微观上串行</strong></p>

<h4 id="多道批处理系统">多道批处理系统</h4>

<ul>
  <li><strong>多道</strong>： 系统可同时容纳多个作业</li>
  <li><strong>成批</strong>： 系统运行过程中，不允许用户与其它作业发生交互作用</li>
</ul>

<h4 id="分时系统">分时系统</h4>

<p>处理机的运行时间被分成很短的时间片，按时间片轮流把处理机分配给联机作业使用。</p>

<ul>
  <li>多路性</li>
  <li>交互性</li>
  <li>独立性</li>
  <li>及时性</li>
</ul>

<h4 id="分布式系统">分布式系统</h4>

<p>整个系统中有一个全局的操作系统</p>

<h4 id="实时系统">实时系统</h4>

<ul>
  <li>及时响应</li>
  <li>高可靠性和安全性</li>
  <li>系统的整体性强</li>
  <li>交互会话活动较弱</li>
</ul>

<h3 id="计算机硬件简介">计算机硬件简介</h3>

<h4 id="内存">内存</h4>

<h4 id="cache">Cache</h4>

<h4 id="磁盘">磁盘</h4>

<h3 id="操作系统的特征">操作系统的特征</h3>

<ul>
  <li>并发</li>
  <li>共享
    <ul>
      <li>互斥共享</li>
      <li>同时访问</li>
    </ul>
  </li>
  <li>虚拟</li>
  <li>异步性</li>
</ul>

<h2 id="系统引导">系统引导</h2>

<h3 id="基础知识">基础知识</h3>

<h4 id="启动-bootstrapping">启动 Bootstrapping</h4>

<h4 id="bootloader">Bootloader</h4>

<p>系统加点后运行的第一段软件代码，是在操作系统内核运行前运行的一段小程序。</p>

<h4 id="mips-的基本地址空间">MIPS 的基本地址空间</h4>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202104/2324053-20210426130707406-741030482.png" alt="image" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">命名</th>
      <th style="text-align: center">地址</th>
      <th style="text-align: center">功能</th>
      <th style="text-align: center">MMU</th>
      <th style="text-align: center">Cache</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">kuseg</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0x0000 0000 - 0x7FFF FFFF</code></td>
      <td style="text-align: center">用户态可用地址</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">√</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">kseg0</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0x8000 0000 - 0x9FFF FFFF</code></td>
      <td style="text-align: center">存放**操作系统核心**</td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">√</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">kseg1</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0xA000 0000 - 0xBFFF FFF</code></td>
      <td style="text-align: center">I/O 寄存器，**唯一在系统重启时能正常工作的地址空间**</td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">×</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">kseg2</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0xC000 0000 - 0xFFFF FFFF</code></td>
      <td style="text-align: center">可供管理态程序使用</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">√</td>
    </tr>
  </tbody>
</table>

<h2 id="存储器管理">存储器管理</h2>

<h3 id="存储器管理基础">存储器管理基础</h3>

<h4 id="存储层次结构">存储层次结构</h4>

<p>寄存器 》 高速缓存 》 主存 》 外存</p>

<h4 id="大小尾端">大小尾端</h4>

<p>提到体系结构时，经常遇到大小尾端的概念，这里做个总结。
big endian：大尾端，也称大端（高位）优先存储。
little endian：小尾端，也称小端（低位）优先存储。
如下00001000 00000100 00000010 00000001的存储</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>大尾端： 00001000 00000100 00000010 00000001
        addr+0    addr+1     addr+2   addr+3   //先存高有效位（在低地址）
小尾端： 00000001 00000010 00000100 00001000
        addr+0    addr+1     addr+2   addr+3   //先存低有效位（在低地址）
</code></pre></div></div>

<p>比如 short int a = 0x1234
大尾存放时：
偏移地址   存放内容
0x0000    0x12
0x0001    0x34</p>

<p>小尾存放：
偏移地址   存放内容
0x0000    0x34
0x0001    0x12</p>

<h4 id="程序的装入和链接">程序的装入和链接</h4>

<h5 id="c-语言编译链接过程">c 语言编译+链接过程</h5>

<ul>
  <li>编译
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.c</code>-&gt;<code class="language-plaintext highlighter-rouge">.o</code></li>
    </ul>
  </li>
  <li>链接
    <ul>
      <li>将 <code class="language-plaintext highlighter-rouge">.o</code> 文件和库文件链接到一起，形成最终的可执行文件</li>
    </ul>
  </li>
  <li>重定位
    <ul>
      <li>填写之前未填写的地址的过程</li>
    </ul>
  </li>
</ul>

<h5 id="gcc-调用包含的几个工具"><code class="language-plaintext highlighter-rouge">gcc</code> 调用包含的几个工具</h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">cc1</code>: 预处理器和编译器</li>
  <li><code class="language-plaintext highlighter-rouge">as</code>: 汇编器</li>
  <li><code class="language-plaintext highlighter-rouge">collect2</code>: 链接器</li>
</ul>

<h5 id="elfexecutable-and-linkable-format-可执行文件格式"><code class="language-plaintext highlighter-rouge">ELF(Executable and Linkable Format)</code>-可执行文件格式</h5>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202104/2324053-20210426132323158-80020968.png" alt="image" /></p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210503164950768-1931582126.png" alt="image" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.text</code>
    <ul>
      <li><strong>正文</strong>，存放程序的执行指令</li>
      <li>只读</li>
      <li>包括命令语句和一些只读的常数变量，如字符串常量等</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">.data</code>
    <ul>
      <li><strong>数据段</strong>，存放程序内存映像的初始化数据</li>
      <li>存放已初始化的全局变量</li>
      <li>属于静态内存分配</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">.bss</code>
    <ul>
      <li><strong>静态段</strong>，存放程序内存映像未初始化数据，不沾文件空间</li>
      <li>存放未初始化的全局变量</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">heap</code>
    <ul>
      <li><strong>堆</strong></li>
      <li>先进先出</li>
      <li>存放程序中被动态分配的内存段</li>
      <li>属于动态内存分配</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">stack</code>
    <ul>
      <li><strong>栈</strong></li>
      <li>先进后出</li>
      <li>存放程序临时创建的局部变量</li>
      <li>属于动态内存分配</li>
      <li>在函数调用时，其参数会被压入发起调用的进程栈中，并且等调用结束后，函数的返回值也会被存放回栈中。</li>
    </ul>
  </li>
</ul>

<h6 id="elf-header">ELF Header</h6>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202104/2324053-20210426133127100-816057673.png" alt="image" /></p>

<h5 id="program-header-table">Program Header Table</h5>

<h5 id="section-header-table">Section Header Table</h5>

<h4 id="程序的装载和运行">程序的装载和运行</h4>

<h5 id="程序的装载">程序的装载</h5>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">shell</code> 调用 <code class="language-plaintext highlighter-rouge">fork()</code> 系统调用，创建出一个子进程</p>
  </li>
  <li>
    <p>子进程调用 <code class="language-plaintext highlighter-rouge">execve()</code> 加载 program</p>

    <ul>
      <li>
        <p>加载器根据 ELF 文件中的 segment 相关信息完成加载</p>

        <blockquote>
          <p>一个 <code class="language-plaintext highlighter-rouge">segment</code> 在文件中的大小 ≤ 内存中的大小</p>

          <p>通过 <strong>补零</strong> 使其达到其在内存中应有的大小</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h5 id="程序的运行">程序的运行</h5>

<ul>
  <li>系统调用 <code class="language-plaintext highlighter-rouge">execve</code></li>
</ul>

<h3 id="基础内存管理">基础内存管理</h3>

<h4 id="单道程序的内存管理">单道程序的内存管理</h4>

<h5 id="分配方式">分配方式</h5>

<ul>
  <li>直接指定</li>
  <li>静态分配</li>
  <li>动态分配</li>
</ul>

<h5 id="优缺点">优缺点</h5>

<ul>
  <li>优点
    <ul>
      <li>无需地址翻译，程序运行速度快</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>比物理内存大的程序无法加载，因而无法运行</li>
      <li>造成资源浪费</li>
    </ul>
  </li>
</ul>

<h4 id="多道程序的内存管理">多道程序的内存管理</h4>

<h5 id="分区式匹配">分区式匹配</h5>

<h6 id="固定式静态分区分配">（固定式）静态分区分配</h6>

<ul>
  <li>
    <p>分区大小</p>

    <ul>
      <li>
        <p>相等</p>

        <p>适合多个相同程序的并发执行</p>
      </li>
      <li>
        <p>不等</p>
      </li>
    </ul>
  </li>
  <li>
    <p>队列数目</p>

    <ul>
      <li>
        <p>单队列</p>

        <p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210503195048476-1795308777.png" alt="image" /></p>
      </li>
      <li>
        <p>多队列</p>

        <p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210503195110247-16117104.png" alt="image" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>优缺点</p>

    <ul>
      <li>
        <p>优点</p>

        <p>易于实现，开销小</p>
      </li>
      <li>
        <p>缺点</p>

        <p>内碎片造成浪费，分区总数固定，限制了并发执行的程序数目</p>
      </li>
      <li>
        <p>数据结构</p>

        <p>分区表——记录分区的大小和使用情况</p>
      </li>
    </ul>
  </li>
</ul>

<h6 id="可变式动态分区分配">（可变式）动态分区分配</h6>

<ul>
  <li>
    <p>优缺点</p>

    <p>没有内碎片，有外碎片</p>
  </li>
</ul>

<h4 id="闲置空间管理">闲置空间管理</h4>

<h5 id="位图表示法">位图表示法</h5>

<p>给每个单元赋予一个空位，用来记录单元是否闲置。</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210503201329849-1037490167.png" alt="image" /></p>

<h5 id="分区表示法">分区表示法</h5>

<p>将分配单元按照是否闲置链接起来。</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210503201353524-914507544.png" alt="image" /></p>

<h4 id="可变分区的管理">可变分区的管理</h4>

<p>已分配分区表和未分配分区表</p>

<h4 id="分区分配算法">==分区分配算法==</h4>

<h5 id="首次适应算法first-fit">首次适应算法(First Fit)</h5>

<p>从空白区域链始端开始查找，选择第一个满足要求的空白块。</p>

<h5 id="下次适应算法-next-fit">下次适应算法 (Next Fit)</h5>

<p>从上一次查找结束的地方开始，选择第一个满足要求的空白块。</p>

<h5 id="最佳适应算法-best-fit">最佳适应算法 (Best Fit)</h5>

<p>总是寻找大小最接近作业要求的存储区域</p>

<h5 id="最坏适应算法worst-fit">最坏适应算法(Worst Fit)</h5>

<p>总是寻找最大的空白分区</p>

<h5 id="基于索引的搜索分配算法">基于索引的搜索分配算法</h5>

<h5 id="快速适应算法">快速适应算法</h5>

<h5 id="伙伴系统">伙伴系统</h5>

<p>无论已分配分区或空闲分区，其大小均为 2 的 k 次幂。将空闲分区分成相等的两个分区，称为一对伙伴。</p>

<h4 id="系统中的碎片">系统中的碎片</h4>

<h5 id="内碎片">内碎片</h5>

<ul>
  <li>分配给作业的存储空间中未被利用的部分</li>
  <li>无法被整理，只能在作业完成后得到释放</li>
</ul>

<h5 id="外碎片">外碎片</h5>

<ul>
  <li>
    <p>分区和分区之间存在的碎片</p>
  </li>
  <li>
    <p>消除方法： <strong>紧凑技术</strong></p>

    <blockquote>
      <p>通过移动作业把多个分散的小分区拼接成一个大分区</p>
    </blockquote>
  </li>
</ul>

<h4 id="分区的存储保护">分区的存储保护</h4>

<h5 id="界限寄存器方法">界限寄存器方法</h5>

<ul>
  <li>上下界寄存器方法</li>
  <li>基址，限长寄存器方法</li>
</ul>

<h5 id="存储保护键方法">存储保护键方法</h5>

<h4 id="分区管理">分区管理</h4>

<blockquote>
  <p>如何实现小内存运行大作业？</p>
</blockquote>

<h5 id="覆盖">==覆盖==</h5>

<ul>
  <li>把一个程序划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成能一组，共享主存的同一个区域。</li>
  <li>要求作业各模块之间有明确的调用结构， <strong>程序员要向系统指明覆盖结构</strong>，然后由操作系统自动完成覆盖</li>
  <li>缺点：<strong>对用户不透明，增加用户负担</strong></li>
  <li>主要对 <strong>同一个作业或程序进行</strong></li>
</ul>

<h5 id="交换">==交换==</h5>

<ul>
  <li>把暂时不用的某个（或某些）程序及其数据的部分或全部从主存移动到辅存中去。</li>
  <li>优点：增加并发运行的程序数目，给用户提供适当的响应时间；编写程序时不影响程序的结构</li>
  <li>缺点：对换入和换出的控制增加处理机开销；程序整个地址空间都进行传送，没有考虑到执行过程中地址访问的统计特性</li>
  <li>主要在作业和程序间进行</li>
</ul>

<h3 id="页式内存管理">页式内存管理</h3>

<h4 id="基本原理">基本原理</h4>

<h5 id="程序">程序</h5>

<ul>
  <li>静止</li>
  <li>一个程序可以作为多个运行进程的运行程序</li>
</ul>

<h5 id="进程">进程</h5>

<ul>
  <li>动态</li>
  <li><strong>计算机系统有限资源的基本单位</strong></li>
  <li>能真实的描述并发</li>
  <li>由生存周期</li>
  <li>一个进程可以运行多个程序</li>
  <li>一个进程可以创建其它进程</li>
</ul>

<h5 id="作业">作业</h5>

<ul>
  <li>用户需要计算机完成的某项任务，要求计算机所做工作的集合</li>
  <li>一个作业通常包括程序、数据和操作说明书</li>
  <li>作业完成阶段：
    <ul>
      <li>提交</li>
      <li>收容</li>
      <li>执行</li>
      <li>完成</li>
    </ul>
  </li>
  <li>一个作业可以由多个进程组成，且至少由一个进程组成，反之不成立</li>
</ul>

<h4 id="基本概念-1">基本概念</h4>

<h5 id="页">页</h5>

<p>把每个地址空间分成一些<strong>大小相等</strong>的片，称作 <strong>页面</strong> 或 <strong>页</strong>，各页从 0 开始编号</p>

<h5 id="存储块">存储块</h5>

<p>把主存的存储空间页分为 <strong>与页面大小相等的</strong> 片，称作 <strong>存储块</strong> 或 <strong>页框 (Frame)</strong></p>

<h5 id="页表">页表</h5>

<p>方便在内存中找到进程每个页面所对应的块。进程<strong>逻辑地址空间</strong>中的每一页，在页表中都有一个页表项</p>

<h5 id="地址变换">地址变换</h5>

<h5 id="多级页表">多级页表</h5>

<blockquote>
  <p>为什么要采用多级页表？（aka. 一级页表的问题）</p>

  <p>因为页表的存放要求<strong>地址连续</strong>，若逻辑地址空间很大，则页表就很大，占用的连续存储空间就很大，实现困难，因此可以采用多级页表（或者动态调入页表）的方式</p>
</blockquote>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505150415858-1017472083.png" alt="image" /></p>

<h5 id="快表-tlb-translation-lookaside-buffer">快表 (TLB, Translation Lookaside Buffer)</h5>

<p>块表是一种特殊的高速缓冲存储器，内容是页表中的一部分或全部内容</p>

<p>CPU 产生逻辑地址的页号，首先在块表中查找，若命中就找出其对应的物理块，若未命中，再到页表中找出其对应的物理块。</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505150640919-918643565.png" alt="image" /></p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505150728433-1811027996.png" alt="image" /></p>

<h4 id="纯分页系统-pure-paging-system">纯分页系统 (Pure Paging System)</h4>

<ul>
  <li>不具备页面对换功能，不支持虚拟存储器功能</li>
  <li>在调度一个作业时，必须把它的所有页一次装到主存的页框里</li>
  <li>优缺点：
    <ul>
      <li>优点：没有外碎片，每个内碎片不超过页大小，一个程序不必连续存放</li>
      <li>缺点：程序全部装入内存</li>
    </ul>
  </li>
</ul>

<h5 id="地址结构">地址结构</h5>

<h6 id="逻辑地址">逻辑地址</h6>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505145630757-169251152.png" alt="image" /></p>

<h6 id="物理地址">物理地址</h6>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505145654609-1935493561.png" alt="image" /></p>

<h5 id="数据结构">数据结构</h5>

<h6 id="进程页表">进程页表</h6>

<p>每个进程有一个页表，描述该进程占用物理页面及逻辑排列顺序</p>

<h6 id="物理页面表">物理页面表</h6>

<p>每个系统有一个物理页面表，描述物理内存空间的分配和使用情况</p>

<ul>
  <li>位图，空闲链表</li>
</ul>

<h6 id="请求表">请求表</h6>

<p>每个系统有一个请求表，描述系统内各个进程页表的位置和大小</p>

<h5 id="页表-1">页表</h5>

<p>访问一个数据需要访问内存 <strong>2</strong> 次（页表一次，内存一次）</p>

<p>页表的基址和长度由页表寄存器给出</p>

<h5 id="地址转换机构">地址转换机构</h5>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505150042395-247837520.png" alt="image" /></p>

<h4 id="页面大小">页面大小</h4>

<ul>
  <li>若页面较小
    <ul>
      <li>减少内碎片和总的内存碎片</li>
      <li>每个进程的页面数增多，页表程度增加，占用内存增大</li>
      <li>页面换进换出速率降低</li>
    </ul>
  </li>
  <li>若页面较大
    <ul>
      <li>每个进程页面数减少，页表长度减少，占用内存较小</li>
      <li>页面换进换出速度提高</li>
      <li>增加页内碎片，不利于提高内存利用率</li>
    </ul>
  </li>
</ul>

<h4 id="页表类型">页表类型</h4>

<h5 id="哈希页表">哈希页表</h5>

<p>用虚拟页码作为哈希值。</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505180445459-271419957.png" alt="image" /></p>

<h5 id="反置页表-inverted-page-table">反置页表 (inverted page table)</h5>

<ul>
  <li>反置页表是根据该进程在内存中的<strong>物理页面号</strong>来组织，其表项内容是逻辑页号 <code class="language-plaintext highlighter-rouge">p</code> 及隶属进程标识符 <code class="language-plaintext highlighter-rouge">pid</code></li>
  <li>反置页表的大小<strong>只与物理内存的大小有关</strong>，与逻辑空间大小和进程数无关。</li>
  <li><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505185222076-641500225.png" alt="image" /></li>
  <li>可能需要查找整个表来寻找匹配，可以通过使用哈希表来限制页表条目或者加入 TLB 来改善</li>
</ul>

<h4 id="页共享">页共享</h4>

<p>最好的实现方式：分段存储管理</p>

<h3 id="段式内存管理">段式内存管理</h3>

<h4 id="基本原理-1">基本原理</h4>

<blockquote>
  <ul>
    <li>
      <p><strong>方便编程</strong></p>

      <p>一个作业由多个代码段和数据段组成，用户可以根据名字访问到对应的程序段和数据段</p>
    </li>
    <li>
      <p><strong>信息共享</strong></p>

      <p>共享以信息的逻辑单位为基础</p>

      <p>以 <strong>页</strong> 为存储信息的物理单位，以 <strong>段</strong> 为存储信息的逻辑单位</p>
    </li>
    <li>
      <p><strong>信息保护</strong></p>

      <p>以信息的逻辑单位进行保护</p>
    </li>
    <li>
      <p><strong>动态增长</strong></p>

      <p>实现某些段的不断增长</p>
    </li>
    <li>
      <p><strong>动态链接</strong></p>

      <p>把主程序和需要用到的目标程序链接起来</p>
    </li>
  </ul>
</blockquote>

<h5 id="分段地址空间">分段地址空间</h5>

<p>一个段可以定义为一组逻辑信息，每个作业的地址空间由一些分段构成，每个段有自己的名字，且都是一段连续的地址空间，首地址为 0</p>

<h5 id="地址结构-1">地址结构</h5>

<h6 id="段表">段表</h6>

<ul>
  <li>段表保存在内存中，记录了段与内存位置的对应关系</li>
  <li>访问数据需要先访问段表一次，再访问内存一次</li>
  <li>逻辑地址 = 段号 + 段内偏移</li>
</ul>

<h4 id="地址变换-1">地址变换</h4>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505203952551-484047019.png" alt="image" /></p>

<h4 id="段共享">段共享</h4>

<p><strong>可重入代码</strong>（纯代码）</p>

<blockquote>
  <p>允许多个进程同时访问的代码，只读，各个进程执行的代码完全相同</p>
</blockquote>

<h4 id="优缺点-1">优缺点</h4>

<h5 id="优点">优点</h5>

<ul>
  <li>易于实现段的共享，对段的保护十分简单</li>
</ul>

<h5 id="缺点">缺点</h5>

<ul>
  <li>变换地址花费时间，且需要为段表提供附加的地址空间</li>
  <li>为满足分段的动态增长和减少外零头，要采用拼接手段</li>
  <li>辅存管理不定长度的分段较为困难</li>
  <li>分段的最大尺寸受到主存可用空间的限制</li>
</ul>

<h4 id="与页式管理优缺点对比">与页式管理优缺点对比</h4>

<ul>
  <li>分页的地址空间是单一的线性地址空间，而分段的地址空间是二维的</li>
  <li><strong>页</strong> 是信息的 <strong>物理单位</strong> ，而 <strong>段</strong> 是信息的 <strong>逻辑单位</strong></li>
  <li>页大小固定，段大小不固定</li>
  <li>分页用户不可见，分段用户可见</li>
</ul>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505204531879-1275370754.png" alt="image" /></p>

<h4 id="段页式管理">段页式管理</h4>

<h5 id="基本思想">基本思想</h5>

<p>用 <strong>分段</strong> 方法来分配和管理虚拟存储器，用 <strong>分页</strong> 的方法来分配和管理实存储器</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505204702764-1138006488.png" alt="image" /></p>

<h5 id="实现原理">实现原理</h5>

<p>地址组成</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505204741937-816298569.png" alt="image" /></p>

<p><strong>一个进程一个段表，每个段一个页表</strong></p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505204828444-24496586.png" alt="image" /></p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505204905163-1147211281.png" alt="image" /></p>

<h3 id="虚拟存储管理">虚拟存储管理</h3>

<h4 id="局部性原理">局部性原理</h4>

<h4 id="基本原理-2">基本原理</h4>

<ul>
  <li>在程序装入时，不必将其完全读到内存，而只需要将当前需要执行的不分页或段读入内存</li>
  <li>在程序运行过程中，若需要更多的页面/段，则产生缺页中断，通知操作系统将其调入到内存中</li>
  <li>操作系统将内存中暂时不用的页或段保存在外存中</li>
</ul>

<h4 id="虚拟内存">虚拟内存</h4>

<p>虚拟内存为每个进程提供了一个 <strong>一致的、连续的、私有的</strong> 地址空间。</p>

<ul>
  <li>
    <p>离散性</p>

    <p>物理内存分配不必连续</p>
  </li>
  <li>
    <p>多次性</p>

    <p>作业分多次调入内存</p>
  </li>
  <li>
    <p>对换性</p>

    <p>允许作业在运行过程中换进换出</p>
  </li>
  <li>
    <p>虚拟性</p>

    <p>不考虑物理内存上可用的空间和数量</p>
  </li>
</ul>

<h5 id="优点代价和现实">优点、代价和现实</h5>

<h6 id="优点-1">优点</h6>

<ul>
  <li>在较小的物理内存中执行较大的程序</li>
  <li>可在内存中容纳更多的程序并发执行</li>
  <li>不影响编程时的程序结构</li>
  <li>提供给用户大于物理内存的虚拟空间</li>
</ul>

<h6 id="代价">代价</h6>

<ul>
  <li>牺牲 CPU 处理时间和内外存的交换时间</li>
</ul>

<h6 id="限制">限制</h6>

<p>虚拟内存的最大容量由计算机的地址结构决定</p>

<h4 id="请求式分页">请求式分页</h4>

<p>在分页（分段）系统的基础上，增加了请求调段（页）的功能</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505214835157-1263893749.png" alt="image" /></p>

<h5 id="请求式分页管理的页表">请求式分页管理的页表</h5>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505220106830-290017426.png" alt="image" /></p>

<ul>
  <li>驻留位
    <ul>
      <li>1: 该页在内存当中</li>
      <li>0: 该页当前还在外存当中</li>
    </ul>
  </li>
  <li>保护位
    <ul>
      <li>只读、可写、可执行</li>
    </ul>
  </li>
  <li>修改位
    <ul>
      <li>表明此页在内存中是否被修改过</li>
    </ul>
  </li>
  <li>访问（统计）位
    <ul>
      <li>用于页面置换算法</li>
    </ul>
  </li>
</ul>

<h4 id="基本概念-2">基本概念</h4>

<h5 id="逻辑空间虚拟空间">逻辑空间（虚拟空间）</h5>

<p>通过连接器，将构成进程所需要的程序及其运行所需要的环境，按照某种规则装配链接而形成的一种规范格式。</p>

<p>格式按字节从 0 开始编址所形成的空间</p>

<h5 id="虚拟地址空间--虚拟存储空间">虚拟地址空间 &amp; 虚拟存储空间</h5>

<p>一个进程虚拟地址空间是进程在内存中存放的逻辑视图</p>

<p>一个进程的虚拟地址空间大小 = 虚拟存储空间大小</p>

<h5 id="交换分区交换文件">交换分区（交换文件）</h5>

<p>在物理内存不够的情况下，将内存中的数据存到硬盘的交换空间中，从而获得更大的空间</p>

<h5 id="地址映射问题">地址映射问题</h5>

<ul>
  <li>在每个进程创建加载时，内核只是为进程创建了虚拟内存的布局，而并没有把信息拷贝到对应的地址上。等程序运行时，才通过缺页异常拷贝数据</li>
  <li><em>用户可执行文件</em> 及 <em>共享库</em> 都是以文件的形式存在磁盘中，初始时在页表中的类型为 <em>file backed</em></li>
  <li><em>堆</em>  和 <em>栈</em> 在磁盘上没有对应的文件，页表中类型为 <em>anonymous</em></li>
  <li>未分配部分没有对应的页表项，只有在申请时才建立相应的页表项</li>
</ul>

<h4 id="虚拟存储器的管理">虚拟存储器的管理</h4>

<h5 id="页面调入">页面调入</h5>

<h6 id="预调页">预调页</h6>

<p>事先调入页面</p>

<h6 id="按需调页">按需调页</h6>

<p>仅当需要的时候调入页面</p>

<h5 id="页错误处理">页错误处理</h5>

<ol>
  <li>
    <p><strong>现场保护</strong></p>

    <p>陷入内核态，保存必要信息</p>
  </li>
  <li>
    <p><strong>页面定位</strong></p>

    <p>查找发生中断的虚拟页面</p>
  </li>
  <li>
    <p><strong>权限检查</strong></p>

    <p>检查有效性及安全保护位</p>
  </li>
  <li>
    <p><strong>新页面调入</strong></p>
  </li>
  <li>
    <p><strong>旧页面写回</strong></p>
  </li>
  <li>
    <p><strong>新页面调入</strong></p>
  </li>
  <li>
    <p><strong>更新页表</strong></p>
  </li>
  <li>
    <p><strong>恢复现场</strong></p>
  </li>
  <li>
    <p><strong>继续执行</strong></p>
  </li>
</ol>

<h5 id="置换问题">==置换问题==</h5>

<h6 id="最优置换optimal">最优置换（Optimal）</h6>

<p>理想情况，无法被实现</p>

<p>最优置换会将内存中的页 P 置换掉，如果页 P 满足：从现在开始到未来的某时刻再次需要页 P，这段时间最长。也就是 OPT 算法会置换掉未来最久不被使用的页。</p>

<h6 id="先进先出算法first-in-first-out">先进先出算法（First-in First-out）</h6>

<ul>
  <li>
    <p>Belady 现象</p>

    <blockquote>
      <p>所谓 Belady 现象是指：在分页式虚拟存储器管理中，发生缺页时的置换算法采用FIFO（先进先出）算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p>
    </blockquote>
  </li>
  <li>
    <p>改进版本：</p>

    <ul>
      <li>
        <p><strong>第二次机会算法（Second Chance）</strong></p>

        <p>如果被淘汰的数据之前被访问过，则给其第二次机会（Second Chance）</p>

        <p>每个页面会增加一个<strong>访问标志位</strong>，用于标识此数据放入缓存队列后是否被再次访问过。</p>

        <ul>
          <li>A是FIFO队列中最旧的页面，且其放入队列后没有被再次访问，则A被立刻淘汰；否则如果放入队列后被访问过，则将A<strong>移到FIFO队列头，并且将访问标志位清除</strong>。</li>
          <li>如果所有的页面都被访问过，则经过一次循环后就会按照FIFO的原则淘汰。</li>
        </ul>
      </li>
      <li>
        <p><strong>Clock</strong> 算法，最近未使用算法（NRU, Not Recently Used）</p>

        <ul>
          <li>如果没有缺页错误，将相应的页面访问位置1，指针不动</li>
          <li>产生缺页错误时，当前指针指向C，如果C被访问过，则清除C的访问标志，并将指针指向D；</li>
          <li>如果C没有被访问过，则将新页面放入到C的位置, 置访问标志，并将指针指向D。</li>
        </ul>
      </li>
    </ul>

    <p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505223735498-1088842058.png" alt="image" /></p>
  </li>
</ul>

<h6 id="最近不适用页面置换算法least-recently-used-replacement">最近不适用页面置换算法（Least Recently Used Replacement）</h6>

<ul>
  <li>
    <p>访问第 i 页时先将该页所在的行置 1，所在列清 0，将行编号最小的那一页置出去</p>
  </li>
  <li>
    <p>缺点：空间开销太大</p>
  </li>
  <li>
    <p>改进算法：</p>

    <ul>
      <li>
        <p><strong>老化算法（Aging）</strong></p>

        <p>位每个页面设置一个移位寄存器，并设置一位访问位 R，每隔一段时间，所有寄存器右移 1 位，并将 R 的值从左移入</p>
      </li>
    </ul>
  </li>
</ul>

<h5 id="最小物理块数的问题">最小物理块数的问题</h5>

<h5 id="分配问题">分配问题</h5>

<h5 id="抖动问题-thrashing">==抖动问题 (Thrashing)==</h5>

<p>随着驻留内存的进程数目增加，或者说进程并发水平(multiprogramming level)的上升，处理器利用率先是上升，然后下降。</p>

<blockquote>
  <p>每个进程的驻留集不断减小，当驻留集小于工作集后，缺页率急剧上升频繁调页使得调页开销增大。OS要选择一个适当的进程数目，以在并发水平和缺页率之间达到一个平衡。</p>
</blockquote>

<p>解决办法：局部置换策略、工作集算法、预留部分页面、挂起若干进程</p>

<h4 id="页面置换">页面置换</h4>

<h4 id="内存保护">内存保护</h4>

<h3 id="存储管理实例">存储管理实例</h3>

<h3 id="页目录自映射">页目录自映射</h3>

<h4 id="基础知识-1">基础知识</h4>

<p>多级页表</p>

<table>
  <thead>
    <tr>
      <th>10</th>
      <th>10</th>
      <th>12</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>页目录偏移</td>
      <td>页表偏移</td>
      <td>页面偏移</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>空间</th>
      <th>大小</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>虚拟空间</td>
      <td>4 GB</td>
    </tr>
    <tr>
      <td>页表</td>
      <td>4 MB</td>
    </tr>
    <tr>
      <td>页面</td>
      <td>4 KB</td>
    </tr>
    <tr>
      <td>页目录</td>
      <td>4 KB</td>
    </tr>
    <tr>
      <td>页表项</td>
      <td>4 B</td>
    </tr>
  </tbody>
</table>

<p>$4G$ 空间对应 $2^{20}$ 个页面</p>

<p>$4M$ 页表空间对应 $2^{10}$ 个页表，其中每个页表对应 $2^{10}$ 个页面，即 $2^{22}B = 4MB$ 的内存空间</p>

<p>$4K$ 页目录空间对应 $2^{10}$ 个页目录项，其中每个页目录项对应一个页表，从而对应 $2^{10}$ 个页面，即 $2^{22}B = 4MB$ 的内存空间</p>

<h4 id="背景">背景</h4>

<p><img src="http://cscore.net.cn/assets/courseware/v1/384b0b746c79c840e9c3f4ff5b4b0b0f/asset-v1:Internal+B3I062140+2020_T2+type@asset+block/lab2-pic-1.jpg" alt="img" /></p>

<p><img src="http://cscore.net.cn/assets/courseware/v1/79285678df7ddb18b4761b7d88a87de9/asset-v1:Internal+B3I062140+2020_T2+type@asset+block/lab2-pic-2.jpg" alt="img" /></p>

<p>从一级页表、二级页表中获得的地址都是<strong>物理地址</strong></p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505230554161-398323370.png" alt="" /></p>

<p>页目录中有一条 PTE 指向自身的物理地址</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210505230701031-498549903.png" alt="/////////////////////////////////////////////////////////////////////////////////////////////////////////////" /></p>

<h4 id="计算">计算</h4>

<h5 id="符号及含义">符号及含义</h5>

<table>
  <thead>
    <tr>
      <th>符号</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$PT$</td>
      <td>Page Table，页表</td>
    </tr>
    <tr>
      <td>$PT_{base}$</td>
      <td>页表基址</td>
    </tr>
    <tr>
      <td>$PD$</td>
      <td>Page Directory，页目录</td>
    </tr>
    <tr>
      <td>$PD_{base}$</td>
      <td>页目录基址</td>
    </tr>
    <tr>
      <td>$PDE_{self-mapping}$</td>
      <td>自映射页目录项</td>
    </tr>
  </tbody>
</table>

<h5 id="公式">公式</h5>

<p>$$
PD_{base} = PT_{base} | (PT_{base}) » 10 <br />
PDE_{self_mapping} = PT_{base} | (PT_{base}) » 10 | (PT_{base}) » 20
$$</p>

<h5 id="由二级页表初地址求页目录地址">由二级页表初地址求页目录地址</h5>

<p>我们知道，这 4M 空间的起始位置也就是第一个二级页表对应着页目录的第一个页目录项，同时，由于 1M 个页表项和 4G 地址空间是线性映射，不难算出 0x7fc00000 这一地址对应的应该是第 (0x7fc00000 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> 12) 个页表项，这个页表项 也就是第一个页目录项。一个页表项 32 位，占用 4 个字节的内存，因此，其相对于页表起始地址 0x7fc000000 的 偏移为 (0x7fc00000 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> 12) * 4 = 0x1ff000 ，于是得到地址为 0x7fc00000 + 0x1ff000 = 0x7fdff000 。也就是 说，页目录的虚存地址为 0x7fdff000。</p>

<h2 id="进程与线程">进程与线程</h2>

<h3 id="进程概念的引入">进程概念的引入</h3>

<h4 id="基本概念-3">基本概念</h4>

<h5 id="并发与并行">并发与并行</h5>

<h6 id="并发-concurrent">==并发 Concurrent==</h6>

<p>在某一特定时间，两个活动无论是否在同一个处理机上运行，只要两个活动都处于各自起点和重点之间的某一处，则称两个活动是并发执行的。</p>

<p>多个任务在单处理器或多处理器中分时运行</p>

<h6 id="并行-parallel">==并行 Parallel==</h6>

<p>在同一时间度量下同时运行在<strong>不同</strong>处理机上</p>

<p>多个任务在多处理器上同时运行</p>

<h5 id="前驱图">前驱图</h5>

<p>有向无循环图，图中每个结点表示一条语句，一个程序段或进程，结点间的有向边表示语句或程序段的执行顺序</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210506082359425-1712882056.png" alt="image" /></p>

<p>如图，表示 AB 的执行顺序：先 A 后 B，可写成 $A\rightarrow B$</p>

<h5 id="程序并发执行时的特征">程序并发执行时的特征</h5>

<ul>
  <li>间断性</li>
  <li>非封闭性</li>
  <li>不可再现性</li>
</ul>

<h5 id="竞争">竞争</h5>

<ul>
  <li><strong>定义</strong>： 多个进程在读写同一个共享数据时结果依赖于它们执行的相对时间</li>
  <li><strong>条件</strong>： 多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关</li>
  <li><strong>并发进程的无关性——Bernstein 条件</strong></li>
</ul>

<h5 id="bernstein-条件">Bernstein 条件</h5>

<p><strong>判断程序并发执行结果是否可再现的充分条件</strong></p>

<p>两个进程 $S_1$ 和 $S_2$ 可并发，当且仅当下列条件同时成立
$$
R(S_1) \cap W(S_2)  = \empty <br />
W(S_1) \cap R(S_2)  = \empty <br />
W(S_1) \cap W(S_2)  = \empty <br />
$$
其中 $R(S_i)$ 表示 $S_i$ 的读子集，其值在 $S_i$ 中被引用的变量的集合</p>

<p>其中 $W(S_i)$ 表示 $S_i$ 的读子集，其值在 $S_i$ 中被改变的变量的集合</p>

<h5 id="临界资源">==临界资源==</h5>

<p>一次<strong>仅允许一个进程访问</strong>的资源称为 <strong>临界资源</strong></p>

<h5 id="临界区">临界区</h5>

<p>每个进程中访问临界资源的那段代码称作 <strong>临界区</strong></p>

<h5 id="进程-1">进程</h5>

<h6 id="定义">定义</h6>

<p>==进程是程序在一个数据集合上运行的过程，是系统进行<strong>资源分配和调度</strong>的一个独立单位==</p>

<h6 id="性质">性质</h6>

<ul>
  <li>动态性</li>
  <li>并发性</li>
  <li>独立性</li>
  <li>异步性</li>
</ul>

<h6 id="组成部分">组成部分</h6>

<ul>
  <li>代码</li>
  <li>数据</li>
  <li>PC 值</li>
  <li>一组通用寄存器的当前值、堆、栈</li>
  <li>一组系统资源（如打开的文件）</li>
</ul>

<h6 id="利弊">利弊</h6>

<ul>
  <li>利：提高效率</li>
  <li>弊：空间、时间开销</li>
</ul>

<h6 id="与程序的关系">与程序的关系</h6>

<p>通过多次执行，一个程序可以对应多个进程；通过调用关系，一个进程可以包括多个程序</p>

<h3 id="进程状态与控制">进程状态与控制</h3>

<h4 id="进程控制">进程控制</h4>

<h5 id="进程创建">进程创建</h5>

<ul>
  <li>创建方式
    <ul>
      <li>提交批处理作业</li>
      <li>用户登录</li>
      <li>由 OS 创建，以向用户提供服务</li>
      <li>由已存在的进程创建</li>
    </ul>
  </li>
</ul>

<h5 id="进程状态">==进程状态==</h5>

<h6 id="就绪-runnable">就绪 (Runnable)</h6>

<h6 id="执行状态-running">执行状态 (Running)</h6>

<h6 id="阻塞状态-not-runnable--blocked">阻塞状态 (Not Runnable / Blocked)</h6>

<ul>
  <li><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210506084509403-2109850253.png" alt="image" />
    <ul>
      <li>用户退出登录</li>
      <li>进程执行中断服务请求</li>
      <li>出错 or 失败</li>
      <li>正常结束</li>
      <li>给定时限到</li>
    </ul>
  </li>
</ul>

<h4 id="原语">原语</h4>

<p>==若干条指令组成，<strong>连续不可分割</strong>，必须在内核态下执行，且常驻内存==</p>

<h5 id="创建原语-fork-exec">创建原语 fork, exec</h5>

<h6 id="fork">fork</h6>

<ul>
  <li>在 <strong>父进程</strong> 中，fork 返回新创建<strong>子进程</strong>的进程 id</li>
  <li>在 <strong>子进程</strong> 中，fork 返回 <strong>0</strong></li>
  <li>若出现错误，fork 返回一个负值</li>
</ul>

<h5 id="撤销原语-kill">撤销原语 kill</h5>

<h4 id="进程控制块-pcbprocess-control-block">进程控制块 PCB(Process Control Block)</h4>

<p>一个与动态过程相联系的数据结构，记载了进程的外部特性（名字、状态）以及与其他进程的联系（通信关系），还记录了进程所拥有的各种资源。进程控制块是进程存在的标志。</p>

<h5 id="内容">内容</h5>

<ul>
  <li>进程标识符</li>
  <li>程序和数据地址</li>
  <li>现行状态</li>
  <li>现场保留区</li>
  <li>互斥和同步机制</li>
  <li>进程通信机制</li>
  <li>优先级</li>
  <li>资源清单</li>
  <li>链接字</li>
  <li>家族关系</li>
  <li>其它…</li>
</ul>

<h5 id="组织形式">组织形式</h5>

<ul>
  <li>线性表</li>
  <li>链接方式</li>
  <li>索引方式
    <ul>
      <li>就绪索引表</li>
      <li>阻塞索引表</li>
    </ul>
  </li>
</ul>

<h4 id="进程上下文切换-process-context-switch">进程上下文切换 (Process Context Switch)</h4>

<ul>
  <li>由调度器执行</li>
  <li>保存进程执行断点</li>
  <li>切换内存映射 （页表基址、flush TLB）</li>
</ul>

<h4 id="陷入--退出内核-mode-switch">陷入 / 退出内核 (Mode Switch)</h4>

<ul>
  <li>CPU 状态改变</li>
  <li>由中断、异常、Trap 指令（系统调用）引起</li>
  <li>需要保存执行现场（寄存器，堆栈等）</li>
</ul>

<h3 id="线程概念的引入">线程概念的引入</h3>

<h4 id="可执行单元线程-thread">可执行单元——线程 (Thread)</h4>

<h4 id="与进程的区别">==与进程的区别==</h4>

<p>进程是 <strong>资源拥有者</strong></p>

<p>线程是 <strong>可执行单元</strong>，将资源与计算分离，提高并发效率</p>

<p><strong>进程</strong> 拥有：虚空间、进程映像、处理机保护、文件、I/O 空间</p>

<p><strong>线程</strong> 拥有：运行状态、保存上下文（程序计数器）、执行<strong>栈</strong>、资源共享机制</p>

<h4 id="引入目的">引入目的</h4>

<ul>
  <li>减少进程切换的开销</li>
  <li>提高进程内的并发程度</li>
  <li>共享资源</li>
</ul>

<h3 id="线程的实现方式">线程的实现方式</h3>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210506090740433-1906429894.png" alt="image" /></p>

<h4 id="用户级线程-user-level-threads-ult">==用户级线程 (User Level Threads, ULT)==</h4>

<h5 id="优点-2">优点</h5>

<ul>
  <li>线程切换与内核无关</li>
  <li>线程的调度由应用决定，容易进行优化</li>
  <li>可运行在任何支持线程库的操作系统上</li>
</ul>

<h5 id="缺点-1">缺点</h5>

<ul>
  <li>系统调用会回引起阻塞，内核会因此阻塞 <strong>所有</strong> 相关的线程</li>
  <li>内核只能将处理机分配给进程，无法实现一个进程中多个线程的并行执行</li>
  <li>CPU 调度以 <strong>进程</strong> 为单位</li>
</ul>

<h4 id="内核级线程-kernel-level-threads-klt">==内核级线程 (Kernel Level Threads, KLT)==</h4>

<h5 id="优点-3">优点</h5>

<ul>
  <li>OS 可感知</li>
  <li>内核线程执行系统调用时，只导致该线程被中断</li>
  <li>CPU 调度以 <strong>线程</strong> 为单位</li>
</ul>

<h5 id="缺点-2">缺点</h5>

<ul>
  <li>线程创建、撤销、调度均需要 OS 内核提供支持</li>
</ul>

<h4 id="混合实现">混合实现</h4>

<ul>
  <li>线程在用户空间创建和管理</li>
  <li>实现从用户空间线程到内核空间线程的映射</li>
</ul>

<h2 id="进程同步">进程同步</h2>

<h3 id="同步与互斥问题">同步与互斥问题</h3>

<h4 id="进程互斥间接制约关系">进程互斥（间接制约关系）</h4>

<ul>
  <li>两个及其以上的进程不能同时进入同一组共享变量的临界区域</li>
</ul>

<h4 id="进程同步直接制约关系">进程同步（直接制约关系）</h4>

<ul>
  <li>使得程序的执行具有可再现性的过程</li>
  <li>是一种刻意安排的直接制约关系</li>
</ul>

<h4 id="临界区-1">临界区</h4>

<p><strong>空闲让进，忙则等待，有限等待，让权等待</strong></p>

<ol>
  <li>没有进程在临界区时，想进入临界区的进程可以进入</li>
  <li>任何两个进程都不能同时进入临界区 (Mutual Exclusion)</li>
  <li>当一个进程运行在它的临界区外面时，不能妨碍其他进程进入临界区</li>
  <li>任何一个进程进入临界区的要求应该在有限的时间内得到满足</li>
</ol>

<h3 id="基于忙等待的互斥方法">基于忙等待的互斥方法</h3>

<h3 id="基于信号量的方法">基于信号量的方法</h3>

<h4 id="信号量-semaphore">==信号量 (Semaphore)==</h4>

<h5 id="定义-1">定义</h5>

<p>一个确定的二元组 (s, q)，其中 s 是一个具有非负值的整型变量， q 是一个初始状态为空的队列</p>

<h5 id="分类">分类</h5>

<h6 id="二元信号量">二元信号量</h6>

<p>取值仅为 0 和 1，主要用作实现互斥</p>

<h6 id="一般信号量">一般信号量</h6>

<p>取值为可用物理资源的综述，用于进程间写作同步问题</p>

<h5 id="p-proberen-test">P (proberen, test)</h5>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">P</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span>
	<span class="k">while</span> <span class="n">S</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">do</span> <span class="n">skip</span><span class="p">;</span>
	<span class="n">S</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">V</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span>
	<span class="n">S</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<h5 id="v-verhogen-increment">V (verhogen, increment)</h5>

<h3 id="基于管程的同步与互斥">基于管程的同步与互斥</h3>

<h3 id="进程通信的主要方法">进程通信的主要方法</h3>

<h3 id="经典的进程同步与互斥问题">==经典的进程同步与互斥问题==</h3>

<h4 id="生产者-消费者问题">生产者-消费者问题</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// provides exclusive access to the buffer</span>
<span class="n">item</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// the number of items in the buffer</span>
<span class="n">spaces</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="c1">// the number of consumer threads in queue</span>
<span class="c1">// event is a local variable, each threads has its own version</span>

<span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">P</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
	<span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> 
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">V</span><span class="p">(</span><span class="n">spaces</span><span class="p">);</span>
    <span class="n">event</span><span class="p">.</span><span class="n">process</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">P</span><span class="p">(</span><span class="n">spaces</span><span class="p">);</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    	<span class="n">buffer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">V</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Cobegin</span>
        <span class="n">producer</span><span class="p">();</span>
    	<span class="n">consumer</span><span class="p">();</span>
    <span class="n">Coend</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="读者-写者问题">读者-写者问题</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a solution that may cause starvation</span>
<span class="kt">int</span> <span class="n">readers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// keeps track of how many readers are in the room</span>
<span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// provides exclusive access to roomEmpty</span>
<span class="n">roomEmpty</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">writer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">P</span><span class="p">(</span><span class="n">roomEmpty</span><span class="p">);</span>
    	<span class="c1">// critical section for writers</span>
    <span class="n">V</span><span class="p">(</span><span class="n">roomEmpty</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">reader</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    	<span class="n">readers</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">readers</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// first in locks</span>
            <span class="n">P</span><span class="p">(</span><span class="n">roomEmpty</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">// critical section for readers</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    	<span class="n">readers</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">readers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// last out unlocks</span>
    		<span class="n">V</span><span class="p">(</span><span class="n">roomEmpty</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Cobegin</span>
        <span class="n">writer</span><span class="p">();</span>
    	<span class="n">reader</span><span class="p">();</span>
    <span class="n">Coend</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># no-starve readers-writers hint
</span><span class="k">class</span> <span class="nc">Lightswitch</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">lock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">semaphore</span><span class="p">):</span>
        <span class="n">P</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">mutex</span><span class="p">)</span>
        	<span class="bp">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">P</span><span class="p">(</span><span class="n">semaphore</span><span class="p">)</span>
        <span class="n">V</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">unlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">semaphore</span><span class="p">):</span>
        <span class="n">P</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">mutex</span><span class="p">)</span>
        	<span class="bp">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">V</span><span class="p">(</span><span class="n">semaphore</span><span class="p">)</span>
        <span class="n">V</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">mutex</span><span class="p">)</span>
        
<span class="n">readSwitch</span> <span class="o">=</span> <span class="n">lightswitch</span><span class="p">()</span> <span class="c1"># how many readers are in the room, locks 'roomEmpty' when the first reader enters and unlocks it when the last reader exits.
</span><span class="n">roomEmpty</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">turnstile</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># a turnstile for readers and a mutex for writers
</span>
<span class="k">def</span> <span class="nf">writer</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">turnstile</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">roomEmpty</span><span class="p">)</span>
        <span class="c1"># critical section for writers
</span>    <span class="n">V</span><span class="p">(</span><span class="n">turnstile</span><span class="p">)</span> <span class="c1"># unblocks a waiting thread
</span>    <span class="n">V</span><span class="p">(</span><span class="n">roomEmpty</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">reader</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">turnstile</span><span class="p">)</span> <span class="c1"># if no writer is waiting
</span>    <span class="n">V</span><span class="p">(</span><span class="n">turnstile</span><span class="p">)</span>
    <span class="n">readSwitch</span><span class="p">.</span><span class="n">lock</span><span class="p">(</span><span class="n">roomEmpty</span><span class="p">)</span>
    	<span class="c1"># critical sections for readers
</span>    <span class="n">readSwitch</span><span class="p">.</span><span class="n">unlock</span><span class="p">(</span><span class="n">roomEmpty</span><span class="p">)</span> <span class="c1"># unblocking the waiting writer
</span></code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># writer-priority readers-writers hint, possible for readers to starve
</span><span class="n">readSwitch</span> <span class="o">=</span> <span class="n">Lightswitch</span><span class="p">()</span>
<span class="n">writeSwitch</span> <span class="o">=</span> <span class="n">Lightswitch</span><span class="p">()</span>
<span class="n">noReaders</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">noWriters</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">noReaders</span><span class="p">)</span>
    <span class="n">readSwitch</span><span class="p">.</span><span class="n">lock</span><span class="p">(</span><span class="n">noWriters</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">noReaders</span><span class="p">)</span>
    <span class="c1"># critical section for readers
</span>    <span class="n">readSwitch</span><span class="p">.</span><span class="n">unlock</span><span class="p">(</span><span class="n">noWriters</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">writer</span><span class="p">():</span> <span class="c1"># when a writer is in the critical section it holds both noReaders and noWriters
</span>    <span class="n">writerSwitch</span><span class="p">.</span><span class="n">lock</span><span class="p">(</span><span class="n">noReaders</span><span class="p">)</span> <span class="c1"># allowing multiple writers to queue on noWriters, but keeping noReaders locked while they are there
</span>    <span class="n">P</span><span class="p">(</span><span class="n">noWriters</span><span class="p">)</span>
    <span class="c1"># critical section for writers
</span>    <span class="n">V</span><span class="p">(</span><span class="n">noWriters</span><span class="p">)</span>
    <span class="n">writeSwitch</span><span class="p">.</span><span class="n">unlock</span><span class="p">(</span><span class="n">noReaders</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># no-starve mutex hint &lt;Morris's algorithm&gt;
</span><span class="n">room1</span> <span class="o">=</span> <span class="n">room2</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># how many threads are in the waiting rooms
</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># help protect the counters
</span><span class="n">t1</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># turnstile
</span><span class="n">t2</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># turnstile
</span>
<span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
	<span class="n">room1</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>

<span class="n">P</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
	<span class="n">room2</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">room1</span> <span class="o">-=</span> <span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">room1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="n">V</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="n">V</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
        
<span class="n">P</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
	<span class="n">room2</span> <span class="o">-=</span> <span class="mi">1</span>
     <span class="c1"># critical section
</span>    <span class="k">if</span> <span class="n">room2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="哲学家进餐问题-dining-philosophers">哲学家进餐问题 (Dining Philosophers)</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Dining Philosophers hint #1
</span><span class="n">footman</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># if only four philosophers are allowed at the table at a time
</span>
<span class="k">def</span> <span class="nf">get_forks</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="n">P</span><span class="p">(</span><span class="n">footman</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">fork</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
    <span class="n">P</span><span class="p">(</span><span class="n">fork</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
    
<span class="k">def</span> <span class="nf">put_forks</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="n">V</span><span class="p">(</span><span class="n">fork</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
    <span class="n">V</span><span class="p">(</span><span class="n">fork</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
    <span class="n">V</span><span class="p">(</span><span class="n">footman</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">philosopher</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">think</span><span class="p">()</span>
        <span class="n">get_forks</span><span class="p">()</span>
        <span class="n">eat</span><span class="p">()</span>
        <span class="n">put_forks</span><span class="p">()</span>
        
<span class="n">Cobegin</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">philosopher</span><span class="p">()</span>
<span class="n">Coend</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Dining Philosophers hint #2
# deadlock is impossible if there's at least one leftie and at least one rightie at the table
</span></code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Dining Philosophers hint #3
# Tanenbaum's solution, could cause starvation
</span><span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="s">'thinking'</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span> <span class="c1"># the state of the five philosophers
</span><span class="n">sem</span> <span class="o">=</span> <span class="p">[</span><span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_fork</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"hungry"</span>
    <span class="n">test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">sem</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
<span class="k">def</span> <span class="nf">put_fork</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"thinking"</span>
    <span class="n">test</span><span class="p">(</span><span class="n">right</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">test</span><span class="p">(</span><span class="n">left</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="c1"># can start eating if i is hungry and neither of his neighbors are eating
</span>    <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">"hungry"</span> <span class="ow">and</span> <span class="n">state</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">!=</span> <span class="s">"eating"</span> <span class="ow">and</span> <span class="n">state</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">!=</span> <span class="s">"eating"</span><span class="p">:</span>
        <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"eating"</span>
        <span class="n">V</span><span class="p">(</span><span class="n">sem</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</code></pre></div></div>

<h4 id="cigarette-smokers-problem">Cigarette smokers problem</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Agent semaphores
</span><span class="n">agentSem</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">isTobacco</span> <span class="o">=</span> <span class="n">isPaper</span> <span class="o">=</span> <span class="n">isMatch</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">tobaccoSem</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">paperSem</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">matchSem</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># only some of the code is shown below
</span><span class="k">def</span> <span class="nf">PusherA</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">agentSem</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">tobacco</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="k">if</span> <span class="n">isPaper</span><span class="p">:</span>
            <span class="n">isPaper</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">V</span><span class="p">(</span><span class="n">matchSem</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">isMatch</span><span class="p">:</span>
            <span class="n">isMatch</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">V</span><span class="p">(</span><span class="n">paperSem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isTobacco</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">smokerWithTobacco</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">tobaccoSem</span><span class="p">)</span>
    <span class="n">makeCigarette</span><span class="p">()</span>
    <span class="n">V</span><span class="p">(</span><span class="n">agentSem</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="the-dining-savages-problem">The Dining Savages Problem</h4>

<blockquote>
  <p>A tribe of savages eats communal dinners from a large pot that can hold M servings of stewed missionary1. When a savage wants to eat, he helps himself from the pot, unless it is empty. If the pot is empty, the savage wakes up the cook and then waits until the cook has refilled the pot.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># protect the counter 'servings'
</span><span class="n">servings</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># number of servings
</span><span class="n">empty</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">full</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">savages</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
	    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="k">if</span> <span class="n">servings</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># no servings in pot
</span>        	<span class="n">P</span><span class="p">(</span><span class="n">full</span><span class="p">)</span>
	        <span class="n">servings</span> <span class="o">=</span> <span class="n">M</span>
    	    <span class="n">V</span><span class="p">(</span><span class="n">empty</span><span class="p">)</span>
	    <span class="c1"># still servings in pot
</span>	    <span class="n">servings</span><span class="o">--</span>
    	<span class="n">getServingsFromPot</span><span class="p">()</span>
	    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cook</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
	    <span class="n">P</span><span class="p">(</span><span class="n">empty</span><span class="p">)</span>
	    <span class="n">putServingsInPot</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    	<span class="n">V</span><span class="p">(</span><span class="n">full</span><span class="p">)</span>
        
<span class="n">Cobegin</span>
	<span class="n">cook</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numOfSavages</span><span class="p">):</span>
        <span class="n">savages</span><span class="p">()</span>
<span class="n">Coend</span>
</code></pre></div></div>

<h4 id="the-barbershop-problem">The Barbershop Problem</h4>

<blockquote>
  <p>A barbershop consists of a waiting room with n chairs, and the barber room containing the barber chair. If there are no customers to be served, the barber goes to sleep. If a customer enters the barbershop and all chairs are occupied, then the customer leaves the shop. If the barber is busy, but chairs are available, then the customer sits in one of the free chairs. If the barber is asleep, the customer wakes up the barber. Write a program to coordinate the barber and the customers.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">customerNum</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># the number of consumer in the shop
</span><span class="n">customer</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">barber</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">custermerDone</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">barberDone</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">consumer</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">customerNum</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="n">leaveTheShop</span><span class="p">()</span> <span class="c1"># leave the shop
</span>        <span class="k">return</span>
    <span class="n">customer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
    <span class="n">V</span><span class="p">(</span><span class="n">customer</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">barber</span><span class="p">)</span>
    <span class="n">getHairCut</span><span class="p">()</span> <span class="c1"># get hair cut
</span>    <span class="n">V</span><span class="p">(</span><span class="n">consumerDone</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">barberDone</span><span class="p">)</span>
    
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">customerNum</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">barber</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">customer</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">barber</span><span class="p">)</span>
    <span class="n">cutHair</span><span class="p">()</span> <span class="c1"># cut hair
</span>    <span class="n">P</span><span class="p">(</span><span class="n">customerDone</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">barberDone</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="the-fifo-barbershop-problem">The FIFO Barbershop Problem</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># serve the customer base on FIFO rule
</span><span class="n">customerNum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">customer</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">customerDone</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">barberDone</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">consumer</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">customerNum</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="n">leaveTheShop</span><span class="p">()</span> <span class="c1"># leave the shop
</span>        <span class="k">return</span>
    <span class="n">customer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">sem</span><span class="p">)</span> <span class="c1"># append the Semaphore of the consumer himself
</span>    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
    <span class="n">V</span><span class="p">(</span><span class="n">customer</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">sem</span><span class="p">)</span>
    <span class="n">getHairCut</span><span class="p">()</span> <span class="c1"># get hair cut
</span>    <span class="n">V</span><span class="p">(</span><span class="n">consumerDone</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">barberDone</span><span class="p">)</span>
    
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">customerNum</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">barber</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">customer</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">sem</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
    <span class="n">V</span><span class="p">(</span><span class="n">sem</span><span class="p">)</span>
    
    <span class="n">V</span><span class="p">(</span><span class="n">barber</span><span class="p">)</span>
    <span class="n">cutHair</span><span class="p">()</span> <span class="c1"># cut hair
</span>    <span class="n">P</span><span class="p">(</span><span class="n">customerDone</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">barberDone</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="hilzers-barbershop-problem">Hilzer’s Barbershop Problem</h4>

<blockquote>
  <p>Our barbershop has three chairs, three barbers, and a waiting area that can accommodate four customers on a sofa and that has standing room for additional customers. Fire codes limit the total number of customers in the shop to 20.</p>

  <p>A customer will not enter the shop if it is filled to capacity with other customers. Once inside, the customer takes a seat on the sofa or stands if the sofa is filled. When a barber is free, the customer that has been on the sofa the longest is served and, if there are any standing customers, the one that has been in the shop the longest takes a seat on the sofa. When a customer’s haircut is finished, any barber can accept payment, but because there is only one cash register, payment is accepted for one customer at a time. The barbers divide their time among cutting hair, accepting payment, and sleeping in their chair waiting for a customer.</p>
</blockquote>

<h4 id="the-santa-claus-problem">The Santa Claus Problem</h4>

<blockquote>
  <p>Stand Claus sleeps in his shop at the North Pole and can only be awakened by either (1) all nine reindeer being back from their vacation in the South Pacific, or (2) some of the elves having difficulty making toys; to allow Santa to get some sleep, the elves can only wake him when three of them have problems. When three elves are having their problems solved, any other elves wishing to visit Santa must wait for those elves to return. If Santa wakes up to find three elves waiting at his shop’s door, along with the last reindeer having come back from the tropics, Santa has decided that the elves can wait until after Christmas, because it is more important to get his sleigh ready. (It is assumed that the reindeer do not want to leave the tropics, and therefore they stay there until the last possible moment.) The last reindeer to arrive must get Santa while the others wait in a warming hut before being harnessed to the sleigh.</p>

  <p>Here are some addition specifications:</p>

  <p>• After the ninth reindeer arrives, Santa must invoke <code class="language-plaintext highlighter-rouge">prepareSleigh</code>, and then all nine reindeer must invoke <code class="language-plaintext highlighter-rouge">getHitched</code>. 
• After the third elf arrives, Santa must invoke <code class="language-plaintext highlighter-rouge">helpElves</code>. Concurrently, all three elves should invoke <code class="language-plaintext highlighter-rouge">getHelp</code>. 
• All three elves must invoke <code class="language-plaintext highlighter-rouge">getHelp</code> before any additional elves enter (increment the elf counter).</p>

  <p>Santa should run in a loop so he can help many sets of elves. We can assume that there are exactly 9 reindeer, but there may be any number of elves.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">elves</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># counter
</span><span class="n">reindeer</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># counter
</span><span class="n">santaSem</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># santa waits on santaSem until the elves or reindeer wakes him
</span><span class="n">reindeerSem</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># the reindeer wait on reindeerSem umtil Santa signals them to get hitched
</span><span class="n">elfTex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># the elves ise elfTex to prevent additional elves from entering while three elves are being helped
</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># protect elves &amp; reindeer
</span>
<span class="k">def</span> <span class="nf">santa</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">santaSem</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="k">if</span> <span class="n">reindeer</span> <span class="o">&gt;=</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">reindeer</span> <span class="o">-=</span> <span class="mi">9</span>
            <span class="n">prepareSleigh</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span> <span class="c1"># reindeerSem.signal(9)
</span>                <span class="n">V</span><span class="p">(</span><span class="n">reindeerSem</span><span class="p">)</span>
         <span class="k">elif</span> <span class="n">elvs</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># elves needs help
</span>            <span class="n">helpElves</span><span class="p">()</span>
     <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
            
<span class="k">def</span> <span class="nf">reindeer</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">reindeer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">reindeer</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">santaSem</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
    <span class="n">P</span><span class="p">(</span><span class="n">reindeerSem</span><span class="p">)</span>
    <span class="n">getHitched</span><span class="p">()</span>
    
<span class="k">def</span> <span class="nf">elves</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">elfTex</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="n">elves</span> <span class="o">+=</span> <span class="mi">1</span>
    	<span class="k">if</span> <span class="n">elves</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">santaSem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">elfTex</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
    <span class="n">getHelp</span><span class="p">()</span>
    
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="n">elves</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">elves</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">elfTex</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="building-h2o">Building H2O</h4>

<blockquote>
  <p>There are two kinds of threads, oxygen and hydrogen. In order to assemble these threads into water molecules, we have to create a barrier that makes each thread wait until a complete molecule is ready to proceed. As each thread passes the barrier, it should invoke bond. You must guarantee that all the threads from one molecule invoke bond before any of the threads from the next molecule do.
In other words:
• If an oxygen thread arrives at the barrier when no hydrogen threads are present, it has to wait for two hydrogen threads.
• If a hydrogen thread arrives at the barrier when no other threads are present, it has to wait for an oxygen thread and another hydrogen thread.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Ocount</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Hcount</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">OCanBond</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">HCanBond</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Oxygen</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="n">Ocount</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">Hcount</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">Hcount</span> <span class="o">-=</span> <span class="mi">2</span>
            <span class="n">bond</span><span class="p">()</span>
            <span class="n">HCanBond</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
            <span class="n">P</span><span class="p">(</span><span class="n">OCanBond</span><span class="p">)</span>
            <span class="n">bond</span><span class="p">()</span>
    
<span class="k">def</span> <span class="nf">Hydrogen</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="n">Hcount</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">Ocount</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">Hcount</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">bond</span><span class="p">()</span>
            <span class="n">V</span><span class="p">(</span><span class="n">OCanBond</span><span class="p">)</span>
            <span class="n">V</span><span class="p">(</span><span class="n">HCanBond</span><span class="p">)</span>
            <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
            <span class="n">P</span><span class="p">(</span><span class="n">HCanBound</span><span class="p">)</span>
            <span class="n">bond</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="river-crossing-problem">River Crossing Problem</h4>

<blockquote>
  <p>Somewhere near Redmond, Washington there is a rowboat that is used by both Linux hackers and Microsoft employees (serfs) to cross a river. The ferry can hold exactly four people; it won’t leave the shore with more or fewer. To guarantee the safety of the passengers, it is not permissible to put one hacker in the boat with three serfs, or to put one serf with three hackers. Any other combination is safe.
As each thread boards the boat it should invoke a function called <code class="language-plaintext highlighter-rouge">board</code>. You must guarantee that all four threads from each boatload invoke board before any of the threads from the next boatload do. After all four threads have invoked board, exactly one of them should call a function named <code class="language-plaintext highlighter-rouge">rowBoat</code>, indicating that that thread will take the oars. It doesn’t matter which thread calls the function, as long as one does.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">barrier</span> <span class="o">=</span> <span class="n">Barrier</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">hackers</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># the number of hackers waiting to board
</span><span class="n">serfs</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># the number of servers waiting to board
</span><span class="n">hackerQueue</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">serfQueue</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">local</span> <span class="n">isCaptain</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">hacker</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
	<span class="n">hackers</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">hackers</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">board</span><span class="p">()</span>
        <span class="n">hackerQueue</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">rowBoat</span><span class="p">()</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">hackers</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">serfs</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">board</span><span class="p">()</span>
        <span class="n">hackerQueue</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">serfQueue</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">rowBoat</span><span class="p">()</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="n">P</span><span class="p">(</span><span class="n">hackerQueue</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">serf</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">serfs</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">serfs</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">board</span><span class="p">()</span>
        <span class="n">serfQueue</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">rowBoat</span><span class="p">()</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">hackers</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">serf</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">board</span><span class="p">()</span>
        <span class="n">hackerQueue</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">serfQueue</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rowBoat</span><span class="p">()</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="n">P</span><span class="p">(</span><span class="n">serfQueue</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="the-roller-coaster-problem">The Roller Coaster Problem</h4>

<blockquote>
  <p>Suppose there are n passenger threads and a car thread. The passengers repeatedly wait to take rides in the car, which can hold C passengers, where C &lt; n. The car can go around the tracks only when it is full.
Here are some additional details:
• Passengers should invoke <code class="language-plaintext highlighter-rouge">board</code> and <code class="language-plaintext highlighter-rouge">unboard</code>. 
• The car should invoke <code class="language-plaintext highlighter-rouge">load</code>, <code class="language-plaintext highlighter-rouge">run</code> and <code class="language-plaintext highlighter-rouge">unload</code>. 
• Passengers cannot <code class="language-plaintext highlighter-rouge">board</code> until the car has invoked <code class="language-plaintext highlighter-rouge">load</code>
• The car cannot <code class="language-plaintext highlighter-rouge">depart</code> until C passengers have <code class="language-plaintext highlighter-rouge">boarded</code>.
• Passengers cannot <code class="language-plaintext highlighter-rouge">unboard</code> until the car has invoked <code class="language-plaintext highlighter-rouge">unload</code>.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mutex2</span> <span class="o">=</span> <span class="n">Semaphore</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">boarders</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">unboarders</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">boardQueue</span> <span class="o">=</span> <span class="n">Semaphore</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">unboardQueue</span> <span class="o">=</span> <span class="n">Semaphore</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">allAboard</span> <span class="o">=</span> <span class="n">Semaphore</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">allAshore</span> <span class="o">=</span> <span class="n">Semaphore</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">car</span><span class="p">():</span>
    <span class="n">load</span><span class="p">()</span>
    <span class="n">boardQueue</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">allAboard</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
    
    <span class="n">run</span><span class="p">()</span>
    
    <span class="n">unload</span><span class="p">()</span>
    <span class="n">unboardQueue</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">allAshore</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
    
<span class="k">def</span> <span class="nf">passenger</span><span class="p">():</span>
    <span class="n">boardQueue</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="n">board</span><span class="p">()</span>
    
    <span class="n">mutex</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
    	<span class="n">boarders</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">boarders</span> <span class="o">==</span> <span class="n">C</span><span class="p">:</span>
            <span class="n">allAboard</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span>
            <span class="n">boarders</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mutex</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span>
    
    <span class="n">unboardQueue</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="n">unboard</span><span class="p">()</span>
    
    <span class="n">mutex2</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
    	<span class="n">unboarders</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">unboarders</span> <span class="o">==</span> <span class="n">C</span><span class="p">:</span>
            <span class="n">allAshore</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span>
            <span class="n">unboarders</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mutex2</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="the-search-insert-delete-problem">The Search-Insert-Delete Problem</h4>

<blockquote>
  <p>Three kinds of threads share access to a singly-linked list: searchers, inserters and deleters. Searchers merely examine the list; hence they can execute concurrently with each other. Inserters add new items to the end of the list; insertions must be mutually exclusive to preclude two inserters from inserting new items at about the same time. However, one insert can proceed in parallel with any number of searches. Finally, deleters remove items from anywhere in the list. At most one deleter process can access the list at a time, and deletion must also be mutually exclusive with searches and insertions.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">searcher</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># number of searchers
</span><span class="n">inserter</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># number of inserters
</span><span class="n">searcherMutex</span> <span class="o">=</span> <span class="n">semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">inserterMutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">noSearcher</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">noInserter</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">search</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">searcherMutex</span><span class="p">)</span>
	    <span class="n">searcher</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">searcher</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># the first searcher
</span>            <span class="n">P</span><span class="p">(</span><span class="n">noSearcher</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">searcherMutex</span><span class="p">)</span>
    <span class="c1"># critical section
</span>    <span class="n">P</span><span class="p">(</span><span class="n">searcherMutex</span><span class="p">)</span>
    	<span class="n">searcher</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">searcher</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># the last searcher
</span>            <span class="n">V</span><span class="p">(</span><span class="n">noSearcher</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">searcherMutex</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">insert</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">noInserter</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">inserterMutex</span><span class="p">)</span>
    <span class="c1"># critical section
</span>    <span class="n">V</span><span class="p">(</span><span class="n">inserterMutex</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">noInserter</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">delete</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">noSearcher</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">noInserter</span><span class="p">)</span>
    <span class="c1"># critical section
</span>    <span class="n">V</span><span class="p">(</span><span class="n">noInserter</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">noSearcher</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="the-unisex-bathroom-problem">The Unisex Bathroom Problem</h4>

<blockquote>
  <p>• There cannot be men and women in the bathroom at the same time.</p>

  <p>• There should never be more than three employees squandering company time in the bathroom.</p>
</blockquote>

<h4 id="baboon-crossing-problem">Baboon Crossing Problem</h4>

<h4 id="the-modus-hall-problem">The Modus Hall Problem</h4>

<blockquote>
  <p>After a particularly heavy snowfall this winter, the denizens of Modus Hall created a trench-like path between their cardboard shantytown and the rest of campus. Every day some of the residents walk to and from class, food and civilization via the path; we will ignore the indolent students who chose daily to drive to Tier 3. We will also ignore the direction in which pedestrians are traveling. For some unknown reason, students living in West Hall would occasionally find it necessary to venture to the Mods.
Unfortunately, the path is not wide enough to allow two people to walk side-by-side. If two Mods persons meet at some point on the path, one will gladly step aside into the neck high drift to accommodate the other. A similar situation will occur if two ResHall inhabitants cross paths. If a Mods heathen and a ResHall prude meet, however, a violent skirmish will ensue with the victors determined solely by strength of numbers; that is, the faction with the larger population will force the other to wait.</p>
</blockquote>

<h4 id="the-sushi-bar-problem">The Sushi Bar Problem</h4>

<blockquote>
  <p>Imagine a sushi bar with 5 seats. If you arrive while there is an empty seat, you can take a seat immediately. But if you arrive when all 5 seats are full, that means that all of them are dining together, and you will have to wait for the entire party to leave before you sit down.</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">seat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">seat</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">seat</span><span class="o">++</span><span class="p">;</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">seat</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        	<span class="n">P</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
            <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// all seats are taken</span>
        <span class="n">P</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
        <span class="n">seat</span><span class="o">++</span><span class="p">;</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">eat</span><span class="p">();</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">seat</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">seat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">V</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eating</span> <span class="o">=</span> <span class="n">waiting</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># the number of threads sitting at the bar and waiting
</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># protects eating and waiting and must_wait
</span><span class="n">block</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">must_wait</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># indicates that the bar is (has been) full
</span>
<span class="c1"># first possible solution
</span><span class="k">def</span> <span class="nf">consumer1</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">must_wait</span><span class="p">:</span>
        <span class="n">waiting</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="n">P</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eating</span> <span class="o">+=</span> <span class="mi">1</span>
	    <span class="n">must_wait</span> <span class="o">=</span> <span class="p">(</span><span class="n">eating</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
    	<span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
    <span class="c1"># eat sushi
</span>    
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">eating</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">eating</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">waiting</span><span class="p">)</span>
        <span class="n">waiting</span> <span class="o">-=</span> <span class="n">n</span>
        <span class="n">eating</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="n">must_wait</span> <span class="o">=</span> <span class="p">(</span><span class="n">eating</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">V</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
<span class="c1"># another possible solution
</span><span class="k">def</span> <span class="nf">consumer2</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">must_wait</span><span class="p">:</span>
        <span class="n">waiting</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="n">P</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">wating</span> <span class="o">-=</span> <span class="mi">1</span>
    
    <span class="n">eating</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">must_wait</span> <span class="o">=</span> <span class="p">(</span><span class="n">eating</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">waiting</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">must_wait</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        
    <span class="c1"># eat sushi
</span>    
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">eating</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">eating</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">must_wait</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">waiting</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">must_wait</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="c1"># and pass the mutex
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="the-child-care-problem">The Child Care Problem</h4>

<blockquote>
  <p>At a child care center, state regulations require that there is always one adult present for every three children.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">multiplex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># counts the number of tokens available
</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">adult</span><span class="p">():</span>
    <span class="n">multiplex</span><span class="p">.</span><span class="n">signal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># critical section
</span>    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
	    <span class="n">P</span><span class="p">(</span><span class="n">multiplex</span><span class="p">)</span>
    	<span class="n">P</span><span class="p">(</span><span class="n">multiplex</span><span class="p">)</span>
	    <span class="n">P</span><span class="p">(</span><span class="n">multiplex</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="the-room-party-problem">The Room Party Problem</h4>

<blockquote>
  <p>The following synchronization constraints apply to students and the Dean of Students:</p>

  <ol>
    <li>
      <p>Any number of students can be in a room at the same time.</p>
    </li>
    <li>
      <p>The Dean of Students can only enter a room if there are no students in the room (to conduct a search) or if there are more than 50 students in the room (to break up the party).</p>
    </li>
    <li>
      <p>While the Dean of Students is in the room, no additional students may enter, but students may leave.</p>
    </li>
    <li>
      <p>The Dean of Students may not leave the room until all students have left.</p>
    </li>
    <li>
      <p>There is only one Dean of Students, so you do not have to enforce exclusion among multiple deans.</p>
    </li>
  </ol>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># meaningless
</span><span class="n">student</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">status</span> <span class="o">=</span> <span class="s">"waiting"</span> <span class="c1"># status of the dean
</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dean</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">noDean</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">leave</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dean</span><span class="p">():</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s">"waiting"</span>
    <span class="n">P</span><span class="p">(</span><span class="n">dean</span><span class="p">)</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s">"inside"</span>
    <span class="c1"># enter the room
</span>    <span class="n">P</span><span class="p">(</span><span class="n">leave</span><span class="p">)</span>
    <span class="c1"># leave the room
</span>    <span class="n">V</span><span class="p">(</span><span class="n">noDean</span><span class="p">)</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s">"waiting"</span>
    
<span class="k">def</span> <span class="nf">student</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">noDean</span><span class="p">)</span> <span class="c1"># if dean is in the room, the student cannot enter
</span>    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">student</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">student</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">P</span><span class="p">(</span><span class="n">dean</span><span class="p">)</span> <span class="c1"># dean cannot enter the room if students (1 &lt;= x &lt;= 50) in the room
</span>    <span class="k">elif</span> <span class="n">student</span> <span class="o">==</span> <span class="mi">51</span><span class="p">:</span> <span class="c1"># more than 50 student in room
</span>        <span class="n">V</span><span class="p">(</span><span class="n">dean</span><span class="p">)</span> <span class="c1"># dean can enter
</span>    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="c1"># student hang out
</span>    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">student</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">student</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">leave</span><span class="p">)</span>
        <span class="n">V</span><span class="p">(</span><span class="n">dean</span><span class="p">)</span> <span class="c1"># dean can enter the room if it is empty
</span>    <span class="k">elif</span> <span class="n">student</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="p">:</span>
        <span class="n">P</span><span class="p">(</span><span class="n">dean</span><span class="p">)</span> <span class="c1"># dean cannot enter the room if it has less than 50 people
</span>    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">students</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># number of students in the room
</span><span class="n">dean</span> <span class="o">=</span> <span class="s">"not here"</span> <span class="c1"># the status of the dean
</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># protect student and dean
</span><span class="n">turn</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># turnstile that keeps students from entering while the Dean is in the room
</span><span class="n">clear</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> 
<span class="n">lieIn</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># clean and lieIn are used as rendezvouses between a student and the Dean
</span>
<span class="k">def</span> <span class="nf">Dean</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="k">if</span> <span class="n">students</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">students</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>
            <span class="n">dean</span> <span class="o">=</span> <span class="s">"waiting"</span>
            <span class="n">P</span><span class="p">(</span><span class="n">lieIn</span><span class="p">)</span> <span class="c1"># get mutex from the student
</span>        <span class="c1"># students must be 0 or &gt;= 50
</span>        <span class="k">if</span> <span class="n">students</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
            <span class="n">dean</span> <span class="o">=</span> <span class="s">"in the room"</span>
            <span class="n">breakup</span><span class="p">()</span> <span class="c1"># break up the party
</span>            <span class="n">P</span><span class="p">(</span><span class="n">turn</span><span class="p">)</span> <span class="c1"># lock the turnstile
</span>            <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
            <span class="n">P</span><span class="p">(</span><span class="n">clear</span><span class="p">)</span> <span class="c1"># get mutex from the student
</span>            <span class="n">V</span><span class="p">(</span><span class="n">turn</span><span class="p">)</span> <span class="c1"># unlock the turnstile
</span>        <span class="k">else</span><span class="p">:</span> <span class="c1"># student === 0
</span>            <span class="n">search</span><span class="p">()</span>
    <span class="n">dean</span> <span class="o">=</span> <span class="s">"not here"</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">student</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="k">if</span> <span class="n">dean</span> <span class="o">==</span> <span class="s">"in the room"</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span> <span class="c1"># cannot enter the room if dean is there
</span>            <span class="n">P</span><span class="p">(</span><span class="n">turn</span><span class="p">)</span>
            <span class="n">V</span><span class="p">(</span><span class="n">turn</span><span class="p">)</span>
            <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="n">students</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">students</span> <span class="o">==</span> <span class="mi">50</span> <span class="ow">and</span> <span class="n">dean</span> <span class="o">==</span> <span class="s">"waiting"</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">lieIn</span><span class="p">)</span> <span class="c1"># pass mutex to the dean
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">party</span><span class="p">()</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="n">students</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">students</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dean</span> <span class="o">==</span> <span class="s">"waiting"</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">lieIn</span><span class="p">)</span> <span class="c1"># pass mutex to the dean
</span>        <span class="k">elif</span> <span class="n">students</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dean</span> <span class="o">==</span> <span class="s">"in the room"</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">clear</span><span class="p">)</span> <span class="c1"># pass mutex to the dean
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="the-senate-bus-problem">The Senate Bus Problem</h4>

<blockquote>
  <p>Riders come to a bus stop and wait for a bus. When the bus arrives, all the waiting riders invoke <code class="language-plaintext highlighter-rouge">boardBus</code>, but anyone who arrives while the bus is boarding has to wait for the next bus. The capacity of the bus is 50 people; if there are more than 50 people waiting, some will have to wait for the next bus.
When all the waiting riders have boarded, the bus can invoke <code class="language-plaintext highlighter-rouge">depart</code>. If the bus arrives when there are no riders, it should depart immediately.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># error
</span><span class="n">waitingQueue</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">getIn</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">arrive</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bus</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">arrive</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="k">if</span> <span class="n">waitingQueue</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># nobody is waiting
</span>            <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="n">waitingQueue</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">V</span><span class="p">(</span><span class="n">getIn</span><span class="p">)</span>
        <span class="n">depart</span><span class="p">()</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">arrive</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">passenger</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="n">waitingQueue</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">arrive</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">arrive</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">getIn</span><span class="p">)</span>
    <span class="n">boardBus</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># solution 1
</span><span class="n">riders</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># how many riders are waiting
</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># protects riders
</span><span class="n">multiplex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="c1"># make sure there are no more than 50 riders in the boarding area
</span><span class="n">bus</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># riders wait on bus
</span><span class="n">allAboard</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># bus wait on allAboard
</span>
<span class="k">def</span> <span class="nf">bus</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">riders</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="c1"># pass the mutex
</span>        <span class="n">P</span><span class="p">(</span><span class="n">allAboard</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">depart</span><span class="p">()</span>
    
<span class="k">def</span> <span class="nf">riders</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">multiplex</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span> <span class="c1"># cannot enter if the bus arrives
</span>    	<span class="n">riders</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="c1"># get the mutex
</span>    <span class="n">V</span><span class="p">(</span><span class="n">multiplex</span><span class="p">)</span>
    <span class="n">boardBus</span><span class="p">()</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">riders</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">riders</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">allAboard</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="c1"># pass the mutex
</span>    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># solution 2
</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># the number of riders in the boarding area
</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># protect waiting
</span><span class="n">bus</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># signals when the bus has arrived
</span><span class="n">boarded</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># signals that a rider has boarded
</span>
<span class="k">def</span> <span class="nf">bus</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">waiting</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">V</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span>
        <span class="n">P</span><span class="p">(</span><span class="n">boarded</span><span class="p">)</span>
    <span class="n">waiting</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">waiting</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">depart</span><span class="p">()</span>
    
<span class="k">def</span> <span class="nf">rider</span><span class="p">():</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">waiting</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">P</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span>
    <span class="n">boardBus</span><span class="p">()</span>
    <span class="n">V</span><span class="p">(</span><span class="n">boarded</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="the-faneuil-hall-problem">The Faneuil Hall Problem</h4>

<blockquote>
  <p>There are three kinds of threads: immigrants, spectators, and a one judge. Immigrants must wait in line, check in, and then sit down. At some point, the judge enters the building. When the judge is in the building, no one may enter, and the immigrants may not leave. Spectators may leave. Once all immigrants check in, the judge can confirm the naturalization. After the confirmation, the immigrants pick up their certificates of U.S. Citizenship. The judge leaves at some point after the confirmation. Spectators may now enter as before. After immigrants get their certificates, they may leave.</p>

  <p>To make these requirements more specific, let’s give the threads some functions to execute, and put constraints on those functions.
• Immigrants must invoke <code class="language-plaintext highlighter-rouge">enter</code>, <code class="language-plaintext highlighter-rouge">checkIn</code>, <code class="language-plaintext highlighter-rouge">sitDown</code>, <code class="language-plaintext highlighter-rouge">swear</code>, <code class="language-plaintext highlighter-rouge">getCertificate</code> and <code class="language-plaintext highlighter-rouge">leave</code>. 
• The judge invokes <code class="language-plaintext highlighter-rouge">enter</code>, <code class="language-plaintext highlighter-rouge">confirm</code> and <code class="language-plaintext highlighter-rouge">leave</code>. 
• Spectators invoke <code class="language-plaintext highlighter-rouge">enter</code>, <code class="language-plaintext highlighter-rouge">spectate</code> and <code class="language-plaintext highlighter-rouge">leave</code>. 
• While the judge is in the building, no one may enter and immigrants may not leave. 
• The judge can not confirm until all immigrants who have invoked enter have also invoked <code class="language-plaintext highlighter-rouge">checkIn</code>. 
• Immigrants can not <code class="language-plaintext highlighter-rouge">getCertificate</code> until the judge has executed <code class="language-plaintext highlighter-rouge">confirm</code>.</p>
</blockquote>

<h4 id="dining-hall-problem">Dining Hall Problem</h4>

<blockquote>
  <p>Students in the dining hall invoke <code class="language-plaintext highlighter-rouge">dine</code> and then <code class="language-plaintext highlighter-rouge">leave</code>. After invoking <code class="language-plaintext highlighter-rouge">dine</code> and before invoking <code class="language-plaintext highlighter-rouge">leave</code> a student is considered “ready to leave”.
The synchronization constraint that applies to students is that, in order to maintain the illusion of social suave, a student <strong>may never sit at a table alone.</strong> A student is considered to be sitting alone if everyone else who has invoked dine invokes leave before she has finished dine.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eating</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">readyToLeave</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">mutex</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">okToLeave</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">student</span><span class="p">():</span>
    <span class="n">getFood</span><span class="p">()</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    	<span class="n">eating</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">eating</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">readyToleave</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">V</span><span class="p">(</span><span class="n">okToLeave</span><span class="p">)</span>
            <span class="n">readyToLeave</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">dine</span><span class="p">()</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">eating</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">readyToLeave</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">eating</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">readyToLeave</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="n">P</span><span class="p">(</span><span class="n">okToLeave</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">eating</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">readyToLeave</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">V</span><span class="p">(</span><span class="n">okToLeave</span><span class="p">)</span>
        <span class="n">readyToLeave</span> <span class="o">-=</span> <span class="mi">2</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">readyToLeave</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">leave</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="基本概念-4">基本概念</h3>

<h4 id="调度">调度</h4>

<p>CPU 调度的任务是控制、协调多个进程对 CPU 的竞争。也就是按照一定的策略，从就绪队列中选择一个进程，并把 CPU 控制权交给被选中的进程。</p>

<h3 id="要考虑的问题">要考虑的问题</h3>

<ul>
  <li><strong>WHAT</strong>: 按照什么原则选择下一个要执行的进程——进程调度算法</li>
  <li><strong>WHEN</strong>: 何时分配 CPU ——进程调度时机</li>
  <li><strong>HOW</strong>: 如何分配 CPU ——CPU 切换过程</li>
</ul>

<h3 id="调度类型">==调度类型==</h3>

<h4 id="高级调度">高级调度</h4>

<blockquote>
  <p>又称为 <strong>宏观调度</strong>，<strong>作业调度</strong>。从<strong>用户工作流程</strong>的角度，一次提交的如若干个作业，对每个作业进行调度。</p>
</blockquote>

<h4 id="中级调度">中级调度</h4>

<blockquote>
  <p>又称为 <strong>内外存切换</strong>。从<strong>存储器资源</strong>的角度，将进程的部分或全部换出到外存上，将当前所需部分换入内存。指令和数据必须在内存里才能被 CPU 直接访问。</p>
</blockquote>

<h4 id="低级调度">低级调度</h4>

<blockquote>
  <p>又称为 <strong>微观调度</strong>，<strong>进程或线程调度</strong>。从 <strong>CPU 资源</strong>的角度，执行的单位，时间上通常为毫秒。</p>
</blockquote>

<ul>
  <li>非抢占式</li>
  <li>抢占式
    <ul>
      <li>时间片原则</li>
      <li>优先权原则</li>
      <li>短作业（进程）优先</li>
    </ul>
  </li>
</ul>

<h3 id="cpu-三级调度">CPU 三级调度</h3>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202105/2324053-20210531220906682-1320796306.png" alt="image" /></p>

<h3 id="调度的性能准则">==调度的性能准则==</h3>

<h4 id="周转时间批处理系统">周转时间——批处理系统</h4>

<p>作业从提交到完成（得到结果）所经历的时间。</p>

<p>包括：</p>

<ul>
  <li>在收容队列里等待</li>
  <li>在 CPU 上执行</li>
  <li>在就绪队列和阻塞队列中等待</li>
  <li>结果输出等待</li>
</ul>

<h5 id="平均周转时间">平均周转时间</h5>

<h5 id="带权周转时间">带权周转时间</h5>

<h5 id="外存等待时间">外存等待时间</h5>

<h5 id="就绪等待时间">就绪等待时间</h5>

<h5 id="cpu-执行时间">CPU 执行时间</h5>

<h5 id="io-操作时间">I/O 操作时间</h5>

<h4 id="响应时间分时系统">响应时间——分时系统</h4>

<p>用户输入一个请求到系统首次做出响应的时间</p>

<h4 id="截止时间实时系统">截止时间——实时系统</h4>

<p>开始截止时间和完成截止时间</p>

<h4 id="优先级">优先级</h4>

<p>可以使关键任务达到更好的指标</p>

<h4 id="公平性">公平性</h4>

<p>不因作业或进程本身的特性而使上述指标过分恶化，如长作业等待很长时间等</p>

<h4 id="吞吐量批处理系统">吞吐量——批处理系统</h4>

<p>单位时间内所完成的作业数，跟作业本身特性和调度算法都有关系</p>

<h4 id="处理机利用率大中型主机">处理机利用率——大中型主机</h4>

<h4 id="各种资源的均衡利用">各种资源的均衡利用</h4>

<h3 id="设计调度算法要点">设计调度算法要点</h3>

<h4 id="进程优先级">进程优先级</h4>

<ul>
  <li>
    <p>静态优先级</p>

    <p>进程创建时指定，运行过程中不再改变</p>
  </li>
  <li>
    <p>动态优先级</p>

    <p>进程创建时指定，运行过程中可以动态变化</p>
  </li>
</ul>

<h4 id="进程优先级就绪队列的组织">进程优先级就绪队列的组织</h4>

<ul>
  <li>按优先级排队</li>
  <li>所有进程创建以后进入第一优先级就绪队列，随着进程的运行，可能会降低某些进程的优先级，如某些进程的时间片用完了，就将其降级</li>
</ul>

<h4 id="抢占式与非抢占式调度">抢占式与非抢占式调度</h4>

<h5 id="不可抢占式">不可抢占式</h5>

<p>一旦处理器分配给某一个进程，它就一直占用处理器，直到该进程自己因调用原语操作或等待 I/O 等原因进入阻塞状态，或等时间片用完才让出处理器</p>

<h5 id="抢占式">抢占式</h5>

<p>就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，便立即进行进程调度，把处理器转给优先级高的进程</p>

<h4 id="进程的分类">进程的分类</h4>

<ul>
  <li>I/O 密集型</li>
  <li>CPU 密集型</li>
  <li><strong>批处理进程</strong>
    <ul>
      <li>无需与用户交互，通常在后台运行</li>
      <li>无需很快响应</li>
    </ul>
  </li>
  <li>交互式进程
    <ul>
      <li>与用户交互频繁</li>
      <li>响应时间快</li>
    </ul>
  </li>
  <li>实时进程
    <ul>
      <li>有实时需求</li>
      <li>响应时间短且稳定</li>
    </ul>
  </li>
</ul>

<h4 id="时间片">时间片</h4>

<p>确定了允许该进程运行的时间长度</p>

<h3 id="批处理系统的调度算法">批处理系统的调度算法</h3>

<h4 id="公式-1">==公式==</h4>

<p>$$
吞吐量 = \frac{作业数}{总执行时间} <br />
周转时间 = 完成时刻 - 提交时刻 <br />
带权周转时间 = \frac{周转时间}{服务时间（执行时间）} <br />
平均周转时间 = \frac{作业周转时间之和}{作业数} <br />
平均带权周转时间 = \frac{作业带权周转时间之和}{作业数}
$$</p>

<h4 id="常见调度算法">==常见调度算法==</h4>

<h5 id="先来先服务-fcfs-first-come-first-serve">先来先服务 (FCFS: First Come First Serve)</h5>

<ul>
  <li>规则：
    <ul>
      <li>按照作业提交或进程变为就绪状态的先后顺序分派 CPU</li>
      <li>非抢占</li>
    </ul>
  </li>
  <li>利弊：
    <ul>
      <li>有利于长作业，不利于短作业</li>
      <li>有利于 CPU 繁忙的作业，不利于 I/O 繁忙的作业</li>
    </ul>
  </li>
</ul>

<h5 id="最短作业优先-sjf-shortest-job-first">最短作业优先 (SJF: Shortest Job First)</h5>

<ul>
  <li>规则：
    <ul>
      <li>对预计执行时间短的作业优先分派处理机</li>
      <li>通常非抢占</li>
    </ul>
  </li>
  <li>利弊：
    <ul>
      <li>相比于 FCFS 减少了平均周转时间</li>
      <li>对于长作业不利</li>
      <li>未能根据作业紧迫程度划分执行优先级</li>
      <li>难以准确估计作业（进程）优先级，从而影响调度性能</li>
    </ul>
  </li>
</ul>

<h5 id="最短剩余时间优先-frtf-shortest-remaining-time-first">最短剩余时间优先 (FRTF: Shortest Remaining Time First)</h5>

<ul>
  <li>规则
    <ul>
      <li>对预计剩余时间短的作业优先分派处理机</li>
      <li><strong>抢占式</strong></li>
    </ul>
  </li>
  <li>利弊
    <ul>
      <li>源源不断的短任务可能使长任务得不到运行，从而产生”饥饿“现象</li>
    </ul>
  </li>
</ul>

<h5 id="最高响应比优先-hrrf-response-ratio-first">最高响应比优先 (HRRF: Response Ratio First)</h5>

<ul>
  <li>
    <p>规则</p>

    <ul>
      <li>
        <p>每次选择作业投入运行时，先计算后备作业队列中每个作业的响应比 RP，然后选择其值最大的作业投入运行</p>

        <blockquote>
          <p>$RP = \frac{已等待时间 + 要求运行时间}{要求运行时间}$</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p>利弊</p>

    <ul>
      <li>每次计算各道作业的响应比会有一定的时间开销，性能略差于 SJF</li>
    </ul>
  </li>
</ul>

<h3 id="交互式系统的调度算法">交互式系统的调度算法</h3>

<h4 id="时间片轮转-rr-round-robin">时间片轮转 (RR: Round Robin)</h4>

<ul>
  <li>规则
    <ol>
      <li>将系统中所有就绪进程按照 FCFS 原则排成一个队列</li>
      <li>每次调度时将 CPU 分派给队首进程，让其执行一个时间片</li>
      <li>在一个时间片结束时，发生时钟中断</li>
      <li>调度程序暂停当前进程，将其送到就绪队列的末尾</li>
      <li>通过上下文切换执行当前的队首进程</li>
    </ol>
  </li>
  <li>时间片长度的确定</li>
  <li>利弊</li>
</ul>

<h4 id="优先级算法-priority-scheduling">优先级算法 (Priority Scheduling)</h4>

<h5 id="静态优先级">静态优先级</h5>

<h5 id="动态优先级">动态优先级</h5>

<h4 id="多级队列-mq-multi-level-queue">多级队列 (MQ: Multi-level Queue)</h4>

<ul>
  <li>规则
    <ul>
      <li>引入多个就绪队列</li>
      <li>不同队列可有不同优先级、时间片长度、调度策略</li>
      <li>在运行过程中可以改变进程所在队列</li>
    </ul>
  </li>
  <li>利弊
    <ul>
      <li>提高系统吞吐量，缩短平均周转时间，照顾短进程</li>
      <li>获得较好的 I/O 设备利用率和缩短响应时间而照顾 I/O 型进程</li>
      <li>不必估计进程的执行时间，动态调节</li>
    </ul>
  </li>
</ul>

<h4 id="多级反馈队列-mfq-multi-level-feedback-queue">多级反馈队列 (MFQ: Multi-level Feedback Queue)</h4>

<ul>
  <li>规则
    <ul>
      <li>设置多个就绪队列，分别赋予不同优先级（队列 1 优先级最高，优先级越低时间片越长）</li>
      <li>新进程进入内存后，先投入队列 1 末尾，按照 FCFS 算法调度</li>
      <li>若在队列 1 中未执行完，则投入到队列 2 末尾</li>
      <li>降低到最后的队列中时，按照“时间片轮转”调度算法直到完成</li>
    </ul>
  </li>
</ul>

<h3 id="优先级倒置">优先级倒置</h3>

<p>高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210601093327005-1377194481.png" alt="image" /></p>

<ul>
  <li>
    <p>解决方法——优先级置顶 (Priority Ceiling)</p>

    <p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210601093403148-1682096032.png" alt="image" /></p>
  </li>
  <li>
    <p>解决方法——优先级继承 (Priority Inheritance)</p>

    <p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210601093454293.png" alt="image-20210601093454293" /></p>
  </li>
</ul>

<h3 id="实时系统的调度算法">实时系统的调度算法</h3>

<blockquote>
  <p>实时系统是一种 <strong>时间</strong> 起着主导作用的系统。计算机必须在一个确定的时间范围内恰当的对外界刺激做出反应。</p>

  <ul>
    <li>
      <p>硬实时系统</p>

      <p>绝对满足截止时间要求</p>
    </li>
    <li>
      <p>软实时系统</p>

      <p>可以偶尔不满足截至时间要求</p>
    </li>
  </ul>
</blockquote>

<h5 id="静态表调度-static-table-driven-scheduling">静态表调度 (Static Table-driven Scheduling)</h5>

<p>通过对所有周期性任务的分析预测实现确定一个固定的调度方案</p>

<ul>
  <li>特点
    <ul>
      <li>无任何计算，按固定方案进行，开销最小</li>
      <li>无灵活性，只适用于完全固定的任务场景</li>
    </ul>
  </li>
</ul>

<h5 id="单调速率调度-rms-rate-monotonic-scheduling">单调速率调度 (RMS: Rate Monotonic Scheduling)</h5>

<p><em>单处理器下的<strong>最优静态</strong>调度算法</em></p>

<ul>
  <li>特点
    <ul>
      <li>任务周期越小，其优先级越高，优先级最高的任务优先被调度</li>
      <li>如果两个任务优先级一样，将随机选择一个调度</li>
      <li><strong>静态，抢占式调度</strong></li>
    </ul>
  </li>
</ul>

<h5 id="最早截至时间优先算法-edf-earliest-deadline-first">最早截至时间优先算法 (EDF: Earliest Deadline First)</h5>

<ul>
  <li>特点
    <ul>
      <li>任务的绝对截止时间越早，其优先级越高，优先级最高的任务优先被调度</li>
      <li>如果两个任务优先级一样，将随机选择一个调度</li>
    </ul>
  </li>
</ul>

<h3 id="多处理器调度">多处理器调度</h3>

<ul>
  <li>与单处理器调度的区别
    <ul>
      <li>注重整体运行效率</li>
      <li>更多样的调度算法</li>
      <li>广泛采用多线程调度</li>
    </ul>
  </li>
</ul>

<h2 id="死锁">死锁</h2>

<h3 id="死锁的概念">死锁的概念</h3>

<h4 id="死锁问题-deadlock">死锁问题 (Deadlock)</h4>

<ul>
  <li>定义
    <ul>
      <li>由于资源占用的互斥，当某个进程提出资源申请之后，使得一些进程在无外力协助的情况下，永远分配不到必需的资源而无法运行</li>
    </ul>
  </li>
  <li>发生原因
    <ul>
      <li><strong>竞争资源</strong></li>
      <li><strong>并发执行的顺序不当</strong></li>
    </ul>
  </li>
</ul>

<h4 id="死锁发生的四个必要条件">==死锁发生的四个必要条件==</h4>

<ol>
  <li>
    <p><strong>互斥条件</strong></p>

    <p>指进程对所分配到的资源进行排他性使用，即在一段时间内资源只能由一个进程占用。</p>
  </li>
  <li>
    <p><strong>请求和保持条件</strong></p>

    <p>指进程已经保持至少一个资源，但又提出新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放</p>
  </li>
  <li>
    <p><strong>不剥夺条件</strong></p>

    <p>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完成时由自己释放</p>
  </li>
  <li>
    <p><strong>环路等待条件</strong></p>

    <p>指在死锁发生时，必然存在一个进程——资源的环形链</p>
  </li>
</ol>

<h4 id="活锁-livelock">活锁 (Livelock)</h4>

<p>指的是任务或执行者没有被阻塞，或者由于某些条件没有满足，导致一直重复尝试和失败</p>

<h4 id="饥饿-starvation">饥饿 (Starvation)</h4>

<p>某些进程可能由于资源分配不公平导致长时间等待。当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称为进程被 <strong>饿死</strong></p>

<h3 id="处理死锁的基本方法">处理死锁的基本方法</h3>

<ul>
  <li>
    <p>不允许死锁发生</p>

    <ul>
      <li>
        <p>预防死锁（静态）</p>

        <p>破坏死锁的产生条件</p>
      </li>
      <li>
        <p>避免死锁（动态）</p>

        <p>在资源分配之前进行判断</p>
      </li>
    </ul>
  </li>
  <li>
    <p>允许死锁发生</p>

    <ul>
      <li>
        <p>检测和解除死锁</p>
      </li>
      <li>
        <p>无所作为</p>

        <p>鸵鸟算法</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="死锁预防静态">死锁预防【静态】</h4>

<ol>
  <li>
    <p><strong>打破互斥条件</strong></p>

    <p>允许进程同时访问某些资源</p>
  </li>
  <li>
    <p><strong>打破占有且申请条件</strong></p>

    <p>实行资源预先分配策略。只有当系统能够满足当前进程的全部资源需求时，才一次性的将所申请的资源全部分配给该进程，否则不分配任何资源。</p>

    <ul>
      <li>不可预测性</li>
      <li>资源利用率低</li>
      <li>降低进程的并发性</li>
    </ul>
  </li>
  <li>
    <p><strong>打破不可剥夺条件</strong></p>

    <p>允许进程强行从占有者那里夺取资源。</p>

    <p>实现困难，会降低系统性能</p>
  </li>
  <li>
    <p><strong>打破循环等待条件</strong></p>

    <p>实现资源有序分配策略，即把资源事先分类编号，按号分配，使得进程在申请时，占用资源不会形成环路。所有进程对资源的请求必须严格按照资源序号递增的顺序提出。进程只有占用了小号资源，才能申请大号资源。</p>

    <p>增加系统开销，增加进程对资源的占用时间</p>
  </li>
</ol>

<h4 id="死锁避免动态">==死锁避免【动态】==</h4>

<h5 id="安全序列">安全序列</h5>

<ul>
  <li>系统中的所有进程能够按照某种次序分配资源，并依序执行完毕，这种进程序列就称为 <strong>安全序列</strong>。</li>
  <li>如果 <strong>存在</strong> 一个安全序列，则系统是 <strong>安全</strong> 的。若 <strong>不存在</strong> 安全序列，则系统是不安全的。</li>
</ul>

<h5 id="安全状态">安全状态</h5>

<ul>
  <li><strong>安全状态</strong>： 系统存在一个进程执行序列 &lt;P~1~, P~2~, … P~n~&gt; 能顺利完成</li>
  <li><strong>不安全状态</strong>：系统不存在可完成的序列</li>
  <li><em>系统进入不安全状态也未必会产生死锁，但产生死锁后，系统一定处于不安全状态</em></li>
</ul>

<h5 id="银行家算法">==银行家算法==</h5>

<h6 id="数据说明">数据说明</h6>

<ul>
  <li>
    <p>$n$ 为进程数量，$m$ 为资源类型数量</p>
  </li>
  <li>
    <p>可利用资源向量 $Avaliable$: $m$ 维向量</p>

    <p>具有 $m$ 个元素的向量，其中每一个元素代表一类可利用的资源数目，其初值是系统中所配置的该类全部可用的资源数目。</p>
  </li>
  <li>
    <p>最大需求矩阵 $Max$: $n \times m$ 矩阵</p>

    <p>定义了系统中 $n$ 个进程中的每一个进程对 $m$ 类资源的最大需求</p>
  </li>
  <li>
    <p>分配矩阵 $Allocation$: $n\times m$ 矩阵</p>

    <p>定义了系统中每一类资源当前已分配给每一进程的资源数</p>
  </li>
  <li>
    <p>需求矩阵 $Need$: $n\times m$ 矩阵</p>

    <p>表示每一个进程尚需的各类资源数</p>

    <p>$Need(i, j) = Max(i, j) - Allocation(i, j)$</p>
  </li>
</ul>

<h6 id="具体算法">具体算法</h6>

<blockquote>
  <p>设 $Request$ 是进程 $P_i$ 的请求向量，此时进程 $P_i$ 需要 $k$ 个 $R_j$ 类资源</p>
</blockquote>

<ol>
  <li>
    <p>若 $Request_i \le Need_i$，则转向步骤 2，否则出错（所需要的资源超过宣布的最大值）</p>
  </li>
  <li>
    <p>若 $Request_i \le Avaliable_i$，则转向步骤 3，否则，表示系统尚无足够的资源，$P_i$ 需等待</p>
  </li>
  <li>
    <p>系统 <strong>试探</strong> 地把资源分配给进程 $P_i$
$$
Avaliable := Avaliable - Request <br />
Allocation := Allocation + Request <br />
Need_i := Need_i - Request
$$</p>
  </li>
  <li>
    <p>系统执行 <strong>安全性算法</strong>，检查此次资源分配后，系统是否处于安全状态</p>

    <ul>
      <li>若安全，则正式将资源分配给进程 $P_i$</li>
      <li>若不安全，则恢复原理啊的进程分配状态，让 $P_i$ 等待</li>
    </ul>

    <blockquote>
      <p>安全性算法：是否有安全序列</p>
    </blockquote>
  </li>
</ol>

<h4 id="检测死锁">检测死锁</h4>

<h5 id="资源分配图-rag-算法">资源分配图 (RAG) 算法</h5>

<blockquote>
  <p>资源分配图 RAG(Resource Allocation Graph)</p>

  <p>有向图 $G$ 的顶点为 <strong>资源R</strong> 或 <strong>进程P</strong>.</p>

  <ul>
    <li>$R\rightarrow P$: $R$ 已分配给 $P$</li>
    <li>$P\rightarrow R$: $P$ 正因请求 $R$ 而处于等待状态</li>
  </ul>

  <p>化简：</p>

  <p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210601205645257-873812331.png" alt="image" /></p>
</blockquote>

<p><strong>死锁定理</strong>：系统中某个时刻 $t$ 为死锁状态 $\Leftrightarrow$ $t$ 时刻系统的资源分配图是 <strong>不可能完全化简的</strong></p>

<h4 id="死锁解除">死锁解除</h4>

<h5 id="资源剥夺法">资源剥夺法</h5>

<p>使用挂起 / 激活挂起一些进程，剥夺它们的资源解除死锁，当条件满足时，再激活进程</p>

<h5 id="撤销进程法">撤销进程法</h5>

<p>将全部死锁的进程夭折掉，按照某个顺序逐个撤销（回退）进程，直至有足够的资源可用，死锁状态解除为止</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210601210214512-866551624.png" alt="image" /></p>

<h3 id="死锁的基本问题">死锁的基本问题</h3>

<h4 id="哲学家就餐问题">哲学家就餐问题</h4>

<blockquote>
  <p><strong>解题思路</strong></p>

  <ol>
    <li>至多只允许 <em>四个</em> 哲学家（尝试）进餐【破除资源互斥】</li>
    <li>对筷子进行 <em>编号</em>，每个哲学家按照编号从低到高拿筷子。或对哲学家 <em>编号</em>，奇数号哲学家先拿左边筷子，偶数号先拿右边筷子【破除循环等待】</li>
    <li>同时拿起两根筷子，否则不拿起【破除保持等待】</li>
  </ol>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semaphore</span> <span class="n">fork</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// 筷子数量</span>
<span class="n">semaphore</span> <span class="n">room</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">};</span> <span class="c1">// 桌子周围的空间，最多能容纳四个哲学家</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">philosophoer</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">think</span><span class="p">();</span>
        <span class="n">P</span><span class="p">(</span><span class="n">room</span><span class="p">);</span> <span class="c1">// 最多只允许四个哲学家同时坐在桌子周围</span>
        <span class="n">P</span><span class="p">(</span><span class="n">fork</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">P</span><span class="p">(</span><span class="n">fork</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">mod</span> <span class="mi">5</span><span class="p">]);</span>
        <span class="n">eat</span><span class="p">();</span> <span class="c1">// 进餐</span>
        <span class="n">V</span><span class="p">(</span><span class="n">fork</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">mod</span> <span class="mi">5</span><span class="p">]);</span>
        <span class="n">V</span><span class="p">(</span><span class="n">fork</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">V</span><span class="p">(</span><span class="n">room</span><span class="p">);</span> <span class="c1">// 释放资源</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">parbegin</span> <span class="p">(</span><span class="n">philosopher</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">philosopher</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">philosopher</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">philosopher</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">philosopher</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="设备管理">设备管理</h2>

<h3 id="io-管理概述">I/O 管理概述</h3>

<h4 id="设备管理的目的和功能">设备管理的目的和功能</h4>

<ul>
  <li>外设管理目的
    <ul>
      <li>提高效率</li>
      <li>方便使用</li>
      <li>方便控制</li>
    </ul>
  </li>
  <li>外设管理功能
    <ul>
      <li>提供设备使用的用户接口</li>
      <li>设备分配和释放</li>
      <li>设备的访问控制</li>
      <li>I/O 缓冲和调度</li>
    </ul>
  </li>
</ul>

<h4 id="总线bus接入-io-设备的主要方式">总线(bus)：接入 I/O 设备的主要方式</h4>

<h4 id="io-管理的特点">I/O 管理的特点</h4>

<p>I/O 性能经常成为系统性能的瓶颈</p>

<h4 id="io-管理的目标和任务">I/O 管理的目标和任务</h4>

<ol>
  <li>按照用户请求，控制设备操作，完成 I/O 设备与内存间的数据交换，最终完成用户的 I/O 请求</li>
  <li>建立方便、统一的独立于设备的接口</li>
  <li>提高 I/O 效率</li>
  <li>保护数据安全性</li>
</ol>

<h4 id="io-设备的分类">I/O 设备的分类</h4>

<h5 id="按数据组织分类">按数据组织分类</h5>

<ul>
  <li>
    <p><strong>块设备</strong>：</p>

    <p>以<strong>数据块</strong>为单位存储、传输信息。<strong>传输速率较高</strong>，<strong>可寻址</strong>（随机读写）</p>

    <blockquote>
      <p>硬盘、软盘驱动器、CD-ROM 驱动器、闪存、U 盘、SD 卡</p>

      <p><strong>随机读写</strong>：意味着可以不按照顺序读写。</p>
    </blockquote>
  </li>
  <li>
    <p><strong>字符设备</strong>：</p>

    <p>以<strong>字符</strong>为单位随机存储、传输信息。<strong>传输速率低</strong>，<strong>不可寻址</strong></p>

    <blockquote>
      <p>e.g. 鼠标、键盘、串口、控制台和 LED 设备</p>
    </blockquote>
  </li>
  <li>
    <p><strong>网络设备</strong></p>
  </li>
</ul>

<h5 id="按用途分类">按用途分类</h5>

<ul>
  <li><strong>存储设备</strong>：磁盘、磁带</li>
  <li><strong>传输设备</strong>：网卡、Modem</li>
  <li><strong>人机交互设备</strong>：显示器、键盘、鼠标</li>
</ul>

<p><strong>从资源分配角度</strong></p>

<ul>
  <li><strong>独占设备</strong>：在一段时间内只能由一个进程使用的设备，如打印机等</li>
  <li><strong>共享设备</strong>：在一段时间内允许多个进程共同使用的设备，如硬盘</li>
  <li><strong>虚设备</strong>：在一类设备上模拟另一类设备。<em>用共享设备模拟独占设备，用高速设备模拟低速设备。</em></li>
</ul>

<h3 id="io-硬件组成">I/O 硬件组成</h3>

<h4 id="设备控制器">设备控制器</h4>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607110550864-979622355.png" alt="image" /></p>

<ul>
  <li>功能
    <ul>
      <li>接受 &amp; 识别 CPU 命令</li>
      <li>数据交换：CPU 与控制器、控制器与设备</li>
      <li>设备状态的了解和报告</li>
      <li>设备地址识别</li>
      <li>缓冲区</li>
      <li>对设备传来的数据进行差错检测</li>
    </ul>
  </li>
  <li>组成
    <ul>
      <li><strong>控制器与 CPU 接口</strong>：数据寄存器、状态寄存器</li>
      <li><strong>控制器与设备接口</strong>：数据信号、控制信号、状态信号</li>
      <li><strong>I/O 逻辑</strong>：用于实现 CPU 对 I/O 设备的控制</li>
    </ul>
  </li>
</ul>

<h4 id="io-端口地址">I/O 端口地址</h4>

<ul>
  <li>
    <p>I/O 端口地址：接口电路中每个寄存器有唯一的地址</p>
  </li>
  <li>
    <p>所有 I/O 端口地址形成 I/O 端口的 <strong>地址空间</strong></p>

    <ul>
      <li>
        <p>I/O 独立编址</p>

        <blockquote>
          <p>Intel 体系结构 in/out 指令</p>
        </blockquote>

        <ul>
          <li>优点
            <ul>
              <li>外设不占用内存的地址空间</li>
              <li>编程时易于区分是对内存操作还是对 I/O 操作</li>
            </ul>
          </li>
          <li>缺点
            <ul>
              <li>I/O端口操作的指令类型少，操作不灵活</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>内存映像编址</p>

        <blockquote>
          <p>控制器的内存 / 寄存器作为物理内存空间的一部分</p>
        </blockquote>

        <ul>
          <li><strong>优点</strong>：
            <ul>
              <li>不需要特殊的保护机制来阻止用户进程进行相应的 I/O 操作</li>
              <li>可以引用内存的每一条指令都适用于引用控制寄存器</li>
            </ul>
          </li>
          <li><strong>缺点</strong>：
            <ul>
              <li><strong>不允许对一个控制寄存器的内容进行高速缓存</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="io-控制方式">==I/O 控制方式==</h3>

<h4 id="程序控制-io-pio-programmed-io">程序控制 I/O (PIO, Programmed I/O)</h4>

<blockquote>
  <p>也称 <strong>轮询</strong> 或 <strong>查询方式 I/O</strong>，由 CPU 代表进程向 I/O 模块发出指令，然后进入忙等状态，知道操作完成之后进程继续执行</p>
</blockquote>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607112151271-579023237.png" alt="image" /></p>

<h4 id="中断驱动方式-interrupt-driven-io">中断驱动方式 (Interrupt-driven I/O)</h4>

<blockquote>
  <p>I/O 操作结束后由设备控制器主动通过中断通知设备驱动程序。</p>
</blockquote>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607112217758-1752791991.png" alt="image" /></p>

<h4 id="直接存储访问方式-dma-direct-memory-access">直接存储访问方式 (DMA, Direct Memory Access)</h4>

<blockquote>
  <p>由一个专门的控制器完成数据从内存到设备或设备到内存的传输工作</p>
</blockquote>

<ol>
  <li>由程序设置 DMA 控制器中的若干寄存器值（如内存始址，传送字节数），然后发起 I/O 操作</li>
  <li>DMA 控制器完成内存与外设的成批数据交换</li>
  <li>在操作完成时由 DMA 控制器向 CPU 发出中断</li>
</ol>

<p><strong>DMA 控制器中的寄存器</strong></p>

<ul>
  <li><strong>命令 / 状态寄存器(CR)</strong>，用于接收从 CPU 发来的 I/O 命令，或有关控制信息，或设备的状态</li>
  <li><strong>内存地址寄存器(MAR)</strong>，在输入时，它存放把数据从设备传送到内存的起始目标地址，在输出时，它存放由内存到设备的内存源地址</li>
  <li><strong>数据寄存器(DR)</strong>，用于暂存从设备到内存，或从内存到设备的数据</li>
  <li><strong>数据计数器(DC)</strong>，存放本次 CPU 要读或写的字（节）数</li>
</ul>

<p><strong>优缺点</strong></p>

<ul>
  <li>优点
    <ul>
      <li>CPU 只需干预 I/O 操作的开始和结束，而后续成批的数据读写则无需 CPU 控制，适用于高速设备</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>数据传送的方向、存放数据的内存地址及传送数据的长度等都由 CPU 控制，占用了 CPU 时间</li>
      <li>每个设备占用一个 DMA 控制器，当设备增加时，需要增加新的 DMA 控制器</li>
    </ul>
  </li>
</ul>

<p><strong>与中断方式的区别</strong></p>

<ul>
  <li>中断控制方式在 <em>每个数据</em> 传送完成后中断 CPU，DMA 控制方式在传送 <em>一批</em> 数据完成之后中断 CPU</li>
  <li>中断控制方式的数据传送在中断处理时由 CPU 控制完成，需要程序切换、保存和恢复现场。而 DMA 方式下由 DMA 控制器控制完成，只有开始和结束需要 CPU 干预，在传输过程中不需要 CPU 干预。</li>
  <li>程序中断方式具有对 <em>异常事件</em> 的处理能力，而 DMA 控制方式适用于 <em>数据块</em> 的传输</li>
</ul>

<h4 id="通道技术-channel">通道技术 (Channel)</h4>

<blockquote>
  <p>原理与 DMA 类似。</p>

  <p><strong>通道</strong> 是一个特殊功能的处理器，有自己的指令和程序专门负责数据输入输出的传输控制。CPU 将”传输控制“功能下放给通道，由通道负责”数据处理功能“。这样，通道与 CPU 分时使用内存，实现 CPU 内部运算与 I/O 设备的并行工作</p>
</blockquote>

<ul>
  <li>
    <p><strong>基本思想</strong>：进一步减少 CPU 干预</p>
  </li>
  <li>
    <p>I/O 通道专门负责输入输出，独立于 CPU，有自己的指令体系。可执行由通道指令组成的通道程序，因此可以进行较为复杂的 I/O 控制</p>
  </li>
  <li>
    <p><strong>优点</strong>： 执行一个通道程序可以完成好几组 I/O 操作，与 DMA 相比减少了 CPU 干预</p>
  </li>
  <li>
    <p><strong>缺点</strong>： 费用较高</p>
  </li>
  <li>
    <p><strong>通道种类</strong></p>

    <ul>
      <li>
        <p><strong>字节多路通道</strong>：以字节为单位交叉工作</p>

        <blockquote>
          <p>当为一台设备传送一个字节后，立即转去为另一台设备传送一个字节；适用于打印机、终端等低速或中速的 I/O 设备</p>
        </blockquote>
      </li>
      <li>
        <p><strong>数组选择通道</strong></p>

        <blockquote>
          <p>以 ”组方式“ 工作，每次传送一批数据，传送速率很高，但在一段时间只能为一台设备服务。</p>
        </blockquote>
      </li>
      <li>
        <p><strong>数组多路通道</strong></p>

        <blockquote>
          <p>综合了字节多路通道和数据选择通道。对通道程序采用多道程序设计技术，使得与通道连接的设备可以并行工作</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>与 DMA 的区别</strong></p>

    <ul>
      <li>通道具有更强的处理 I/O 的功能</li>
      <li>一个通道可以同时控制多种设备</li>
    </ul>
  </li>
</ul>

<h3 id="io-软件的组成">I/O 软件的组成</h3>

<h4 id="io-软件设计">I/O 软件设计</h4>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607132407679-667178510.png" alt="image" /></p>

<h4 id="设备独立性">设备独立性</h4>

<ul>
  <li>
    <p>为了实现设备独立性引入 <strong>逻辑设备</strong> 和 <strong>物理设备</strong> 两个概念</p>
  </li>
  <li>
    <p>系统需具有将逻辑设备名称转换为某物理设备名称的功能</p>
  </li>
  <li>
    <p>优点</p>

    <ul>
      <li>设备分配更灵活</li>
      <li>易于实现 I/O 重定向</li>
    </ul>
  </li>
  <li>
    <p>逻辑设备名到物理设备名的映射</p>

    <ul>
      <li>
        <p>设备逻辑表 LUT(Logical Unit Table)</p>

        <blockquote>
          <p>包含逻辑设备名、物理设备名和设备驱动程序入口地址</p>
        </blockquote>
      </li>
      <li>
        <p>可以为整个系统，也可以为每个用户单独设置 LUT</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="设备驱动程序">设备驱动程序</h4>

<blockquote>
  <p>与设备密切相关的代码</p>
</blockquote>

<ul>
  <li>接收来自设备无关的上层软件的抽象请求，并执行这个请求</li>
  <li>向设备发送命令和参数，并监督它们正确执行</li>
</ul>

<p><strong>组成</strong></p>

<ul>
  <li>
    <p>自动配置和初始化子程序</p>

    <blockquote>
      <p>检查设备工作是否正常</p>
    </blockquote>
  </li>
  <li>
    <p>I/O 操作子程序</p>

    <blockquote>
      <p>系统调用的结果</p>
    </blockquote>
  </li>
  <li>
    <p>中断服务子程序</p>

    <blockquote>
      <p>系统接收硬件中断，再由系统调用中断服务子程序</p>
    </blockquote>
  </li>
</ul>

<p><strong>设备驱动程序与应用程序的区别</strong></p>

<ul>
  <li>应用程序以 <code class="language-plaintext highlighter-rouge">main</code> 开始，而设备驱动程序以一个模块初始化函数作为入口</li>
  <li>应用程序从头到尾执行一个任务，而设备驱动程序完成初始化后不再运行，等待系统调用</li>
  <li>应用程序可以使用标准 C 函数库，而驱动程序则不能</li>
</ul>

<h3 id="io-缓冲管理">I/O 缓冲管理</h3>

<h4 id="缓冲技术">缓冲技术</h4>

<p>缓冲技术可以提高外设利用率</p>

<ul>
  <li>原因
    <ul>
      <li>匹配 CPU 与外设的不同处理速度</li>
      <li>减少对 CPU 的中断次数</li>
      <li>提高 CPU 和 I/O 设备之间的并行性</li>
    </ul>
  </li>
</ul>

<h4 id="单缓冲-single-buffer">单缓冲 (single buffer)</h4>

<p>每当用户进程发出一个 I/O 请求时，操作系统便在主存中为之分配一个缓冲区</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607170753413-545748149.png" alt="image" /></p>

<h4 id="双缓冲-double-buffer">双缓冲 (double buffer)</h4>

<p>两个缓冲区，CPU 和外设都可以连续处理而无需等待对方。</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607170729070-527687345.png" alt="image" /></p>

<p>要求 CPU 与外设的速度相近</p>

<h4 id="环形缓冲-circular-buffer">环形缓冲 (circular buffer)</h4>

<p>当 CPU 与外设的处理速度相差极大时，引入多缓冲机制，将多个缓冲组织成循环缓冲形式</p>

<p>作为输入的多缓冲区可分为三种类型：</p>

<ul>
  <li><strong>空缓冲区 R</strong>：用于装输入数据</li>
  <li><strong>已装满数据的缓冲区 G</strong></li>
  <li>计算进程 <strong>正在使用的工作缓冲区 C</strong></li>
</ul>

<p>作为输入的缓冲区可设置三个指针：</p>

<ul>
  <li>用于 <strong>指示计算进程下一个可用缓冲区 G 的指针 Nextg</strong></li>
  <li>用于 <strong>指示输入进程下次可用的空缓冲区 R 的指针 Nexti</strong></li>
  <li>用于 <strong>指示计算进程增在使用的工作缓冲区 C 的指针 Current</strong></li>
</ul>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607170642294-1380649775.png" alt="image" /></p>

<h4 id="缓冲池-buffer-pool">缓冲池 (buffer pool)</h4>

<p>将相同类型的缓冲区链成一个队列</p>

<ul>
  <li><strong>空缓冲队列 emq</strong></li>
  <li><strong>输入队列 inq</strong></li>
  <li><strong>输出队列 outq</strong></li>
</ul>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607170557640-1038523088.png" alt="image" /></p>

<p><strong>工作方式</strong></p>

<ul>
  <li>
    <p><strong>收容输入</strong></p>

    <p>在输入进程需要输入数据时，便调用 Getbuf(emq) 过程，从空缓冲队列的队首取出一个空的缓冲区，把它作为收容输入工作缓冲 hin。</p>

    <p>然后将数据输入其中</p>

    <p>装满后调用 Putbuf(inq, hin) 过程，将该缓冲区挂在输入队列上</p>
  </li>
  <li>
    <p><strong>提取输入</strong></p>

    <p>计算进程需要输入数据时，调用 Getbuf(inq) 过程，从输入队列队首去除一个缓冲区，作为提取输入工作缓冲区 sin</p>

    <p>计算进程从中提取数据</p>

    <p>使用完数据后，调用 Putbuf(emq, sin) 过程，将该缓冲区挂到空缓冲队列 emq 上</p>
  </li>
  <li>
    <p><strong>收容输出</strong></p>

    <p>计算过程需要输出时，调用 Getbuf(emq) 过程，从空缓冲区队列 emq 的队首取出一个空缓冲区，作为收容输出工作缓冲区 hout</p>

    <p>当其中装满输出后，又调用 Putbuf(outq, hout) 过程，将缓冲区挂在 outq 末尾</p>
  </li>
  <li>
    <p><strong>提取输出</strong></p>

    <p>由输出进程调用 Getbuf(outq) 过程，从输出队列队首取出一个装满输出数据的缓冲区，作为提取输出工作缓冲区 sout</p>

    <p>提取数据</p>

    <p>调用 Putbuf(emq, sout) 过程，将该缓冲区挂在空缓冲队列末尾</p>
  </li>
</ul>

<h3 id="io-设备管理">I/O 设备管理</h3>

<h4 id="io-设备分配">I/O 设备分配</h4>

<h4 id="数据结构-1">数据结构</h4>

<ol>
  <li>
    <p><strong>设备控制表(DCT, Device Control Table)</strong>：每个设备一张，描述设备特性和状态。反映设备的特性、设备和控制器的连接情况。反应设备的特性、设备和控制器的连接情况</p>

    <p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607194409648-1166416661.png" alt="image" /></p>

    <p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607194050828-1327675172.png" alt="image" /></p>
  </li>
  <li>
    <p><strong>控制器控制表 (COCT, COntroller Control Table)</strong></p>

    <p>每个设备控制器一张，描述 I/O 控制器的配置和状态。</p>

    <p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607194331985-1238006993.png" alt="image" /></p>
  </li>
  <li>
    <p><strong>通道控制表 (CHCT, CHannel Control Table)</strong></p>

    <p>每个通道一张，描述通道工作状态。</p>

    <p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607194348426-1248032932.png" alt="image" /></p>
  </li>
  <li>
    <p><strong>系统设备表 (SDT, System Device Table)</strong></p>

    <p>反映系统中设备资源的状态，记录所有设备的状态及其设备控制表的入口。SDT 表项的组成：</p>

    <ul>
      <li><strong>DCT 指针</strong>：指向相应设备的 DCT</li>
      <li><strong>设备使用进程标识</strong>：正在使用该设备的进程标识</li>
      <li><strong>DCT 信息</strong>：为引用方便而保存的 DCT 信息</li>
    </ul>
  </li>
</ol>

<h4 id="设备分配时应考虑的因素">设备分配时应考虑的因素</h4>

<ul>
  <li>设备固有属性：独享、共享、虚拟设备</li>
  <li>设备分配算法：先来先服务、优先级高者优先</li>
  <li>设备分配中的安全性：死锁问题
    <ul>
      <li>安全分配（同步）</li>
      <li>不安全分配（异步）</li>
    </ul>
  </li>
</ul>

<h4 id="单多通路-io-系统的设备分配">单（多）通路 I/O 系统的设备分配</h4>

<p>一个设备对应一（多）个控制器，一个控制器对应一（多）个通道</p>

<ul>
  <li>分配设备</li>
  <li>分配设备控制器</li>
  <li>分配通道</li>
</ul>

<h4 id="用户空间的-io-软件spooling-技术">==用户空间的 I/O 软件：SPOOLing 技术==</h4>

<blockquote>
  <p><strong>SPOOLing, Simultaneous Peripheral Operation On Line</strong>，也称虚拟设备技术，可把独享设备转变成具有共享特征的虚拟设备，从而提高设备利用率。</p>
</blockquote>

<p>应用程序进行 I/O 操作时，只是和 SPOOLing 程序交换数据，可以称为 ”虚拟 I/O“。应用程序实际上是从 SPOOLing 程序的缓冲池中读出数据或把数据送入缓冲池，而不是跟实际的外设进行 I/O 操作。</p>

<p><strong>SPOOLing 系统组成</strong></p>

<ul>
  <li><strong>输入井和输出井</strong>：在磁盘上开辟的两大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存 I/O 设备输入的数据。输出井是模拟脱机输出时的磁盘，用于暂存用户程序和输出数据</li>
  <li><strong>输入缓冲区和输出缓冲区</strong>：缓和 CPU 与磁盘之间速度不匹配，在内存中开辟的两个缓冲区，输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井，输出缓冲区用于暂存从输出井送来的数据，以后再传送给输出设备</li>
  <li><strong>输入进程 SPi 和输出进程 SPo</strong>：利用两个进程模拟脱机 I/O 时的外围控制机。</li>
</ul>

<h3 id="io-性能问题">I/O 性能问题</h3>

<h4 id="io-操作的步骤">I/O 操作的步骤</h4>

<ol>
  <li><strong>磁盘把数据装载进内核的内存空间</strong></li>
  <li><strong>内核的内存空间的数据 copy 到用户的内存空间中</strong></li>
</ol>

<p>解决 I/O 性能问题的两个途径：</p>

<ul>
  <li>
    <p>使 CPU 利用率尽可能不被 I/O 降低</p>

    <blockquote>
      <p>使用缓冲技术 <em>减少</em> 或 <em>缓解</em> 速度差异，同时使用异步 I/O 使 CPU 不等待 I/O</p>
    </blockquote>
  </li>
  <li>
    <p>使 CPU 尽可能摆脱 I/O</p>

    <blockquote>
      <p>使用 DMA、通道等 I/O 部件让 CPU 摆脱 I/O 操作的影响</p>
    </blockquote>
  </li>
</ul>

<h4 id="阻塞-io">阻塞 I/O</h4>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607204657963-1682940241.png" alt="image" /></p>

<p>调用结果返回之前，当前进程会被挂起（线程进入睡眠状态），函数只有在得到结果之后，才会返回，才能继续运行</p>

<h4 id="io-多路复用">I/O 多路复用</h4>

<p>工作进程调用一个管理 I/O 的特殊库函数，此库函数可以接收并处理多个 I/O 请求，工作进程可以同时等待多个 I/O 请求。阻塞在多个进程上，相较前者的效率更高。</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607204820676-1942297118.png" alt="image" /></p>

<h4 id="非阻塞-io">非阻塞 I/O</h4>

<p>进程发起 I/O 调用，I/O 通知进程进行别的操作</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607204933605-435903107.png" alt="image" /></p>

<h4 id="事件信号驱动-io">事件（信号）驱动 I/O</h4>

<p>进程发起调用，通过回调函数，内核记住哪个进程申请的，在第一段完成后向进程发起通知，避免进程在第一段时忙等。第二段依然是阻塞的</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607204954435-1803283200.png" alt="image" /></p>

<h4 id="异步-io">异步 I/O</h4>

<p>无论第一段还是第二段，不再向系统调用提出任何反馈，只有数据完全复制到服务进程内存中以后，在向服务进程返回 Ok 的信息，其它时间，进程可以随意做自己的事情，直到内核通知 ok 信息。</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607215257429-1768857617.png" alt="image" /></p>

<h4 id="五种模型比较">五种模型比较</h4>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607215608609-58389590.png" alt="image" /></p>

<h2 id="磁盘管理">磁盘管理</h2>

<h3 id="磁盘的结构">磁盘的结构</h3>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607222611978-1575846319.png" alt="image" /></p>

<blockquote>
  <p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21lbmd4aWFveHUvbWVuZ3hpYW94dS5naXRodWIuaW8vbWFzdGVyL3Bvc3QtaW1hZ2VzLzE1Njk2NzkyNjY4ODIuanBn?x-oss-process=image/format,png" style="zoom: 67%;" /></p>

  <p>磁盘一般有一个或多个盘片。每个盘片可以有两面，即第一个盘片的正面为0面，反面为 1 面；第二个盘片的正面为 2 面…依次类推。磁头的编号也和盘面的编号是一样的，因此有多少个盘面就有多少个磁头。盘面正视图如下图，磁头的传动臂只能在盘片的内外磁道之间移动。因此不管开机还是关机，磁头总是在盘片上面。关机时，磁头停在盘片上面，抖动容易划伤盘面造成数据损失，为了避免这样的情况，所以磁头都是停留在起停区的，起停区是没有数据的。</p>

  <p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21lbmd4aWFveHUvbWVuZ3hpYW94dS5naXRodWIuaW8vbWFzdGVyL3Bvc3QtaW1hZ2VzLzE1Njk2NzkyOTQ5MjMuanBn?x-oss-process=image/format,png" alt="img" /></p>

  <p>每个盘片的盘面被划分成多个狭窄的同心圆环，数据就存储在这样的同心圆环上面，我们将这样的圆环称为<strong>磁道 (Track)</strong>。每个盘面可以划分多个磁道，最外圈的磁道是0号磁道，向圆心增长依次为1磁道、2磁道…磁盘的数据存放就是从最外圈开始的。</p>

  <p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21lbmd4aWFveHUvbWVuZ3hpYW94dS5naXRodWIuaW8vbWFzdGVyL3Bvc3QtaW1hZ2VzLzE1Njk2NzkzMjEzOTIuanBn?x-oss-process=image/format,png" alt="img" style="zoom:80%;" /></p>

  <p>根据硬盘的规格不同，磁道数可以从几百到成千上万不等。每个磁道可以存储数 Kb 的数据，但是计算机不必要每次都读写这么多数据。因此，再把每个磁道划分为若干个弧段，每个弧段就是一个扇区 (Sector)。扇区是硬盘上存储的物理单位，现在每个扇区可存储 512 字节数据已经成了业界的约定。也就是说，即使计算机只需要某一个字节的数据，但是也得把这个 512 个字节的数据全部读入内存，再选择所需要的那个字节。</p>

  <p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21lbmd4aWFveHUvbWVuZ3hpYW94dS5naXRodWIuaW8vbWFzdGVyL3Bvc3QtaW1hZ2VzLzE1Njk2NzkzNTAzOTIuanBn?x-oss-process=image/format,png" alt="img" /></p>

  <p><strong>柱面</strong>是我们抽象出来的一个逻辑概念，简单来说就是处于同一个垂直区域的磁道称为柱面 ，即各盘面上面相同位置磁道的集合。需要注意的是，磁盘读写数据是按柱面进行的，磁头读写数据时首先在同一柱面内从 0 磁头开始进行操作，依次向下在同一柱面的不同盘面(即磁头上)进行操作，只有在同一柱面所有的磁头全部读写完毕后磁头才转移到下一柱面。因为选取磁头只需通过电子切换即可，而选取柱面则必须通过机械切换。数据的读写是按柱面进行的，而不是按盘面进行，所以把数据存到同一个柱面是很有价值的。</p>

  <p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21lbmd4aWFveHUvbWVuZ3hpYW94dS5naXRodWIuaW8vbWFzdGVyL3Bvc3QtaW1hZ2VzLzE1Njk2NzkzNzU4NzguanBn?x-oss-process=image/format,png" alt="img" style="zoom:80%;" /></p>

  <p>磁盘被<strong>磁盘控制器</strong>所控制（可控制一个或多个），它是一个小处理器，可以完成一些特定的工作。比如将磁头定位到一个特定的半径位置；从磁头所在的柱面选择一个扇区；读取数据等。</p>

  <p>————————————————
版权声明：本文为CSDN博主「Guanngxu」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/heuguangxu/article/details/80072024</p>
</blockquote>

<h4 id="基本概念-5">基本概念</h4>

<h5 id="扇区-sector">扇区 (sector)</h5>

<p>盘面被分成许多扇形的区域</p>

<h5 id="磁道-track">磁道 (track)</h5>

<p>盘片上以盘片中心为圆心，不同半径的同心圆</p>

<h5 id="柱面-cylinder">柱面 (cylinder)</h5>

<p>硬盘中，不同盘片相同半径的磁道所组成的援助</p>

<h5 id="磁头-head">磁头 (head)</h5>

<p>每个磁盘由两个面，每个面都有一个磁头</p>

<h4 id="扇区的组织与内部结构">扇区的组织与内部结构</h4>

<ul>
  <li>每个磁道的扇区数不是常量</li>
  <li>绝大多数磁盘有一些缺陷扇区，因此映射必须用磁盘上其他空闲扇区来替代这些缺陷扇区</li>
</ul>

<h4 id="磁盘缺陷">磁盘缺陷</h4>

<blockquote>
  <p><strong>P 表</strong>：又称为永久缺陷列表，用于记录硬盘生产过程中产生的缺陷</p>

  <p><strong>G 表</strong>：又称增长缺陷列表，用于记录硬盘使用过程中由于磁介质性能变弱而引起的缺陷</p>
</blockquote>

<ul>
  <li><strong>固件区</strong>：存储硬盘的固件（硬盘控制器使用）</li>
  <li><strong>工作区</strong>：用户存储数据的区域，也就是硬盘标定容量的扇区</li>
  <li><strong>保留区</strong>：超过固件定义的硬盘容量的那些扇区</li>
</ul>

<h3 id="磁盘的组织">磁盘的组织</h3>

<h4 id="主引导扇区-mbr">主引导扇区 (MBR)</h4>

<blockquote>
  <p>硬盘的 0 柱面、0 磁头、1 扇区称为主引导扇区。</p>
</blockquote>

<p>用于硬盘启动时将系统控制权交给用户指定的、在分区表中登记了某个操作系统分区。</p>

<p>包括：</p>

<ul>
  <li>
    <p><strong>启动代码</strong> &amp; <strong>数据</strong></p>
  </li>
  <li>
    <p><strong>分区表</strong></p>
  </li>
  <li>
    <p><strong>幻数(Magic Number)</strong></p>

    <p>用于检查</p>
  </li>
</ul>

<h4 id="分区表-dpt">分区表 (DPT)</h4>

<blockquote>
  <p>分区表由四个分区项组成，每个分区项数据为 16 字节，记录了启动时需要的分区参数</p>
</blockquote>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210607224007151-1558900650.png" alt="image" /></p>

<h4 id="分区引导扇区-dbr">分区引导扇区 (DBR)</h4>

<h4 id="容量">容量</h4>

<p>$$
磁盘地址与块号的转换<br />
已知块号，则磁盘地址：<br />
柱面号 = \frac{块号}{磁头数\times 扇区数}<br />
磁头号 = \frac{块号 mod (磁头数\times 扇区数)}{扇区数}<br />
扇区号 = (块号 mod （磁头数\times 扇区数)) mod 扇区数 <br />
已知磁盘地址：<br />
块号 = 柱面号 \times (磁头数 \times 扇区数)+磁头号\times 扇区数+扇区号
$$</p>

<h4 id="访问时间">==访问时间==</h4>

<h5 id="寻道时间">寻道时间</h5>

<blockquote>
  <p>把磁臂（磁头）从当前位置移到指定磁道上所经历的时间。该事件是启动磁盘的时间 s 与磁头移动 n 条磁道所花费的时间之和</p>
</blockquote>

<p>$Ts = m\times n + s$，其中 $m$ 为常数</p>

<h5 id="旋转延迟时间">旋转延迟时间</h5>

<blockquote>
  <p>磁盘旋转所花费的时间</p>
</blockquote>

<p>$Tr = \frac{1}{2r}$，其中，磁盘旋转速度为 $r$</p>

<h5 id="传输时间">传输时间</h5>

<blockquote>
  <p>把数据从磁盘读出，或向磁盘写入数据所经历的时间</p>
</blockquote>

<p>$Tt = \frac{b}{rN}$，其中 $b$ 为磁盘每次读/写的字节数，$r$ 为磁盘旋转速度，$N$ 为磁道上的字节数</p>

<h5 id="访问时间-1">访问时间</h5>

<blockquote>
  <p>磁盘访问数据的时间</p>
</blockquote>

<p>访问时间 = 寻道时间 + 旋转延迟时间 + 传输时间</p>

<p>$Ta = Ts + \frac{1}{2r} + \frac{b}{rN}$</p>

<h3 id="磁盘的调度算法">==磁盘的调度算法==</h3>

<h4 id="先来先服务算法-fcfs">先来先服务算法 (FCFS)</h4>

<ul>
  <li>
    <p><strong>算法思想</strong></p>

    <p>按访问请求到达的先后次序服务</p>
  </li>
  <li>
    <p><strong>优点</strong></p>

    <p>简单、公平</p>
  </li>
  <li>
    <p><strong>缺点</strong></p>

    <p>效率低，服务时间长，对机械结构不利</p>
  </li>
</ul>

<h4 id="最短寻道时间优先算法-sstf-shortest-seek-time-first">最短寻道时间优先算法 (SSTF, Shortest Seek Time First)</h4>

<ul>
  <li>
    <p><strong>算法思想</strong></p>

    <p>优先旋转距当前磁头最近的访问请求进行服务，主要考虑寻道优先</p>
  </li>
  <li>
    <p><strong>优点</strong></p>

    <p>改善磁盘平均服务时间</p>
  </li>
  <li>
    <p><strong>缺点</strong></p>

    <p>可能产生“饥饿”现象</p>
  </li>
</ul>

<h4 id="扫描算法-scan">扫描算法 (SCAN)</h4>

<ul>
  <li>
    <p><strong>算法思想</strong></p>

    <p>当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，直到访问到最边缘，之后改变运动方向，继续移动，如此反复</p>
  </li>
  <li>
    <p><strong>优点</strong></p>

    <p>克服饥饿问题</p>
  </li>
  <li>
    <p><strong>缺点</strong></p>

    <p>两侧磁道被访问的频率低于中间磁道</p>
  </li>
</ul>

<h4 id="循环扫描算法-cscan">循环扫描算法 (CSCAN)</h4>

<ul>
  <li>
    <p><strong>算法思想</strong></p>

    <ul>
      <li>按照所要访问的柱面位置的次序旋转访问者</li>
      <li>移动臂到达最后一个柱面时，立即带动读写磁头快速返回 0 号柱面</li>
      <li>返回时不为任何等待访问者服务</li>
      <li>返回后可再次扫描</li>
    </ul>
  </li>
  <li>
    <p><strong>优点</strong></p>

    <p>克服饥饿问题</p>

    <p>避免扫描算法中两侧磁道被访问的频率低的缺点</p>
  </li>
</ul>

<h4 id="look">LOOK</h4>

<p>SCAN + 只处理与当前移动方向相同的请求</p>

<h4 id="c-look">C-LOOK</h4>

<p>CSCAN + 只处理与当前移动方向相同的请求</p>

<h4 id="n-step-scan">N-Step-SCAN</h4>

<p>将磁盘请求队列分成若干个长度为 N 的子队列，解决磁头粘贴问题</p>

<h4 id="fscans">FSCANS</h4>

<p>分为当前请求和新请求两个区域</p>

<h3 id="磁盘空间的管理">磁盘空间的管理</h3>

<h4 id="位图">位图</h4>

<p>用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应 1 位，分配的物理块为 0，否则为 1.</p>

<h4 id="空闲表法">空闲表法</h4>

<p>将所有空闲块记录在一个表中，称为空闲表。</p>

<p>主要记录两项内容：起始块号，块数</p>

<h4 id="空闲链表法">空闲链表法</h4>

<p>把所有空闲块链成一个表</p>

<h4 id="成组链接法">成组链接法</h4>

<p>把空白物理块分成组，在通过指针把组与组之间链接起来</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608084048833-952725257.png" alt="image" /></p>

<p>优点：</p>

<ol>
  <li>空白块号等级不占用额外空间</li>
  <li>节省时间</li>
  <li>采用后进先出的栈结构思想</li>
</ol>

<h3 id="raid">==RAID==</h3>

<blockquote>
  <p><strong>RAID</strong>，廉价冗余磁盘阵列(Redundant Arrays of Inexpensive Disks)</p>
</blockquote>

<p>RAID 的基本思想是把多个相对便宜的硬盘组合起来，称为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵，容量巨大的硬盘。</p>

<h5 id="raid0条带化存储">RAID0，条带化存储</h5>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608090408026-1156753631.png" alt="image" /></p>

<h5 id="raid1镜像存储">RAID1，镜像存储</h5>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608090427293-1271398581.png" alt="image" /></p>

<h5 id="raid2海明码检验条带存储">RAID2，海明码检验条带存储</h5>

<blockquote>
  <p><strong>海明码</strong>是一种在原始数据中加入若干校验码来进行错误检测和纠正的编码技术，其中第 2n 位（ 1, 2, 4, 8, … ）是校验码，其他位置是数据码。</p>
</blockquote>

<p><img src="C:\Users\Ericaaaaaaaa\AppData\Roaming\Typora\typora-user-images\image-20210608090507115.png" alt="image-20210608090507115" /></p>

<p><strong>特点</strong>：</p>

<ul>
  <li>并行存取，各个驱动器同步工作</li>
  <li>使用海明编码来进行错误检测和纠正，数据传输效率高</li>
  <li>需要多个磁盘来存放海明校验码信息，冗余磁盘数量与数据盘数量的对数成正比</li>
  <li>是一种在多磁盘易出错环境中的有效选择</li>
</ul>

<h5 id="raid3奇偶校验条带存储共享校验盘数据条带存储单位为字节">RAID3，奇偶校验条带存储，共享校验盘，数据条带存储单位为字节</h5>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608091741456-1642683777.png" alt="image" /></p>

<p><strong>特点</strong>：</p>

<ul>
  <li>将磁盘分组，读写要访问组中所有盘，每组中有一个盘作为校验盘</li>
  <li>校验盘一般采用奇偶检验</li>
  <li>缺点：恢复时间长</li>
</ul>

<h5 id="raid4奇偶校验条带存储共享校验盘数据条带存储单位为块">RAID4，奇偶校验条带存储，共享校验盘，数据条带存储单位为块</h5>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608092051313-679702965.png" alt="image" /></p>

<p><strong>特点</strong>：</p>

<ul>
  <li>冗余代价与 RAID3 相同</li>
  <li>访问数据的方法与 RAID3 不同</li>
  <li>使用较少的磁盘参与操作，以使磁盘阵列可以并行进行多个数据的磁盘操作</li>
</ul>

<h5 id="raid5奇偶校验条带存储校验数据分布式存储数据条带存储单位为块">RAID5，奇偶校验条带存储，校验数据分布式存储，数据条带存储单位为块</h5>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608092249960-275974776.png" alt="image" /></p>

<p><strong>特点</strong>：</p>

<ul>
  <li>更适用于小数据块和随机读写的数据</li>
  <li>大部分传输只对一块磁盘操作，并可并行操作</li>
  <li>有“写缺失”，即每次写操作将产生四个实际上的读/写操作，其中两次读旧的数据及奇偶信息，两次写新的数据及奇偶信息</li>
  <li>当有<strong>两块</strong>盘损坏时，整个 RAID 数据失效</li>
</ul>

<h5 id="raid6奇偶检验条带存储">RAID6，奇偶检验条带存储</h5>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608093206707-1284637403.png" alt="image" /></p>

<p><strong>特点</strong>：</p>

<ul>
  <li>需要分配给奇偶校验信息更大的磁盘空间</li>
  <li>写入数据需要访问 1 个数据盘和 2 个冗余盘，相对 RAID5 写损失更大</li>
  <li><strong>可以容忍双盘出错</strong></li>
  <li>存储开销是 RAID5 的两倍</li>
</ul>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608094941707-67533411.png" alt="image" /></p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608095002914-1284449107.png" alt="image" /></p>

<h3 id="提高-io-速度">提高 I/O 速度</h3>

<p>提高 I/O 速度的主要途径：</p>

<ul>
  <li>选择性能更好的磁盘</li>
  <li>并行化</li>
  <li>采用适当的调度算法</li>
  <li>设置磁盘高速缓冲区</li>
</ul>

<h4 id="提高磁盘-io-速度缓存">提高磁盘 I/O 速度：缓存</h4>

<h4 id="优化数据布局">优化数据布局</h4>

<h2 id="文件系统">文件系统</h2>

<h3 id="基本概念-6">基本概念</h3>

<h4 id="文件">文件</h4>

<ul>
  <li>一组带标识（文件名）的，在逻辑上有完整意义的信息项序列</li>
  <li><strong>数据的存储和访问单位</strong></li>
  <li><strong>信息项</strong>：构成文件内容的基本单位（单个字节，或多个字节），各信息项之间具有顺序关系</li>
  <li>文件内容的意义：由文件建立者和使用者解释</li>
  <li>文件包括：
    <ul>
      <li><strong>文件体</strong>：文件本身的内容</li>
      <li><strong>文件说明</strong>：文件存储和管理的相关信息，如：文件名、文件内部标识、文件存储地址、访问权限、访问时间等</li>
    </ul>
  </li>
  <li>文件是一种 <strong>抽象</strong> 机制，提供了一种把信息保存在磁盘等存储设备上，并且便于以后访问的方法。</li>
  <li>可以视为 <strong>一个单独的连续的逻辑地址空间</strong>，其大小即为文件的大小，与进程的地址空间无关</li>
</ul>

<h4 id="文件管理">文件管理</h4>

<ul>
  <li>用户视角：使用 <strong>逻辑文件</strong></li>
  <li>操作系统视角：组织和管理 <strong>物理文件</strong></li>
</ul>

<h4 id="文件系统-1">文件系统</h4>

<h5 id="定义-2">定义</h5>

<blockquote>
  <p><strong>文件系统</strong> 是操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用</p>
</blockquote>

<p>操作系统中与文件管理有关的那部分软件和被管理的文件以及实施管理所需要的数据结构的总体</p>

<h5 id="目的">目的</h5>

<p>为系统管理者和用户提供了对文件的透明存取（按名存取）</p>

<h5 id="任务目标">任务目标</h5>

<ul>
  <li>方便的文件访问</li>
  <li>并发文件访问和控制</li>
  <li>统一的用户接口</li>
  <li>多种文件访问权限</li>
  <li>执行效率</li>
  <li>差错恢复</li>
</ul>

<h5 id="文件系统要完成的任务">文件系统要完成的任务</h5>

<ol>
  <li>统一管理磁盘空间，实现磁盘空间的分配与回收</li>
  <li>实现文件按名存取：名字空间 – 映射 –&gt; 磁盘空间</li>
  <li>实现文件信息的共享，并提供文件的保护、保密手段</li>
  <li>向用户提供一个方便使用、易于维护的接口，并向用户提供有关统计信息</li>
  <li>提高文件系统性能</li>
  <li>提供与 I/O 系统的统一接口</li>
</ol>

<h4 id="文件名">文件名</h4>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">文件名.扩展名</code></p>
</blockquote>

<h4 id="文件类型">文件类型</h4>

<ul>
  <li><strong>按性质和用途</strong>：系统文件、库文件、用户文件</li>
  <li><strong>按数据形式</strong>：源文件、目标文件、可执行文件</li>
  <li><strong>按对文件实施的保护级别</strong>：只读文件、读写文件、执行文件、不保护文件</li>
  <li><strong>按逻辑结构分</strong>：有结构文件、无结构文件</li>
  <li><strong>按文件中物理结构分</strong>：顺序文件、链接文件、索引文件</li>
</ul>

<h4 id="文件的逻辑结构">文件的逻辑结构</h4>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608101217180-1343124664.png" alt="image" /></p>

<h5 id="以字节为单位的流式结构">以字节为单位的流式结构</h5>

<h5 id="记录式文件结构">记录式文件结构</h5>

<h5 id="树形结构">树形结构</h5>

<h4 id="典型的文件结构">典型的文件结构</h4>

<ul>
  <li><strong>流式文件</strong>：构成文件的基本单位是字符。文件是有逻辑意义、无结构的一串字符的集合</li>
  <li><strong>记录式文件</strong>：文件由若干记录组成，可以按记录进行读写，查找等操作，每条记录由其内部结构</li>
</ul>

<h4 id="文件存取方式">文件存取方式</h4>

<ul>
  <li>顺序存取</li>
  <li>随机存取：提供读写位置（当前位置）</li>
</ul>

<h4 id="文件存储介质">文件存储介质</h4>

<ul>
  <li>典型的存储介质：磁盘(包括 SSD)、磁带、光盘等</li>
  <li>物理块：数据存储、传输和分配的单位，存储设备通常划分为大小相等的物理块，统一编号</li>
</ul>

<h4 id="文件基本操作">文件基本操作</h4>

<p>创建、删除、打开、关闭、读、写、修改文件名、设置文件读写位置</p>

<h4 id="目录">目录</h4>

<blockquote>
  <p><strong>目录</strong> 是由文件说明索引组成的用于文件检索的特殊文件。目录的内容主要是文件访问和控制的信息（不包括文件内容）</p>
</blockquote>

<h5 id="目录内容">目录内容</h5>

<ul>
  <li>基本信息
    <ul>
      <li>文件名</li>
      <li>别名的数目</li>
    </ul>
  </li>
  <li>文件类型
    <ul>
      <li>有/无结构</li>
      <li>内容</li>
      <li>用途</li>
      <li>属性</li>
      <li>文件组织</li>
    </ul>
  </li>
  <li>地址信息
    <ul>
      <li>存放位置</li>
      <li>文件长度</li>
    </ul>
  </li>
  <li>访问控制信息
    <ul>
      <li>文件所有者</li>
      <li>访问权限</li>
    </ul>
  </li>
  <li>使用信息
    <ul>
      <li>创建时间</li>
      <li>最后一次读访问的时间和用户</li>
      <li>最后一次写访问的时间和用户</li>
    </ul>
  </li>
</ul>

<h5 id="目录操作">目录操作</h5>

<h5 id="目录分类">目录分类</h5>

<h6 id="单极文件目录">单极文件目录</h6>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608140317859-581897839.png" alt="image" /></p>

<ul>
  <li><strong>文件目录的每个表目应包含：</strong>
    <ul>
      <li>文件符号名</li>
      <li>文件所在物理地址</li>
      <li>文件结构信息</li>
      <li>存取控制信息</li>
      <li>管理信息</li>
    </ul>
  </li>
  <li><strong>特点</strong>
    <ul>
      <li>结构简单</li>
      <li>文件多时，目录检索时间长</li>
      <li>存在命名冲突问题</li>
      <li>不便于实现共享</li>
    </ul>
  </li>
</ul>

<h6 id="二级文件目录">二级文件目录</h6>

<p>在根目录下，每个用户对应一个目录（第二级目录），在用户目录下是该用户的文件，而不再有下级目录。适用于多用户系统，各用户可有自己的专用目录</p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608140258846-598532483.png" alt="image" /></p>

<h6 id="多级文件目录层次目录">多级文件目录（层次目录）</h6>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608140720749-1593648631.png" alt="image" /></p>

<p><strong>实现方式</strong></p>

<ul>
  <li>在较高的目录级，其目录表包含下一级目录名以及一个指向其目录的指针</li>
  <li>在最后一级目录，这个指针指向文件的物理地址</li>
</ul>

<p><strong>访问方式</strong></p>

<ul>
  <li><strong>绝对路径名</strong>：从根目录开始依次经由各级目录名</li>
  <li><strong>相对路径</strong>：结合当前路径的相对路径</li>
  <li><strong>当前目录</strong>：也叫工作目录</li>
  <li><strong>上一级目录</strong>：根目录的上级目录是它本身</li>
</ul>

<p><strong>多级目录的特点</strong></p>

<ul>
  <li><strong>层次清楚</strong></li>
  <li><strong>可解决文件重名问题</strong></li>
  <li><strong>查找速度快</strong></li>
  <li><strong>目录级别太多时，会增加路径检索时间</strong></li>
</ul>

<h3 id="实现方法">实现方法</h3>

<h4 id="文件控制块-fcb-file-control-block">文件控制块 (FCB, File Control Block)</h4>

<p>为管理文件而设置的数据结构，保存管理文件所需的所有有关信息（文件属性或元数据）</p>

<ul>
  <li>基本信息</li>
  <li>访问控制信息</li>
  <li>使用信息</li>
</ul>

<h4 id="文件常用属性">文件常用属性</h4>

<ul>
  <li>文件名</li>
  <li>文件号</li>
  <li>文件大小</li>
  <li>文件地址</li>
  <li>创建时间</li>
  <li>最后修改时间</li>
  <li>最后访问时间</li>
  <li>保护口令</li>
  <li>创建者</li>
  <li>当前拥有者</li>
  <li>文件类型</li>
  <li>共享计数</li>
  <li>各种标志（只读、隐藏、系统、归档、ASCII/二进制、顺序/随机访问、临时文件、锁）</li>
</ul>

<h4 id="文件逻辑结构和物理结构">==文件逻辑结构和物理结构==</h4>

<ul>
  <li>
    <p>文件逻辑结构（文件组织）</p>
  </li>
  <li>
    <p>文件物理结构</p>

    <p>文件在存储介质上的存放方式</p>

    <p>主要结构：连续、索引、串联</p>
  </li>
</ul>

<h5 id="连续结构">连续结构</h5>

<ul>
  <li>优点
    <ul>
      <li>结构简单、实现容易，不需要额外的空间开销</li>
      <li>支持顺序和随机存取，顺序存取速度快</li>
      <li>连续存取时速度快</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>文件长度一经固定便不易改变</li>
      <li>不利于文件的动态增加和修改</li>
    </ul>
  </li>
  <li>适用于变化不大的顺序访问的文件</li>
</ul>

<h5 id="串联--链接文件结构">串联 / 链接文件结构</h5>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210609184441018-31137670.png" alt="image" /></p>

<ul>
  <li>优点
    <ul>
      <li>空间利用率高；能较好的利用辅助空间</li>
      <li>文件动态扩充和修改容易</li>
      <li>顺序存取效率高</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>随机存取效率太低，如果访问文件最后的内容，实际上要访问整个文件</li>
      <li>可靠性问题：如指针出错</li>
      <li>链接指针可能占用一定的空间</li>
    </ul>
  </li>
</ul>

<h5 id="索引结构">索引结构</h5>

<p>系统为每个文件建立逻辑块号与物理块号的对照表，称为文件的索引表。文件由数据文件和索引表构成，这种文件称为索引文件</p>

<ul>
  <li>索引表位置：文件目录中，文件的开头等</li>
  <li>索引表大小：固定大小，非固定大小</li>
</ul>

<h6 id="索引文件结构">索引文件结构</h6>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608144534379-292679924.png" alt="image" /></p>

<h6 id="索引文件的操作">索引文件的操作</h6>

<p>索引文件在存储区中占两个区：索引区和数据区</p>

<ul>
  <li>索引区存放索引表</li>
  <li>数据区存放数据文件本身</li>
</ul>

<p>访问索引文件需要两步操作：</p>

<ul>
  <li>查文件索引号，由逻辑块号查到物理块号</li>
  <li>由此磁盘块号而获得要求的信息</li>
</ul>

<h6 id="优缺点-2">优缺点</h6>

<ul>
  <li>优点
    <ul>
      <li>既能顺序存取，又能随机存取</li>
      <li>满足文件动态增长、插入删除的要求</li>
      <li>能充分利用外存空间</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>索引表本身带来系统开销</li>
    </ul>
  </li>
</ul>

<h6 id="索引表的组织">索引表的组织</h6>

<ul>
  <li>
    <p><strong>链接模式</strong></p>

    <p>一个盘一块索引表，多个索引表链接起来</p>
  </li>
  <li>
    <p><strong>多级索引</strong></p>

    <p>将一个大文件的所有索引表（二级索引）的地址放在另一个索引表（一级索引）中</p>
  </li>
  <li>
    <p><strong>综合模式</strong></p>

    <p>直接索引与间接索引方式的结合</p>
  </li>
</ul>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210609184943595-1813669943.png" alt="image" /></p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210609185046041-753863180.png" alt="image" /></p>

<h4 id="文件存储器存储空间的管理">文件存储器存储空间的管理</h4>

<h5 id="空白文件目录">空白文件目录</h5>

<p><strong>目录的实现</strong></p>

<ul>
  <li>
    <p>直接法：目录项 = 文件名 + FCB 信息</p>
  </li>
  <li>
    <p>间接法：目录项 = 文件名 + FCB 地址</p>
  </li>
</ul>

<p><strong>长文件名的处理方法</strong></p>

<p><img src="https://img2020.cnblogs.com/blog/2324053/202106/2324053-20210608145344808-1739192984.png" alt="image" /></p>

<p><strong>符号文件目录的查询技术</strong></p>

<ul>
  <li>顺序查询法</li>
  <li>Hash 方法</li>
</ul>

<p><strong>便于共享的目录组织</strong></p>

<p>硬连接 vs 软连接</p>

<blockquote>
  <p>【硬连接】</p>

  <p>硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>

  <p>【软连接】</p>

  <p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p>
</blockquote>

<p><strong>保护文件的方法</strong></p>

<ul>
  <li>
    <p>建立副本</p>

    <p>把同一个文件保存到多个存储介质上</p>

    <ul>
      <li>优点
        <ul>
          <li>方法简单</li>
        </ul>
      </li>
      <li>缺点
        <ul>
          <li>设备费用和系统开销大</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>定时转储</p>

    <p>每隔一定时间把文件转储到其他存储介质上</p>
  </li>
  <li>
    <p>规定文件权限</p>
  </li>
</ul>

<h5 id="空白物理块链">空白物理块链</h5>

<h5 id="位视图">位视图</h5>

<h4 id="提高文件系统性能块高速缓存">提高文件系统性能：块高速缓存</h4>

<p><strong>块高速缓存(Block Cache)</strong> 又称为文件缓存、磁盘高速缓存、缓冲区高速缓存。是指在内存中位磁盘块设置的一个缓冲区，保存了磁盘中某些块的副本</p>

<h4 id="基于日志结构的文件系统">基于日志结构的文件系统</h4>

<h5 id="lfs">LFS</h5>

<ul>
  <li>将磁盘看作一个日志系统：log</li>
  <li>日志 log 是一个数据结构，所有的写操作在日志头完成</li>
  <li>文件顺序添加到磁盘上</li>
</ul>

<h5 id="ufs">UFS</h5>

<h3 id="文件系统实例分析">文件系统实例分析</h3>

<h4 id="fat-文件系统">FAT 文件系统</h4>

<ul>
  <li>簇（块）大小：1、2、3、8、16、32或64扇区。簇由若干个扇区组成，在一个文件卷中从 0 开始对簇编号</li>
  <li>文件系统的数据记录在“引导扇区”中</li>
  <li>文件分配表（FAT, File Allocation Table）的作用：描述簇的分配状态、标注下一簇的簇号等</li>
  <li>FAT 表项：2 字节(16 位)</li>
  <li>目录项：32 字节</li>
  <li>根目录大小固定</li>
</ul>

<h4 id="linux-文件系统">Linux 文件系统</h4>

<h5 id="ext2-文件系统索引节点"><strong>Ext2</strong> 文件系统——索引节点</h5>

<p>利用索引结点 (inode) 来描述文件系统的拓扑结构。在单个文件系统中，每个文件对应一个索引节点，而每个索引节点由一个唯一的整数标识符。文件系统中所有文件的索引节点保存在索引节点表中。</p>

<blockquote>
  <p>一个文件系统允许的inode节点数是有限的，如果文件数量太多，即使每个文件都是0字节的空文件，系统最终也会因为节点空间耗尽而不能再创建文件。</p>
</blockquote>

<h5 id="ext2-文件系统目录">Ext2 文件系统——目录</h5>

<p>Ext2 文件系统中的目录实际上是一种特殊文件，有对应的索引节点，索引节点指向的数据块中包含该目录中所有目录项（文件、目录、符号链接等），每个目录项有自己的索引节点</p>]]></content><author><name>ericaaaaaaaa</name></author><category term="ComputerArchitecture" /><category term="note" /><category term="system" /><category term="operating-system" /><summary type="html"><![CDATA[操作系统]]></summary></entry><entry><title type="html">Computer Organization</title><link href="http://localhost:4000/computerarchitecture/2021/01/11/ComputerOrganization.html" rel="alternate" type="text/html" title="Computer Organization" /><published>2021-01-11T00:00:00+08:00</published><updated>2021-01-11T00:00:00+08:00</updated><id>http://localhost:4000/computerarchitecture/2021/01/11/ComputerOrganization</id><content type="html" xml:base="http://localhost:4000/computerarchitecture/2021/01/11/ComputerOrganization.html"><![CDATA[<h1 id="computer-organization">Computer Organization</h1>

<p>$Ericaaaaaaaa$</p>

<p>$Jan,\ 2021$</p>

<h2 id="组合逻辑设计">组合逻辑设计</h2>

<h3 id="逻辑门电路">逻辑门电路</h3>

<h4 id="ttlmos-集成门电路">TTL、MOS 集成门电路</h4>

<ul>
  <li>
    <p>晶体管</p>

    <ul>
      <li>
        <p>COMS</p>
      </li>
      <li>
        <p><strong>N 型</strong></p>

        <p><img src="/assets/images/post/image-20210101221532955.png" alt="image-20210101221532955" /></p>
      </li>
      <li>
        <p><strong>P 型</strong></p>

        <p><img src="/assets/images/post/image-20210101221602975.png" alt="image-20210101221602975" /></p>
      </li>
    </ul>

    <table>
      <thead>
        <tr>
          <th>Gate</th>
          <th>N 型</th>
          <th>P 型</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>0 (低电平)</td>
          <td>OFF (截止)</td>
          <td>ON (导通)</td>
        </tr>
        <tr>
          <td>1 (高电平)</td>
          <td>ON (导通)</td>
          <td>OFF (截止)</td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>注意事项
        <ul>
          <li>导通时<strong>应该让 <code class="language-plaintext highlighter-rouge">Sourse</code> 和 <code class="language-plaintext highlighter-rouge">Gate</code> 之间电压有反差</strong></li>
          <li>避免无源驱动</li>
          <li>避免短路</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>利用晶体管构建门电路</p>

    <ul>
      <li>
        <p>NAND</p>

        <p><img src="/assets/images/post/image-20210101221946733.png" alt="image-20210101221946733" /></p>
      </li>
      <li>
        <p>NOR</p>

        <p><img src="/assets/images/post/image-20210101222004949.png" alt="image-20210101222004949" /></p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="与门非门或门复合逻辑门电路及其性能指标">与门、非门、或门、复合逻辑门电路及其性能指标</h4>

<ul>
  <li>
    <p>门电路</p>

    <table>
      <thead>
        <tr>
          <th>名称</th>
          <th>示意图</th>
          <th>真值表</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>NOT</td>
          <td>![image-20210101222127129](/assets/images/post/image-20210101222127129.png)</td>
          <td>![image-20210101222144259](/assets/images/post/image-20210101222144259.png)</td>
        </tr>
        <tr>
          <td>AND</td>
          <td>![image-20210101222138567](/assets/images/post/image-20210101222138567.png)</td>
          <td>![image-20210101222149786](/assets/images/post/image-20210101222149786.png)</td>
        </tr>
        <tr>
          <td>OR</td>
          <td>![image-20210101222208179](/assets/images/post/image-20210101222208179.png)</td>
          <td>![image-20210101222157106](/assets/images/post/image-20210101222157106.png)</td>
        </tr>
        <tr>
          <td>XOR</td>
          <td>![image-20210101222250073](/assets/images/post/image-20210101222250073.png)</td>
          <td>![image-20210101222259353](/assets/images/post/image-20210101222259353.png)</td>
        </tr>
        <tr>
          <td>NAND</td>
          <td>![image-20210101222216037](/assets/images/post/image-20210101222216037.png)</td>
          <td>![image-20210101222222169](/assets/images/post/image-20210101222222169.png)</td>
        </tr>
        <tr>
          <td>NOR</td>
          <td>![image-20210101222232021](/assets/images/post/image-20210101222232021.png)</td>
          <td>![image-20210101222240024](/assets/images/post/image-20210101222240024.png)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="布尔代数">布尔代数</h3>

<h4 id="布尔代数基本原理">布尔代数基本原理</h4>

<h4 id="逻辑函数表达式标准表达式最小项表达式最大项表达式">逻辑函数表达式：标准表达式（最小项表达式、最大项表达式）</h4>

<h4 id="逻辑函数表达式的简化法合并乘积项法吸收项法配项法">逻辑函数表达式的简化法：（合并乘积项法、吸收项法、配项法）</h4>

<ul>
  <li>
    <p>合并乘积项法——利用互补律消去一个变量</p>

    <p>$F = A(BC + \overline{B}\overline{C}) + AB\overline{C} + A\overline{B}C$</p>

    <p>$\ \ \ \ =ABC + A\overline{B}\overline{C} + AB\overline{C} + A\overline{B}C$  利用分配律展开</p>

    <p>$\ \ \ \ =(ABC + A\overline{B}C) + (A\overline{B}\overline{C} + AB\overline{C}))$   合并</p>

    <p>$\ \ \ \ =AC(B + \overline{B}) + A\overline{C}(\overline{B} + B)$ 互补律</p>

    <p>$\ \ \ \ =AC + A\overline{C}$ 互补律</p>

    <p>$\ \ \ \ =A(C + \overline{C})$  互补律</p>

    <p>$\ \ \ \ =A$</p>
  </li>
  <li>
    <p>吸收项法——利用吸收律和包含律减少“与”项</p>

    <p>$F = A\overline{B} + \overline{A}B + ABCD + \overline{A}\overline{B}CD$</p>

    <p>$\ \ \ \ =(A\overline{B} + \overline{A}B) + (AB + \overline{A}\overline{B})CD$</p>

    <p>$\ \ \ \ =(A\overline{B}+\overline{A}B) + \overline{A\overline{B} + \overline{A}B}CD\ \ \ \ \ \ 吸收律: A \pm AB = A\pm B$</p>

    <p>$\ \ \ \ =A\overline{B} + \overline{A}B + CD$</p>
  </li>
  <li>
    <p>配项法——利用互补律，配在乘积项上</p>

    <p>$F = AB + \overline{A}\overline{B}C + BC$</p>

    <p>$\ \ \ \ =AB + \overline{A}\overline{B}C + BC(A +\overline{A})$</p>

    <p>$\ \ \ \ =AB + \overline{A}\overline{B}C + ABC + \overline{A}BC$</p>

    <p>$\ \ \ \ =(AB + ABC) + (\overline{A}\overline{B}C + \overline{A}BC)$</p>

    <p>$\ \ \ \ =AB(1 + C) + \overline{A}C(B + \overline{B})$</p>

    <p>$\ \ \ \ =AB + \overline{A}C$</p>
  </li>
  <li>
    <p><strong>卡诺图</strong> $(K-map)$</p>

    <p><img src="/assets/images/post/image-20210101225103542.png" alt="image-20210101225103542" /></p>

    <p>$y = bd + b’d’ + acd$</p>

    <p>用卡诺图生成的最简表达式不唯一。</p>

    <p>使用卡诺图可以方便的化简多个布尔表达式。</p>

    <ul>
      <li>卡诺图采用<strong>格雷码</strong>，即相邻方格中有一个变量的值不同。</li>
      <li>卡诺图是<strong>环绕的</strong></li>
      <li>用卡诺图得到最小化等式的规则
        <ul>
          <li>用<strong>最少</strong>的圈来圈住全部所有的1</li>
          <li>每个圈中的<strong>所有</strong>方格都必须包含1</li>
          <li>每个圈必须是<strong>矩形</strong>，其<strong>每个边长必须是 2 的整数次幂</strong>(例如 1, 2, 4)</li>
          <li>每个圈必须<strong>尽可能的大</strong></li>
          <li>圈可以<strong>环绕卡诺图的边界</strong></li>
          <li>如果可以使用更少数量的圈，则卡诺图中一个为 1 的方格<strong>可以被多次圈住</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="verilog-hdl-介绍">Verilog HDL 介绍</h3>

<p>【Verilog HDL】 是硬件描述语言的一种，用于数字电子系统设计。</p>

<p>【HDL】$Hardware\ Description\ Language$ 硬件描述语言</p>

<p>【VHDL】$VHSIC\ Hardware\ Description\ Language$ 高速集成电路硬件描述语言</p>

<p>【VHSIC】$Very\ High\ Speed\ Integrated\ Circuit$ 高速集成电路</p>

<h3 id="基本组合逻辑部件设计与分析">基本组合逻辑部件设计与分析</h3>

<h4 id="运算单元电路加法器比较器">运算单元电路（加法器、比较器）</h4>

<ul>
  <li>
    <p>一位全加器</p>

    <ul>
      <li>
        <p>末位</p>

        <ul>
          <li>列出真值表</li>
        </ul>

        <table>
          <thead>
            <tr>
              <th>$a_0$</th>
              <th>$b_0$</th>
              <th>$s_0$</th>
              <th>$c_1\ (Carry Out Bit)$</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr>
            <tr>
              <td>0</td>
              <td>1</td>
              <td>1</td>
              <td>0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>0</td>
              <td>1</td>
              <td>0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>1</td>
              <td>0</td>
              <td>1</td>
            </tr>
          </tbody>
        </table>

        <ul>
          <li>通过真值表写出表达式</li>
        </ul>

        <p>$s_0 = a_0\ XOR\  b_0$</p>

        <p>$c_1 = a_0\ AND\  b_0$</p>
      </li>
      <li>
        <p>其它位</p>

        <ul>
          <li>列出真值表</li>
        </ul>

        <table>
          <thead>
            <tr>
              <th>$a_i$</th>
              <th>$b_i$</th>
              <th>$c_i$</th>
              <th>$s_i$</th>
              <th>$c_{i+1}\ (Carry Out Bit)$</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr>
            <tr>
              <td>0</td>
              <td>0</td>
              <td>1</td>
              <td>1</td>
              <td>0</td>
            </tr>
            <tr>
              <td>0</td>
              <td>1</td>
              <td>0</td>
              <td>1</td>
              <td>0</td>
            </tr>
            <tr>
              <td>0</td>
              <td>1</td>
              <td>1</td>
              <td>0</td>
              <td>1</td>
            </tr>
            <tr>
              <td>1</td>
              <td>0</td>
              <td>0</td>
              <td>1</td>
              <td>0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>0</td>
              <td>1</td>
              <td>0</td>
              <td>1</td>
            </tr>
            <tr>
              <td>1</td>
              <td>1</td>
              <td>0</td>
              <td>0</td>
              <td>1</td>
            </tr>
            <tr>
              <td>1</td>
              <td>1</td>
              <td>1</td>
              <td>1</td>
              <td>1</td>
            </tr>
          </tbody>
        </table>

        <ul>
          <li>
            <p>通过真值表写出表达式</p>

            <p>$s_i = \overline{a_i}\overline{b_i}c_i + \overline{a_i}b_i\overline{c_i} + a_i\overline{b_i}\overline{c_i} + a_ib_ic_i$</p>

            <p>$c_{i+1} = a_ib_i + a_ic_i + b_ic_i$</p>
          </li>
        </ul>
      </li>
      <li>
        <p>根据表达式构造一位全加器</p>

        <p><img src="/assets/images/post/image-20210103110642597.png" alt="image-20210103110642597" /></p>
      </li>
      <li>
        <p>行波进位加法器</p>

        <p><img src="/assets/images/post/image-20210103110722807.png" alt="image-20210103110722807" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>比较器</p>

    <p><img src="/assets/images/post/image-20210104203344207.png" alt="image-20210104203344207" /></p>
  </li>
</ul>

<h4 id="多路选择器译码器编码器">多路选择器，译码器，编码器</h4>

<ul>
  <li>
    <p>8 选 1 数据选择器</p>

    <p><img src="/assets/images/post/image-20210103095704509.png" alt="image-20210103095704509" /><img src="/assets/images/post/image-20210103100252686.png" alt="image-20210103100252686" /></p>

    <ol>
      <li>
        <p>功能①</p>

        <ul>
          <li>
            <p>控制端共三位，为 $A_2A_1A_0$，通过 $A_0,\ A_1,\ A_2$ 的组合选择某个 $D$</p>
          </li>
          <li>
            <p>$Y = \overline{A_2}\overline{A_1}\overline{A_0}D_0 + \overline{A_2}\overline{A_1}A_0D_1 + \overline{A_2}A_1\overline{A_0}D_2 + \overline{A_2}A_1A_0D_3 + A_2\overline{A_1}\overline{A_0}D_4 + A_2\overline{A_1}A_0D_5 + A_2A_1\overline{A_0}D_6 + A_2A_1A_0D_7$</p>

            <p>$\ \ \ =m_0D_0 + m_1D_1 + m_2D_2 + m_3D_3 + m_4D_4 + m_5D_5 + m_6D_6 + m_7D_7$</p>
          </li>
        </ul>
      </li>
      <li>
        <p>功能②</p>

        <ul>
          <li>
            <p>$D_7 - D_0$ 为控制端——多功能运算电路</p>

            <blockquote>
              <p>通过 $D_7 - D_0$ 取不同的值，从输入变量 $A_2,\ A_1,\ A_0$ 的各个最小项中选取某几个最小项输出，实现不同的运算电路。</p>

              <p>共 $2^8 = 256$ 种功能——包含 3 变量的各种最小项表达式，可实现任意<strong>组合逻辑电路</strong>的设计</p>
            </blockquote>
          </li>
          <li>
            <p>$Y = \overline{A_2}\overline{A_1}\overline{A_0}D_0 + \overline{A_2}\overline{A_1}A_0D_1 + \overline{A_2}A_1\overline{A_0}D_2 + \overline{A_2}A_1A_0D_3 + A_2\overline{A_1}\overline{A_0}D_4 + A_2\overline{A_1}A_0D_5 + A_2A_1\overline{A_0}D_6 + A_2A_1A_0D_7$</p>

            <p>$\ \ \ =m_0D_0 + m_1D_1 + m_2D_2 + m_3D_3 + m_4D_4 + m_5D_5 + m_6D_6 + m_7D_7$</p>
          </li>
        </ul>
      </li>
    </ol>

    <blockquote>
      <p>【例】利用数据选择器实现逻辑函数 $F(A, B, C) = \overline{A}\overline{B}C + \overline{A}B\overline{C} + AB$</p>

      <p>【解】</p>

      <p>$A-A_2, B-A_1, C-A_0$</p>

      <p>$F(A, B, C) = \overline{A}\overline{B}C + \overline{A}B\overline{C} + AB = m_1 + m_2 + m_6 + m_7$</p>

      <p>故：$A_0 = 0, D_1 = 1, D_2 = 1, D_3 = 0, D_4 = 1, D_5 = 0, D_6 = 1, D_7 = 1$</p>
    </blockquote>
  </li>
  <li>
    <p>译码器</p>

    <p><img src="/assets/images/post/image-20210104180528566.png" alt="image-20210104180528566" /></p>
  </li>
</ul>

<h2 id="时序逻辑设计">时序逻辑设计</h2>

<h3 id="锁存器和触发器">锁存器和触发器</h3>

<h4 id="sr-锁存器d-锁存器">SR 锁存器，D 锁存器</h4>

<h4 id="sr-锁存器">SR 锁存器</h4>

<p>Q 与 ~Q 随着 R 与 S 的改变随时改变</p>

<p><img src="/assets/images/post/image-20210104180721227.png" alt="image-20210104180721227" /><img src="/assets/images/post/image-20210104181737359.png" alt="image-20210104181737359" /></p>

<p><img src="/assets/images/post/image-20210104182102227.png" alt="image-20210104182102227" /></p>

<h5 id="d-锁存器-d-latch">D 锁存器 (D-latch)</h5>

<p>在 clk 置位时，D 实时改变 Q 与 ~Q，</p>

<p>在 clk 为0时，D 对 Q 与 ~Q 无影响</p>

<p><img src="/assets/images/post/image-20210104180803157.png" alt="image-20210104180803157" /><img src="/assets/images/post/image-20210104182210605.png" alt="image-20210104182210605" /></p>

<h4 id="d-触发器-d-flip-flop">D 触发器 (D-flip flop)</h4>

<p>在 clk <strong>上升沿</strong>时，Q 同步更新为 D 的值</p>

<p><img src="/assets/images/post/image-20210104180922438.png" alt="image-20210104180922438" /><img src="/assets/images/post/image-20210104182252202.png" alt="image-20210104182252202" /></p>

<h5 id="d-latch-vs-d-flip-flop">D Latch vs. D Flip-Flop</h5>

<p><img src="/assets/images/post/image-20210104182659795.png" alt="image-20210104182659795" /></p>

<h4 id="jk-触发器">JK 触发器</h4>

<h3 id="有限状态机-finite-state-machine-fsm">有限状态机 Finite State Machine (FSM)</h3>

<h4 id="概述">概述</h4>

<ul>
  <li><strong>状态</strong>：电路所处的特定工作阶段</li>
  <li><strong>状态寄存器</strong>：</li>
  <li><strong>状态寄存器的值</strong>：</li>
  <li><strong>次态逻辑</strong>：<em>根据输入和当前状态的编码值，计算下一个状态编码值</em>
    <ul>
      <li>次态逻辑也是组合逻辑</li>
    </ul>
  </li>
  <li><strong>输出逻辑</strong>：根据状态及输入，计算该状态下的输出值</li>
</ul>

<h4 id="表示方法">表示方法</h4>

<p><img src="/assets/images/post/image-20210104184202716.png" alt="image-20210104184202716" /><img src="/assets/images/post/image-20210104184212494.png" alt="image-20210104184212494" /></p>

<h4 id="构造方法">构造方法</h4>

<ol>
  <li>
    <p>规划状态总数</p>
  </li>
  <li>
    <p>构造状态图</p>

    <p>每个状态的转移条件必须是<strong>完备</strong>的</p>
  </li>
  <li>
    <p>根据【输入信号、当前状态编码、下一个状态编码】构造每个寄存器的 D 输入信号的门电路</p>

    <p>方法：真值表→乘积项表达式→最简表达式→最简门电路</p>
  </li>
  <li>
    <p>根据设计需求决定当前状态的输出</p>
  </li>
</ol>

<h4 id="设计要点">设计要点</h4>

<ul>
  <li>
    <p>初始状态</p>
  </li>
  <li>
    <p>复位信号</p>
  </li>
  <li>
    <p>状态编码方式</p>

    <ul>
      <li>二进制编码
        <ul>
          <li>$\log_2^N$ 个触发器表示 $N$ 个状态</li>
          <li>节约逻辑资源，但可能产生毛刺</li>
        </ul>
      </li>
      <li>格雷编码
        <ul>
          <li>$\log_2^N$ 个触发器表示 $N$ 个状态</li>
          <li>节约逻辑资源，但可能产生毛刺</li>
        </ul>
      </li>
      <li>一位独热编码(One Hot Encoding)
        <ul>
          <li>资源消耗多，但无毛刺</li>
          <li>降低次态逻辑和输出逻辑的复杂度，有利于提高时钟频率</li>
          <li>FPGA 具有丰富的寄存器资源，采用一位独热码编码可以有效提高电路的速度和可靠性</li>
        </ul>
      </li>
    </ul>

    <table>
      <thead>
        <tr>
          <th>状态</th>
          <th>二进制编码</th>
          <th>格雷编码</th>
          <th>一位独热编码</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>0</td>
          <td>000</td>
          <td>000</td>
          <td>00000001</td>
        </tr>
        <tr>
          <td>1</td>
          <td>001</td>
          <td>001</td>
          <td>00000010</td>
        </tr>
        <tr>
          <td>2</td>
          <td>010</td>
          <td>011</td>
          <td>00000100</td>
        </tr>
        <tr>
          <td>3</td>
          <td>011</td>
          <td>010</td>
          <td>00001000</td>
        </tr>
        <tr>
          <td>4</td>
          <td>100</td>
          <td>110</td>
          <td>00010000</td>
        </tr>
        <tr>
          <td>5</td>
          <td>101</td>
          <td>111</td>
          <td>00100000</td>
        </tr>
        <tr>
          <td>6</td>
          <td>110</td>
          <td>101</td>
          <td>01000000</td>
        </tr>
        <tr>
          <td>7</td>
          <td>111</td>
          <td>100</td>
          <td>10000000</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="moore-型-fsm">Moore 型 FSM</h4>

<p><img src="/assets/images/post/image-20210104185128315.png" alt="image-20210104185128315" /><img src="/assets/images/post/image-20210104185501599.png" alt="image-20210104185501599" /></p>

<h4 id="mealy-型-fsm">Mealy 型 FSM</h4>

<p><img src="/assets/images/post/image-20210104185140453.png" alt="image-20210104185140453" /><img src="/assets/images/post/image-20210104185432851.png" alt="image-20210104185432851" /></p>

<h4 id="状态机类型的选择">状态机类型的选择</h4>

<p><img src="/assets/images/post/image-20210104185231221.png" alt="image-20210104185231221" /></p>

<h3 id="时序逻辑电路分析">时序逻辑电路分析</h3>

<h4 id="数据寄存器">数据寄存器</h4>

<h4 id="移位寄存器">移位寄存器</h4>

<p>包括时钟、串行输入 $S_{in}$、串行输出$S_{out}$和 N 位并行输出 $Q_{N-1:0}$</p>

<p>移位寄存器可以看作是<em>串行到并行的转换器</em>。输入由 $S_{in}$以串行的方式提供（一次一位）。在 N 个周期后，前面的 N 位输入可以在 Q 中并行访问。</p>

<p><img src="/assets/images/post/image-20210104204430980.png" alt="image-20210104204430980" /></p>

<h4 id="计数器">计数器</h4>

<p>计数器 = 加法器 + 复位寄存器</p>

<p><img src="/assets/images/post/image-20210104191512718.png" alt="image-20210104191512718" /></p>

<h1 id="主存储器">主存储器</h1>

<h2 id="存储单元电路">存储单元电路</h2>

<p><strong>存储器阵列（$memory\ array$）</strong>——可以有效存储大量数据</p>

<ul>
  <li>
    <p>概述</p>

    <ol>
      <li>
        <p>位单元</p>

        <p>存储器阵列由为单元<img src="/assets/images/post/image-20210104205741949.png" alt="image-20210104205741949" />（bit cell）的阵列组成，其中每个为单元存储一位数据。</p>
      </li>
      <li>
        <p>存储器的结构</p>

        <p><img src="https://img2020.cnblogs.com/blog/1593105/202003/1593105-20200319160616110-1518490028.png" alt="img" /></p>
      </li>
    </ol>
  </li>
  <li>
    <p>分类</p>

    <ul>
      <li>动态随机访问存储器（DRAM）</li>
      <li>静态随机访问存储器（SRAM）</li>
      <li>只读存储器（ROM）
        <ul>
          <li>现代ROM不再只读，<strong>也可以写入</strong>。不同点在于ROM的写入时间更长，但是是非易失的。</li>
        </ul>
      </li>
    </ul>

    <blockquote>
      <p>RAM是<strong>易失型</strong>，关掉电源时会丢失数据；ROM是<strong>非易失型</strong>，没有电源也能无期限的保存数据。</p>
    </blockquote>
  </li>
</ul>

<h3 id="sram-存储单元电路-static-random-access-memory">SRAM 存储单元电路 Static Random Access Memory</h3>

<p>不需要刷新存储位</p>

<p><img src="https://img2020.cnblogs.com/blog/1593105/202003/1593105-20200320103836982-1899282128.png" alt="img" /></p>

<h3 id="dram-存储单元电路-dynamic-random-access-memory">DRAM 存储单元电路 Dynamic Random Access Memory</h3>

<p>以电容的充电和放电来存储位。位值存储在电容中，nMOS作为开关。字线作为MOS的开关</p>

<p><img src="https://img2020.cnblogs.com/blog/1593105/202003/1593105-20200320102607807-194114994.png" alt="img" /></p>

<h3 id="rom-存储单元电路">ROM 存储单元电路</h3>

<p>以是否存在晶体管作为是否存储一位。在读过程中，位线被拉高，如果存在MOS，则位线被拉低，不存在MOS则保持高。</p>

<p><img src="https://img2020.cnblogs.com/blog/1593105/202003/1593105-20200320104511490-1402746880.png" alt="img" /></p>

<h2 id="主存储器的结构">主存储器的结构</h2>

<h3 id="sram-芯片的内部结构">SRAM 芯片的内部结构</h3>

<h3 id="dram-芯片的内部结构">DRAM 芯片的内部结构</h3>

<h2 id="存储器的扩展">存储器的扩展</h2>

<h3 id="芯片容量的基本描述">芯片容量的基本描述</h3>

<p><strong>字单元数 × 每个字单元的位数</strong></p>

<ul>
  <li>
    <p>1K × 2：1024个字单元，每个字单元 2 位（二进制位）</p>

    <p><img src="/assets/images/post/image-20210104213022348.png" alt="image-20210104213022348" /></p>
  </li>
  <li>
    <p>64 K × 8：</p>

    <p><img src="/assets/images/post/image-20210104213108434.png" alt="image-20210104213108434" /></p>
  </li>
</ul>

<h3 id="存储器的扩展方法">存储器的扩展方法</h3>

<p><img src="/assets/images/post/image-20210104213156145.png" alt="image-20210104213156145" /></p>

<p><img src="/assets/images/post/image-20210104213224828.png" alt="image-20210104213224828" /></p>

<p><img src="/assets/images/post/image-20210104213241421.png" alt="image-20210104213241421" /></p>

<p><img src="/assets/images/post/image-20210104213300870.png" alt="image-20210104213300870" /></p>

<p><img src="/assets/images/post/image-20210104213324260.png" alt="image-20210104213324260" /></p>

<h2 id="dram-的刷新">DRAM 的刷新</h2>

<p><img src="/assets/images/post/image-20210104213346438.png" alt="image-20210104213346438" /></p>

<p><img src="/assets/images/post/image-20210104213405991.png" alt="image-20210104213405991" /></p>

<h1 id="指令系统与-mips-汇编语言">指令系统与 MIPS 汇编语言</h1>

<h2 id="指令系统概述">指令系统概述</h2>

<h3 id="指令系统的基本要素">指令系统的基本要素</h3>

<h3 id="指令格式">指令格式</h3>

<p><img src="/assets/images/post/image-20210104214340696.png" alt="image-20210104214340696" /></p>

<p><img src="/assets/images/post/image-20210104214118528.png" alt="" /><img src="/assets/images/post/image-20210104214146638.png" alt="image-20210104214146638" /><img src="/assets/images/post/image-20210104214245791.png" alt="image-20210104214245791" />!<img src="/assets/images/post/image-20210110094303699.png" alt="image-20210110094303699" /><img src="/assets/images/post/image-20210110094436402.png" alt="image-20210110094436402" /><img src="/assets/images/post/image-20210110094519161.png" alt="image-20210110094519161" /></p>

<p><img src="/assets/images/post/image-20210104214400175.png" alt="image-20210104214400175" /></p>

<h2 id="mips-指令系统">MIPS 指令系统</h2>

<p><img src="/assets/images/post/image-20210104214413589.png" alt="image-20210104214413589" /><img src="/assets/images/post/image-20210104214425889.png" alt="image-20210104214425889" /></p>

<h2 id="mips-汇编语言编程">MIPS 汇编语言编程</h2>

<h1 id="mips-处理器设计">MIPS 处理器设计</h1>

<h2 id="处理器的功能组成一般设计方法等">处理器的功能、组成、一般设计方法等</h2>

<h2 id="mips-处理器设计概述">MIPS 处理器设计概述</h2>

<h3 id="结构指令集数据通路的基本组件">结构、指令集、数据通路的基本组件</h3>

<h2 id="单周期处理器设计">单周期处理器设计</h2>

<p><img src="D:\大学\大二 秋季\计算机组成原理\p3\main.png" alt="main" /></p>

<h3 id="单周期数据通路和控制器设计">单周期数据通路和控制器设计</h3>

<p><img src="D:\大学\大二 秋季\计算机组成原理\p3\Decoder.png" alt="Decoder" /></p>

<h3 id="单周期处理器性能分析">单周期处理器性能分析</h3>

<h2 id="流水线处理器设计">流水线处理器设计</h2>

<p><img src="/assets/images/post/image-20210104214456135.png" alt="image-20210104214456135" /></p>

<p><img src="D:\verilog HDL\p6\CPU_Pipeline_p6\CPU_Pipeline_p6_02.png" alt="CPU_Pipeline_p6_02" /></p>

<h3 id="流水线数据通路和控制器设计">流水线数据通路和控制器设计</h3>

<h3 id="流水线处理器性能分析">流水线处理器性能分析</h3>

<h3 id="流水线冒险及其处理">流水线冒险及其处理</h3>

<h1 id="高速缓冲存储器-cache">高速缓冲存储器 （Cache）</h1>

<h2 id="程序执行局部性原理">程序执行局部性原理</h2>

<h3 id="时间局部性">时间局部性</h3>

<h3 id="空间局部性">空间局部性</h3>

<h3 id="局部性成因">局部性成因</h3>

<ol>
  <li>绝大多数情况下指令<strong>顺序执行</strong></li>
  <li>程序主要行为特征表现为<strong>循环</strong></li>
  <li>数组、结构等具有局部性</li>
</ol>

<h2 id="存储层次常用概念">存储层次常用概念</h2>

<ol>
  <li>
    <p><strong>数据包含原则</strong>：高层次数据 $\in$ 低层次数据</p>
  </li>
  <li>
    <p><strong>数据交换基本原则</strong>：数据交换一般只在相邻两层之间完成</p>
  </li>
  <li>
    <p><strong>命中 Hit</strong></p>
  </li>
  <li>
    <p><strong>命中率 Hite Rate (HR)</strong></p>
  </li>
  <li>
    <p><strong>缺失 Miss</strong></p>
  </li>
  <li>
    <p><strong>缺失率 Miss Rate (MR)</strong></p>

    <blockquote>
      <p>HR + MR = 1</p>
    </blockquote>
  </li>
  <li>
    <p><strong>命中时间 Hit Time (HT)</strong>：包括查找时间、判断时间以及数据读写时间的总和</p>
  </li>
  <li>
    <p><strong>缺失代价 Miss Penalty (MP)</strong>：某层缺失后从下层获取数据所需要的时间。</p>
  </li>
</ol>

<h2 id="cache-的结构与工作原理">Cache 的结构与工作原理</h2>

<p><img src="/assets/images/post/image-20210104220539508.png" alt="image-20210104220539508" /></p>

<p>cache 的每个数据单元被称为<strong>块(cache block)</strong></p>

<p>寄存器与 cache 之间的数据交换以 <em>寄存器</em> 为单位，但 cache 之间以及 cache 与下层主存储器之间的数据交换以 cache 块为单位。</p>

<p><img src="/assets/images/post/image-20210104225313742.png" alt="image-20210104225313742" /></p>

<h2 id="cache-的映射机制">Cache 的映射机制</h2>

<h3 id="直接映射-direct-mapped-cache">直接映射 Direct-Mapped Cache</h3>

<p><img src="/assets/images/post/image-20210104220605473.png" alt="image-20210104220605473" /></p>

<table>
  <thead>
    <tr>
      <th>有效</th>
      <th>标记</th>
      <th>索引</th>
      <th>块内偏移</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Valid</code></td>
      <td><code class="language-plaintext highlighter-rouge">Tag</code></td>
      <td><code class="language-plaintext highlighter-rouge">Index</code></td>
      <td><code class="language-plaintext highlighter-rouge">Offset</code></td>
    </tr>
    <tr>
      <td>$1$</td>
      <td>$地址总位数 - Offset - Index$</td>
      <td>$\log_2{cache块总数}$</td>
      <td>$\log_2{cache块大小}$</td>
    </tr>
  </tbody>
</table>

<h3 id="多级-cache">多级 Cache</h3>

<p><img src="/assets/images/post/image-20210104224839359.png" alt="image-20210104224839359" /></p>

<h3 id="全相联映射">全相联映射</h3>

<h3 id="组相联映射">组相联映射</h3>

<p><img src="/assets/images/post/image-20210104225521131.png" alt="image-20210104225521131" /></p>

<p><img src="/assets/images/post/image-20210104225038208.png" alt="image-20210104225038208" /></p>

<p><img src="/assets/images/post/image-20210104225057771.png" alt="image-20210104225057771" /></p>

<p><img src="/assets/images/post/image-20210104225116164.png" alt="image-20210104225116164" /></p>

<p><img src="/assets/images/post/image-20210104225140142.png" alt="image-20210104225140142" /></p>

<p><img src="/assets/images/post/image-20210104225210851.png" alt="image-20210104225210851" /></p>

<h2 id="cache-的替换策略">Cache 的替换策略</h2>

<h2 id="cache-性能分析与其他">Cache 性能分析与其他</h2>

<h3 id="容量计算">容量计算</h3>

<h3 id="性能分析">性能分析</h3>

<h4 id="直接映射">直接映射</h4>

<h5 id="amat-average-memoory-access-time">AMAT (Average Memoory Access Time)</h5>

<p>average time to access memory considering both hits and misses.</p>

<p><img src="/assets/images/post/image-20210104224118818.png" alt="image-20210104224118818" /></p>

<p><img src="/assets/images/post/image-20210104224319650.png" alt="image-20210104224319650" /></p>

<p><img src="/assets/images/post/image-20210104224516760.png" alt="image-20210104224516760" /></p>

<p><img src="/assets/images/post/image-20210104224538040.png" alt="image-20210104224538040" /></p>

<p><img src="/assets/images/post/image-20210104224557640.png" alt="image-20210104224557640" /></p>

<p><img src="/assets/images/post/image-20210104224617880.png" alt="image-20210104224617880" /></p>

<p><img src="/assets/images/post/image-20210104224634077.png" alt="image-20210104224634077" /></p>

<h4 id="多级-cache-1">多级 Cache</h4>

<p><img src="/assets/images/post/image-20210104224755270.png" alt="image-20210104224755270" /></p>

<p><img src="/assets/images/post/image-20210104224904488.png" alt="image-20210104224904488" /></p>

<p><img src="/assets/images/post/image-20210104224919361.png" alt="image-20210104224919361" /></p>

<p><img src="/assets/images/post/image-20210104224938425.png" alt="image-20210104224938425" /></p>

<p><img src="/assets/images/post/image-20210104224957879.png" alt="image-20210104224957879" /></p>

<p><img src="/assets/images/post/image-20210104225016103.png" alt="image-20210104225016103" /></p>

<h4 id="组相联映射-1">组相联映射</h4>

<h3 id="cache-数据一致性问题">Cache 数据一致性问题</h3>

<h4 id="write-through-policy-写通">Write-Through Policy 写通</h4>

<p><img src="/assets/images/post/image-20210104221411308.png" alt="image-20210104221411308" /></p>

<h4 id="write-back-policy-写回">Write-Back Policy 写回</h4>

<p><img src="/assets/images/post/image-20210104221421857.png" alt="image-20210104221421857" /></p>

<h3 id="处理-cache-缺失">处理 Cache 缺失</h3>

<p><img src="/assets/images/post/image-20210104221458231.png" alt="image-20210104221458231" /><img src="/assets/images/post/image-20210104221521780.png" alt="image-20210104221521780" /></p>

<h3 id="改进-cache-性能">改进 Cache 性能</h3>

<p><img src="/assets/images/post/image-20210104225417419.png" alt="image-20210104225417419" /><img src="/assets/images/post/image-20210104225430923.png" alt="image-20210104225430923" /></p>

<h1 id="虚拟存储系统">虚拟存储系统</h1>

<h2 id="辅助存储器">辅助存储器</h2>

<h2 id="虚拟存储器的概念和作用">虚拟存储器的概念和作用</h2>

<h2 id="虚拟存储器的工作原理">虚拟存储器的工作原理</h2>

<h2 id="虚实地址转换">虚实地址转换</h2>

<h2 id="页表工作原理">页表工作原理</h2>

<h2 id="tlb-工作原理">TLB 工作原理</h2>

<h2 id="虚拟存储器性能分析">虚拟存储器性能分析</h2>

<h1 id="总线与输入输出方式">总线与输入输出方式</h1>

<h2 id="计算机-i--o-系统">计算机 I / O 系统</h2>

<h2 id="总线">总线</h2>

<h2 id="i--o-方式">I / O 方式</h2>

<h3 id="程序查询方式">程序查询方式</h3>

<h3 id="中断方式">中断方式</h3>]]></content><author><name>ericaaaaaaaa</name></author><category term="ComputerArchitecture" /><category term="note" /><category term="computer-organization" /><category term="system" /><summary type="html"><![CDATA[Computer Organization]]></summary></entry><entry><title type="html">Data Structure</title><link href="http://localhost:4000/data/2021/01/11/DataStructure.html" rel="alternate" type="text/html" title="Data Structure" /><published>2021-01-11T00:00:00+08:00</published><updated>2021-01-11T00:00:00+08:00</updated><id>http://localhost:4000/data/2021/01/11/DataStructure</id><content type="html" xml:base="http://localhost:4000/data/2021/01/11/DataStructure.html"><![CDATA[<h1 id="线性表">线性表</h1>

<h2 id="线性表的概念和表抽象数据类型">线性表的概念和表抽象数据类型</h2>

<h3 id="表的概念和性质">表的概念和性质</h3>

<ul>
  <li>
    <p>线性表</p>

    <blockquote>
      <p>一个（有穷或无穷）的基本元素集合 E, E 中一组有穷个元素排列成的序列 $L = (e_0, e_1, e_2, …,e_{n-1})$</p>
    </blockquote>
  </li>
  <li>
    <p>下标</p>
  </li>
  <li>
    <p>空表</p>
  </li>
  <li>
    <p>长度</p>
  </li>
  <li>
    <p>首元素 &amp; 尾元素</p>

    <p>唯一</p>
  </li>
  <li>
    <p>前驱元素</p>
  </li>
  <li>
    <p>后继元素</p>
  </li>
</ul>

<h3 id="表抽象数据类型">表抽象数据类型</h3>

<h4 id="线性表的操作">线性表的操作</h4>

<h4 id="表抽象数据类型-1">表抽象数据类型</h4>

<h3 id="线性表的实现基本考虑">线性表的实现：基本考虑</h3>

<ol>
  <li>空间（计算机内存）</li>
  <li>时间（各种重要操作的效率）</li>
</ol>

<h2 id="顺序表的实现">顺序表的实现</h2>

<blockquote>
  <p><strong>顺序表</strong>——表中元素顺序存放在一片足够大的连续存储区内，首元素存入存储区开始位置，其余元素依次顺序存放，元素之间的逻辑顺序关系通过元素在存储区域里的物理位置表示。</p>
</blockquote>

<h3 id="基本实现方式">基本实现方式</h3>

<p>若顺序表中存储的元素类型相同，则：</p>

<ul>
  <li>存取操作可以在 O(1) 的时间内完成。</li>
  <li>元素访问是 O(1) 复杂度的操作</li>
</ul>

<p>若顺序表中元素大小不统一，则</p>

<ul>
  <li>可以将实际数据元素另行存储，在顺序表里各单元位置保存相应元素的引用信息（链接/索引）。</li>
</ul>

<h3 id="顺序表基本操作的实现">顺序表基本操作的实现</h3>

<h4 id="创建和访问操作">创建和访问操作</h4>

<ul>
  <li>
    <p>创建空表`</p>

    <blockquote>
      <p>创建新表的存储区后，应立即将两个表信息域(max 与 num) 设置好，保证这个表处于合法状态</p>
    </blockquote>
  </li>
  <li>
    <p>简单判断操作 O(1)</p>

    <ul>
      <li>空表：num == 0</li>
      <li>表满：num == max</li>
    </ul>
  </li>
  <li>
    <p>访问给定下标 i 的元素 O(1)</p>
  </li>
  <li>
    <p>遍历操作 O(n)</p>
  </li>
  <li>
    <p>查找给定元素 d 的（第一次出现的）位置 O(n)</p>
  </li>
  <li>
    <p>查找给定元素 d 在位置 k 后第一次出现的位置 O(n)</p>
  </li>
</ul>

<h4 id="变动操作加入元素">变动操作：加入元素</h4>

<ul>
  <li>
    <p>尾端加入新数据项 O(1)</p>
  </li>
  <li>
    <p>新数据存入元素存储区的第 i 个单元</p>

    <ul>
      <li>
        <p>不要求维持原有元素的相对位置：O(1)</p>

        <blockquote>
          <p>将原有第 i 个单元的元素放入 num，再将新元素写入第 i 个单元</p>
        </blockquote>
      </li>
      <li>
        <p>要求保持原有元素的相对位置： O(n)</p>

        <blockquote>
          <p>把包括第 i 个单元的所有单元向后平移一位，再将新元素写入第 i 个单元</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h4 id="变动操作删除元素">变动操作：删除元素</h4>

<ul>
  <li>
    <p>尾端删除数据 O(1)</p>
  </li>
  <li>
    <p>删除位置 i 的数据</p>

    <ul>
      <li>
        <p>软删除</p>

        <blockquote>
          <p>添加合法下标，再删除元素时将合法下标改为非法</p>
        </blockquote>
      </li>
      <li>
        <p>硬删除</p>

        <ul>
          <li>
            <p>不需要保持原有顺序 O(1)</p>

            <blockquote>
              <p>将 num - 1 填入 i，再尾端删除</p>
            </blockquote>
          </li>
          <li>
            <p>需要保持原有顺序 O(n)</p>

            <blockquote>
              <p>将第 i 个删除，再将其后面的每个元素前移一位</p>
            </blockquote>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>基于条件的删除 O(n)</p>

    <blockquote>
      <p><strong>基于条件</strong>：不直接给出删除元素的位置，而是给出需要删除数据项的条件</p>

      <p>需要通过循环实现，循环中逐个检查元素，查找到后将其删除。</p>
    </blockquote>
  </li>
</ul>

<h3 id="顺序表及其操作的性质">顺序表及其操作的性质</h3>

<p><strong>顺序表优缺点总结：</strong></p>

<ul>
  <li><strong>优点</strong>：
    <ul>
      <li>O(1) 时间的（随机、直接的）按位置访问元素；</li>
      <li>元素在表里存储紧凑，除表中的存储区之外只需要 O(1) 空间存放少量的辅助信息</li>
    </ul>
  </li>
  <li><strong>缺点</strong>：
    <ul>
      <li>需要连续的存储区存放表中的元素，若表很大，则需要大片连续的内存空间。</li>
      <li>一旦确定了存储块的大小，可容纳单元个数并不随着插入 /删除操作的进行而变化。如果很大的存储区只保存了少量的数据项，就会有大量空闲单元，造成表内的存储浪费。</li>
      <li>另外，在执行加入或删除操作时，通常需要移动许多元素，效率低。</li>
      <li>最后，建立表需要考虑元素存储区大小，而实际需求通常很难事先估计。</li>
    </ul>
  </li>
</ul>

<h3 id="python-的-list">Python 的 list</h3>

<ul>
  <li>
    <p>创建线性表</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">lst = []</code></p>
  </li>
  <li>
    <p>加入元素</p>

    <ul>
      <li>尾端加入单一元素：<code class="language-plaintext highlighter-rouge">lst.append(x)</code></li>
      <li>将数据存入第 i 个单元：<code class="language-plaintext highlighter-rouge">lst.insert(i, x)</code></li>
    </ul>
  </li>
  <li>
    <p>删除元素</p>

    <ul>
      <li>删除尾端元素：<code class="language-plaintext highlighter-rouge">lst.pop()</code></li>
      <li>删除下标为 i 的元素：<code class="language-plaintext highlighter-rouge">lst.pop(i)</code></li>
      <li>删除第一个内容为 x 的元素：<code class="language-plaintext highlighter-rouge">lst.remove(x)</code></li>
    </ul>
  </li>
  <li>
    <p>求表长</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">len(lst)</code></li>
    </ul>
  </li>
  <li>
    <p>清除 list 中的所有元素</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">lst.clear()</code></li>
    </ul>
  </li>
  <li>
    <p>将 list 中的元素倒置</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">lst.reverse()</code></li>
    </ul>
  </li>
  <li>
    <p>将 list 中的元素排序</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">sort</code>：会修改 list 本身，不会返回新的 list</li>
      <li><code class="language-plaintext highlighter-rouge">sorted</code>：不会修改 list 本身，会返回排序好的 list</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">sort</span><span class="p">())</span>   <span class="c1"># None
</span><span class="k">print</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>          <span class="c1"># [1,2,3,4,5]
######
</span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> 
<span class="k">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">lst</span><span class="p">))</span>  <span class="c1"># [1,2,3,4,5]
</span><span class="k">print</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>          <span class="c1"># [3,4,5,1,2]
</span></code></pre></div>    </div>
  </li>
</ul>

<h2 id="链接表链表">链接表（链表）</h2>

<h3 id="线性表的基本需要和链接表">线性表的基本需要和链接表</h3>

<p>链接表的基本思路：</p>

<ul>
  <li>把表中的元素分别存储在一批独立的存储块（称为表的结点）里</li>
  <li>保证从组成表结构中的任一个节点可找到于其相关的下一个结点</li>
  <li>在前一结点里用链接的方式显式地记录与下一个结点的关联</li>
</ul>

<h3 id="单向链接表单链表">单向链接表（单链表）</h3>

<p><img src="/assets/images/post/image-20210103164334335.png" alt="image-20210103164334335" /></p>

<p><img src="/assets/images/post/image-20210103164051115.png" alt="image-20210103164051115" /></p>

<ul>
  <li>一个单链表由一些具体的表结点构成</li>
  <li>每个结点是一个对象，由自己的标识，下面也常称其为该节点的链接</li>
  <li>结点之间通过结点链接建立其单向顺序联系</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 定义一个简单的表结点类
</span><span class="k">class</span> <span class="nc">LNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">next_</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">elem</span> <span class="o">=</span> <span class="n">elem</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">next_</span> <span class="c1"># 为了避免与 python 标准函数 next 重名
</span></code></pre></div></div>

<h3 id="基本链表操作">基本链表操作</h3>

<h4 id="创建空链表">创建空链表</h4>

<p>把相应的表头变量设置为空连接</p>

<h4 id="删除链表">删除链表</h4>

<p>将表指针赋值为 <code class="language-plaintext highlighter-rouge">None</code></p>

<h4 id="判断表是否为空">判断表是否为空</h4>

<p>检查表头指针是否为 <code class="language-plaintext highlighter-rouge">None</code></p>

<h4 id="判断表是否满">判断表是否满</h4>

<p>一般链表不会满</p>

<h3 id="加入元素">加入元素</h3>

<h4 id="表首端插入">表首端插入</h4>

<ol>
  <li>创建一个新结点并存入数据</li>
  <li>把原链表首结点的链接存入新结点的链接域 <code class="language-plaintext highlighter-rouge">next</code></li>
  <li>修改表头变量，使之指向新结点</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q</span> <span class="o">=</span> <span class="n">LNode</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
<span class="n">q</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
<span class="n">head</span> <span class="o">=</span> <span class="n">q</span>
</code></pre></div></div>

<h4 id="一般情况的元素插入">一般情况的元素插入</h4>

<ol>
  <li>创建一个新结点并存入数据</li>
  <li>把 <code class="language-plaintext highlighter-rouge">pre</code> 所指结点的 <code class="language-plaintext highlighter-rouge">next</code> 域的值存入新结点的链接域 <code class="language-plaintext highlighter-rouge">next</code></li>
  <li>修改 <code class="language-plaintext highlighter-rouge">pre</code> 的 <code class="language-plaintext highlighter-rouge">next</code> 域，使之指向新结点</li>
</ol>

<p><img src="/assets/images/post/image-20210103170529842.png" alt="image-20210103170529842" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q</span> <span class="o">=</span> <span class="n">LNode</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
<span class="n">q</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">.</span><span class="nb">next</span>
<span class="n">pre</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">q</span>
</code></pre></div></div>

<h3 id="删除元素">删除元素</h3>

<h4 id="删除表首元素">删除表首元素</h4>

<p>修改表头指针，令其指向表中的第二个结点</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<h4 id="一般情况的元素删除">一般情况的元素删除</h4>

<p><img src="/assets/images/post/image-20210103170904240.png" alt="image-20210103170904240" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pre</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<h3 id="扫描定位和遍历">扫描、定位和遍历</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">head</span>
<span class="k">while</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">还需要继续的其它条件</span><span class="p">:</span>
    <span class="n">对</span> <span class="n">p</span> <span class="n">所指结点里的数据做所需操作</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<h4 id="按下标定位">按下标定位</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">head</span>
<span class="k">while</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<h4 id="按元素定位">按元素定位</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">head</span>
<span class="k">while</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pred</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">elem</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<h4 id="遍历">遍历</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">head</span>
<span class="k">while</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<h3 id="链表操作的复杂度">链表操作的复杂度</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">操作</th>
      <th style="text-align: center">具体说明</th>
      <th style="text-align: center">复杂度</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">创建空表</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">O(1)</td>
    </tr>
    <tr>
      <td style="text-align: center">删除表</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">O(1)</td>
    </tr>
    <tr>
      <td style="text-align: center">判断空表</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">O(1)</td>
    </tr>
    <tr>
      <td style="text-align: center">加入元素</td>
      <td style="text-align: center">首端加入元素</td>
      <td style="text-align: center">O(1)</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">尾端加入元素</td>
      <td style="text-align: center">O(n)</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">定位加入元素</td>
      <td style="text-align: center">O(n)</td>
    </tr>
    <tr>
      <td style="text-align: center">删除元素</td>
      <td style="text-align: center">首端删除元素</td>
      <td style="text-align: center">O(1)</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">尾端删除元素</td>
      <td style="text-align: center">O(n)</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">定位删除元素</td>
      <td style="text-align: center">O(n)</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">其它删除：通常需要扫描一整个表或者一部分</td>
      <td style="text-align: center">O(n)</td>
    </tr>
  </tbody>
</table>

<h3 id="求表的长度-on">求表的长度 O(n)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nb">next</span>
    <span class="k">return</span> <span class="n">n</span>
</code></pre></div></div>

<h2 id="链表的变形和操作">链表的变形和操作</h2>

<h3 id="单链表的简单变形">单链表的简单变形</h3>

<p>在表对象中加入一个表尾引用域</p>

<h3 id="循环单链表循环链表">循环单链表（循环链表）</h3>

<p>最后一个结点的 <code class="language-plaintext highlighter-rouge">next</code> 域不用 <code class="language-plaintext highlighter-rouge">None</code>，而是指向表的第一个结点。</p>

<h3 id="双向链接表双链表">双向链接表（双链表）</h3>

<p>节点之间由双向链接: <code class="language-plaintext highlighter-rouge">prev</code>, <code class="language-plaintext highlighter-rouge">next</code></p>

<h3 id="循环双链表">循环双链表</h3>

<h3 id="链表的排序">链表的排序</h3>

<p>排序操作见后文“内部排序”</p>

<h1 id="栈和队列">栈和队列</h1>

<h2 id="概述">概述</h2>

<h3 id="栈队列和数据使用顺序">栈、队列和数据使用顺序</h3>

<h4 id="栈-stack">栈 Stack</h4>

<p>栈是保证元素<strong>后进先出</strong>（后存入先使用， Lat In First Out, LIFO） 关系的结构，简称 LIFO 结构。</p>

<h4 id="队列-queue">队列 Queue</h4>

<p>队列是保证元素<strong>先进先出</strong>（先存入者先使用，First In First Out, FIFO）关系的结构，简称 FIFO 结构。</p>

<h3 id="应用环境">应用环境</h3>

<ul>
  <li>计算过程分为一些顺序执行的步骤</li>
  <li>计算中执行的某些步骤会不断产生一些后面可能需要的中间数据</li>
  <li>产生的数据中有些不能立即使用，但又需要在将来使用</li>
  <li>需要保存的数据项数不能事先确定</li>
</ul>

<h2 id="栈概念和实现">栈：概念和实现</h2>

<h3 id="栈抽象数据类型">栈抽象数据类型</h3>

<h4 id="栈的线性表实现">栈的线性表实现</h4>

<ul>
  <li>对于<strong>顺序表</strong>，<strong>后端</strong>插入和删除都是 O(1) 操作，应该用这一端作为栈项（采用顺序表实现）</li>
  <li>对于<strong>连接表</strong>，<strong>前端</strong>插入和删除都是 O(1) 操作，应该用这端作为栈项</li>
</ul>

<h3 id="栈的顺序表实现">栈的顺序表实现</h3>

<p>采用 Python 的 <code class="language-plaintext highlighter-rouge">list</code> 数据结构</p>

<ul>
  <li>建立空栈：<code class="language-plaintext highlighter-rouge">lst = []</code></li>
  <li>压栈：<code class="language-plaintext highlighter-rouge">lst.append()</code></li>
  <li>弹栈：<code class="language-plaintext highlighter-rouge">lst.pop()</code></li>
</ul>

<h3 id="栈的连接表实现">栈的连接表实现</h3>

<p>见前文连接表</p>

<h2 id="栈的应用">栈的应用</h2>

<h3 id="数值转换">数值转换</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Conversion</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span> <span class="c1"># 十进制数 n 转化为 d 进制数
</span>    <span class="n">st</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">//=</span> <span class="n">d</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">st</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="s">""</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">''</span><span class="p">)</span>
    
<span class="c1"># 试着运行一下
</span><span class="n">Conversion</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="括号匹配问题">括号匹配问题</h3>

<h4 id="处理思路">处理思路</h4>

<ul>
  <li>顺序扫描被检查正文（一个字符串）中的每一个字符</li>
  <li>检查中跳过无关字符（非括号字符）</li>
  <li>遇到开括号”(“时将其压入栈</li>
  <li>遇到闭括号时弹出当前的栈顶元素与之匹配</li>
  <li>如果匹配成功则继续，发现不匹配时检查以失败结束</li>
</ul>

<h4 id="具体实现">具体实现</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">check_parens</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="s">"""括号匹配检查函数，text 是被检查的正文串"""</span>
    <span class="n">parens</span> <span class="o">=</span> <span class="s">"()[]{}"</span> <span class="c1"># 所有括号字符
</span>    <span class="n">open_parens</span> <span class="o">=</span> <span class="s">"([{"</span> <span class="c1"># 开括号字符
</span>    <span class="n">opposite</span> <span class="o">=</span> <span class="p">{</span><span class="s">")"</span><span class="p">:</span><span class="s">"("</span><span class="p">,</span> <span class="s">"]"</span><span class="p">:</span><span class="s">"["</span><span class="p">,</span> <span class="s">"}"</span><span class="p">:</span><span class="s">"{"</span><span class="p">}</span> <span class="c1"># 表示匹配关系的字典
</span>    
    <span class="k">def</span> <span class="nf">parentheses</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="s">"""括号生成器，每次调用返回 text 里下一个括号及其位置"""</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">text_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text_len</span> <span class="ow">and</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parens</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">text_len</span><span class="p">:</span>
                <span class="k">return</span> 
            <span class="k">yield</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            
    <span class="n">st</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 保存括号的栈
</span>    <span class="k">for</span> <span class="n">pr</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parentheses</span><span class="p">(</span><span class="n">text</span><span class="p">):</span> <span class="c1"># 对 text 里各括号和位置迭代
</span>        <span class="k">if</span> <span class="n">pr</span> <span class="ow">in</span> <span class="n">open_parens</span><span class="p">:</span> <span class="c1"># 开括号，压栈并继续
</span>            <span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">pr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">st</span> <span class="o">==</span> <span class="p">[]:</span> <span class="c1"># 无法再弹栈
</span>            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">!=</span> <span class="n">opposite</span><span class="p">[</span><span class="n">pr</span><span class="p">]:</span> <span class="c1"># 不匹配就是失败，退出
</span>            <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># else: 这是依次成功匹配，什么也不做，继续，因为上一步已经弹栈了
</span>    <span class="k">if</span> <span class="n">st</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="c1"># 应用一下试试看
</span><span class="n">re</span> <span class="o">=</span> <span class="n">check_parens</span><span class="p">(</span><span class="s">"{(]"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">re</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"All parentheses are correctly matched."</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Parentheses mismatched."</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="表达式的表示计算和变换">表达式的表示，计算和变换</h3>

<h4 id="表达式和计算的描述">表达式和计算的描述</h4>

<ul>
  <li>
    <p>中缀形式：<code class="language-plaintext highlighter-rouge">(3 - 5) * (6 + 17 * 4) / 3</code></p>

    <blockquote>
      <p>中缀表达式表达能力最弱，只有在添加括号后才可达到相同的表达能力</p>
    </blockquote>
  </li>
  <li>
    <p>前缀形式：<code class="language-plaintext highlighter-rouge">/ * - 3 5 + 6 * 17 4 3</code></p>
  </li>
  <li>
    <p>后缀形式：<code class="language-plaintext highlighter-rouge">3 5 - 6 17 4 * + * 3 /</code></p>
  </li>
</ul>

<h4 id="后缀表达式的计算">后缀表达式的计算</h4>

<h5 id="算法思路">算法思路</h5>

<ul>
  <li>遇到运算对象是，应该记录它以便后续使用</li>
  <li>遇到运算符时，应该根据其元数（假定都是二元运算符），取得前面最近遇到的几个运算对象或已完成运算的结果，应用这个运算符计算，并保存其结果</li>
</ul>

<h5 id="注意事项">注意事项</h5>

<ul>
  <li>需要记录的是已经掌握的数据</li>
  <li>每次处理运算符，应使用的是此前最后记录的几个结果</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 实现的伪代码如下：
# 假定 st 是一个栈，算法的核心是下面的循环
</span><span class="k">while</span> <span class="n">还有输入</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">nextItem</span><span class="p">()</span> <span class="c1"># 获取下一个输入
</span>    <span class="k">if</span> <span class="n">is_opend</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="c1"># 如果是运算对象
</span>        <span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 如果是运算符
</span>        <span class="n">b</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 第二个运算对象 ################################## 特别注意，先弹出来的是第二个运算数
</span>        <span class="n">a</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 第一个运算对象 ################################## 特别注意，后弹出来的是第一个运算数
</span>        <span class="n">根据运算符对</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">进行运算</span>
        <span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c1">#计算结果压入栈
</span></code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">formula</span><span class="p">):</span>
    <span class="n">formula</span> <span class="o">=</span> <span class="n">formula</span><span class="p">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">st</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 栈
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">formula</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">isdigit</span><span class="p">()):</span> <span class="c1"># 若为数字
</span>            <span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="c1"># 只支持整形运算
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 第二个运算数 ################################## 特别注意，先弹出来的是第二个运算数
</span>            <span class="n">a</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 第一个运算数 ################################## 特别注意，后弹出来的是第一个运算数
</span>            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="s">'+'</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="s">'-'</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="s">'*'</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="s">'/'</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"Illegal operator"</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

<span class="c1"># 试着运算看看
</span><span class="k">print</span><span class="p">(</span><span class="n">calculate</span><span class="p">(</span><span class="s">"3 5 - 6 17 4 * + * 3 /"</span><span class="p">))</span>
</code></pre></div></div>

<h4 id="中缀表达式到后缀表达式的转换">中缀表达式到后缀表达式的转换</h4>

<ul>
  <li>扫描中遇到一个运算符不能将其输出，只要看到下一个运算符的优先级<strong>不高于</strong>本运算符的时候，才能够取做本运算符要求的计算</li>
  <li>应该用一个栈保存尚未处理的运算符</li>
  <li>需要处理括号问题</li>
  <li>在扫描完成后，栈里可能剩下一些运算符，应将其一一弹出并送到后缀表达式。</li>
</ul>

<h4 id="中缀表达式的求值">中缀表达式的求值</h4>

<h3 id="栈与递归">栈与递归</h3>

<h4 id="阶乘函数的递归计算">阶乘函数的递归计算</h4>

<h4 id="栈与递归--函数调用">栈与递归 / 函数调用</h4>

<p>为了支持递归定义函数的实现，需要一个栈（运行栈）保存递归函数执行时每层调用的局部信息</p>

<h2 id="队列">队列</h2>

<h3 id="队列抽象数据类型">队列抽象数据类型</h3>

<p><strong>先进先出</strong>（First In First Out, FIFO）结构</p>

<ul>
  <li>入队（enqueue）</li>
  <li>出队（dequeue）</li>
</ul>

<h3 id="队列的链接表实现">队列的链接表实现</h3>

<p>需要使用<strong>尾端指针</strong></p>

<h3 id="队列的顺序表实现">队列的顺序表实现</h3>

<ul>
  <li>初始化 <code class="language-plaintext highlighter-rouge">front = rear = 0</code></li>
  <li>入队：将新元素插入 <code class="language-plaintext highlighter-rouge">rear</code> 所指向的位置，然后 <code class="language-plaintext highlighter-rouge">rear</code> 加一</li>
  <li>出队：删去 <code class="language-plaintext highlighter-rouge">front</code> 所指的元素，然后加 1 并返回被删元素</li>
  <li>队列为空：<code class="language-plaintext highlighter-rouge">front = rear</code></li>
  <li>队满：<code class="language-plaintext highlighter-rouge">rear = MAX_QUEUE_SIZE - 1 或 front = rear</code></li>
</ul>

<h4 id="基于顺序表实现队列的困难">基于顺序表实现队列的困难</h4>

<p>假溢出</p>

<blockquote>
  <p>在入队和出队操作中，头、尾指针只增加不减小，致使被删除元素的空间永远无法重新利用。因此，尽管队列中实际元素个数可能远远小于数组大小，但可能由于尾指针巳超出向量空间的上界而不能做入队操作。</p>
</blockquote>

<h4 id="循环顺序表循环队列">循环顺序表（循环队列）</h4>

<blockquote>
  <p>为循环队列所分配的空间可以被充分利用，除非向量空间真的被队列元素全部占用，否则不会上溢。</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">q.elems</code> —— 始终指向表元素区开始</li>
  <li><code class="language-plaintext highlighter-rouge">q.head</code> —— 对头变量，记录当前队列里第一个元素的位置</li>
  <li><code class="language-plaintext highlighter-rouge">q.rear</code> —— 队尾变量，记录当前队列里最后元素之后的第一个空位</li>
</ul>

<p><img src="/assets/images/post/image-20210103210448289.png" alt="image-20210103210448289" /></p>

<p><img src="/assets/images/post/image-20210103210459953.png" alt="image-20210103210459953" /></p>

<p>入队和出队分别需要更新变量 <code class="language-plaintext highlighter-rouge">q.head</code> 和 <code class="language-plaintext highlighter-rouge">q.rear</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">q.head = (q.head + 1) % q.len</code></li>
  <li><code class="language-plaintext highlighter-rouge">q.rear = (q.rear + 1) % q.len</code></li>
</ul>

<h3 id="队列的应用">队列的应用</h3>

<p>BFS</p>

<h1 id="串">串</h1>

<h2 id="字符集字符串和字符串操作">字符集、字符串和字符串操作</h2>

<h3 id="字符串的相关概念">字符串的相关概念</h3>

<ul>
  <li>
    <p>字符串<strong>长度</strong></p>
  </li>
  <li>
    <p>字符在字符串中的位置</p>
  </li>
  <li>
    <p>字符串<strong>相等</strong></p>
  </li>
  <li>
    <p><strong>字典序</strong></p>
  </li>
  <li>
    <p>字符串<strong>拼接</strong></p>
  </li>
  <li>
    <p><strong>子串</strong>关系</p>

    <p>任何字符串也是该串自身的子串</p>
  </li>
  <li>
    <p><strong>前缀</strong>，<strong>后缀</strong></p>
  </li>
</ul>

<h3 id="字符串抽象数据类型">字符串抽象数据类型</h3>

<h2 id="字符串的实现">字符串的实现</h2>

<h3 id="基本实现问题和技术">基本实现问题和技术</h3>

<h3 id="实际语言里的字符串">实际语言里的字符串</h3>

<h3 id="python-里的字符串">Python 里的字符串</h3>

<h4 id="str-的操作"><code class="language-plaintext highlighter-rouge">str</code> 的操作</h4>

<ul>
  <li>
    <p>切分操作 <code class="language-plaintext highlighter-rouge">split</code></p>

    <p><code class="language-plaintext highlighter-rouge">string.split('x')</code></p>

    <ul>
      <li>默认在<strong>空格处</strong>切分</li>
      <li>返回切分后的 <code class="language-plaintext highlighter-rouge">list</code>，其中每个元素<strong>不包含</strong> ‘x’</li>
      <li><strong>不改变</strong>原有字符串</li>
    </ul>
  </li>
  <li>
    <p>替换操作 <code class="language-plaintext highlighter-rouge">replace</code></p>

    <p><code class="language-plaintext highlighter-rouge">string.replace('a', 'b')</code></p>

    <ul>
      <li>一次替换掉<strong>全部</strong>满足要求的元素</li>
      <li>返回替换后的结果</li>
      <li><strong>不改变</strong>原有字符串</li>
    </ul>
  </li>
  <li>
    <p>检查子串出现的次数 <code class="language-plaintext highlighter-rouge">count</code></p>

    <p><code class="language-plaintext highlighter-rouge">TimesOccured = string.count('x', start(, end))</code></p>
  </li>
  <li>
    <p>检查后缀 <code class="language-plaintext highlighter-rouge">endswith</code></p>

    <p><code class="language-plaintext highlighter-rouge">string.endswith('Ending')</code></p>

    <ul>
      <li>返回 <code class="language-plaintext highlighter-rouge">Ture</code> 或 <code class="language-plaintext highlighter-rouge">False</code></li>
    </ul>
  </li>
  <li>
    <p>找子串的位置 <code class="language-plaintext highlighter-rouge">find/index</code></p>

    <p><code class="language-plaintext highlighter-rouge">string.find("substring", start(, end))</code></p>

    <p><code class="language-plaintext highlighter-rouge">string.index("substring", start(, end))</code></p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">index() </code>方法检测字符串中是否包含子字符串 <code class="language-plaintext highlighter-rouge">str</code> ，该方法与 python <code class="language-plaintext highlighter-rouge">find()</code>方法一样，只不过如果 <code class="language-plaintext highlighter-rouge">str</code> 不在 <code class="language-plaintext highlighter-rouge">string</code> 中<strong>会报一个异常</strong>。</li>
    </ul>
  </li>
</ul>

<h2 id="字符串匹配子串查找string-matching">字符串匹配（子串查找）string matching</h2>

<h3 id="字符串匹配">字符串匹配</h3>

<p>假设有两个串（其中 $t_i, p_i$ 是字符）</p>

<p>$t = t_0t_1t_2…t_{n-1}$</p>

<p>$p = p_0p_1p_2…p_{m-1}$</p>

<p>在 $t$ 中查找与 $p$ 相同的子串</p>

<ul>
  <li><strong>目标串</strong>：$t$</li>
  <li><strong>模式串</strong>：$p$</li>
</ul>

<blockquote>
  <p>通常有 m « n, 即模式串长度远小于目标串长度</p>
</blockquote>

<h4 id="实际的串匹配问题">实际的串匹配问题</h4>

<h3 id="串匹配和朴素匹配算法">串匹配和朴素匹配算法</h3>

<h4 id="串匹配算法">串匹配算法</h4>

<h4 id="朴素的串匹配算法-brute-force">朴素的串匹配算法 Brute Force</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
 dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
  dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
   dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
    dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
     dsh
acdsgsdshvdncxmcudiwdnskxjzxjkxnvzbcshdiquso
      dsh
</code></pre></div></div>

<h3 id="无回溯串匹配算法kmp-算法">无回溯串匹配算法（KMP 算法）</h3>

<p><img src="/assets/images/post/image-20210103215911275.png" alt="image-20210103215911275" /></p>

<h4 id="基本考虑">基本考虑</h4>

<h4 id="问题分析">问题分析</h4>

<p>当 $p_i$ 匹配失败时，所有的 $p_k(0\le k &lt; i)$ 都已经匹配成功 。因此，只需要根据模式串 $p$ 本身即可决定匹配失败时如何前移。</p>

<p>对 $p$ 中的每个 $i$，都有与之对应的下标 $k_i$，与之匹配的目标串无关。（$k_i$ 课通过对于模式串 $p$ 的预分析得到）假设模式串 $p$ 的长度为 $m$，则需要对每个 $i(0\le i&lt;m)$ 计算出对应的 $k_i$ 并将其保存起来，以便在匹配中使用。为此可以考虑一个长为 $m$ 的表 <code class="language-plaintext highlighter-rouge">pnext</code>，用表元素 <code class="language-plaintext highlighter-rouge">pnext[i]</code> 记录与 $i$ 对应的 $k_i$ 值。</p>

<h4 id="kmp-算法-on">KMP 算法 O(n)</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">matching_KMP</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pnext</span><span class="p">):</span>
    <span class="s">"""KMP 串匹配，主函数"""</span>
    <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span> <span class="c1"># i == m 说明找到了匹配
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="c1"># 考虑 p 中下一个字符
</span>            <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 失败！考虑 pnext 决定的下一字符
</span>            <span class="n">i</span> <span class="o">=</span> <span class="n">pnext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span> <span class="c1"># 找到匹配，返回其下标
</span>        <span class="k">return</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 无匹配，返回特殊值
</span></code></pre></div></div>

<h4 id="构造-pnext-表分析">构造 <code class="language-plaintext highlighter-rouge">pnext</code> 表：分析</h4>

<ul>
  <li>模式串移动之后，作为下一个用于匹配的字符的新位置，其前缀子串应该与匹配失败的字符串之前同样长度的子串相同。</li>
  <li>如果匹配在模式串的位置 i 失败时，二位置 i 的前缀子串中满足上述条件的位置不止一处，那么只可能做最短的移动，将模式串移到最近的那个满足上述条件的位置，以保证不遗漏可能的匹配。</li>
  <li>如果 $p_0…p_{i-1}$ 的最长相等前后缀的长度为 $k(0\le k&lt;i-1)$，在 $p_i\not=t_j$ 时，模式串就应该右移 $i-k$ 位，即应把 <code class="language-plaintext highlighter-rouge">pnext[i]</code> 设置为 $k$</li>
</ul>

<h4 id="递推计算最长相等前后缀的长度">递推计算最长相等前后缀的长度</h4>

<p><img src="/assets/images/post/image-20210104143909921.png" alt="image-20210104143909921" /></p>

<p>已知 <code class="language-plaintext highlighter-rouge">pnext[0] = -1</code> 和直至 <code class="language-plaintext highlighter-rouge">pnext[i-1]</code> 的已有值求 <code class="language-plaintext highlighter-rouge">pnext[i]</code> 的算法：</p>

<ol>
  <li>假设 <code class="language-plaintext highlighter-rouge">pnext[i-1] = k-1</code>。如果 $p_i = p_k$，那么 $p_0…p_i$ 的<strong>最长相等前后缀</strong>的长度就是 $k$，将其计入 <code class="language-plaintext highlighter-rouge">pnext[i]</code>，将 $i$ 的值加一后继续递推（循环）</li>
  <li>如果 $p_i\not=p_k$，就将 $k$ 设置为 <code class="language-plaintext highlighter-rouge">pnext[k]</code> 的值</li>
  <li>如果 $k$ 的值等于 -1（这个值一定是第 2 步而来自 <code class="language-plaintext highlighter-rouge">pnext</code>），那么 $p_0…p_i$ 的最长相同前后缀的长度就是 0，设置 <code class="language-plaintext highlighter-rouge">pnext[i] = 0</code>，将 $i$ 的值加 1 后继续递推。</li>
</ol>

<h4 id="pnext-生成算法的改进"><code class="language-plaintext highlighter-rouge">pnext</code> 生成算法的改进</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gen_pnext</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="s">"""生成针对 p 中各位置 i 的下一个检查位置表，用于 KMP 算法，有稍许修改的优化版本"""</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">pnext</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># 生成下一个 pnext 元素
</span>        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="n">pnext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnext</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pnext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">pnext</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">pnext</span>
</code></pre></div></div>

<h4 id="kmp-算法的时间复杂性及其它">KMP 算法的时间复杂性及其它</h4>

<ul>
  <li>构造 <code class="language-plaintext highlighter-rouge">pnext</code> O(m)</li>
  <li>实际匹配 O(n)</li>
  <li>综上： O(m+n)</li>
</ul>

<h1 id="数组">数组</h1>

<h3 id="数组-1">数组</h3>

<h4 id="数组的定义">数组的定义</h4>

<h4 id="数组的抽象数据类型定义">数组的抽象数据类型定义</h4>

<h4 id="数组的顺序表示和实现">数组的顺序表示和实现</h4>

<p>一般采用<strong>顺序存储</strong>的方法来表示数组</p>

<h5 id="行优先顺序row-major-order">行优先顺序（Row Major Order）</h5>

<p>$a_{11}\ a_{12}\ …\ a_{1n}\ a_{21}\ a_{22}\ …\ a_{2n}\ …\ a_{m1}\ a_{m2}\ …\ a_{mn}$</p>

<h5 id="列优先顺序column-major-order">列优先顺序（Column Major Order）</h5>

<p>$a_{11}\ a_{21}\ …\ a_{m1}\ a_{12}\ a_{22}\ …\ a_{m2}\ …\ a_{1n}\ a_{2n}\ …\ a_{mn}$</p>

<h5 id="不同存储方式的地址计算">不同存储方式的地址计算</h5>

<h3 id="矩阵的压缩存储">矩阵的压缩存储</h3>

<p>对于高阶矩阵，若其中非零元素呈某种规律分布或者矩阵中有大量的零元素，则考虑压缩存储</p>

<ul>
  <li>多个相同的非零元素只分配一个存储空间</li>
  <li>零元素不分配空间</li>
</ul>

<h4 id="特殊矩阵">特殊矩阵</h4>

<p>是指非零元素或零元素的分布有一定规律的矩阵。</p>

<h5 id="对称矩阵">对称矩阵</h5>

<blockquote>
  <p>对称矩阵中的元素关于主对角线对称，因此，让每一对对称元素$a_{ij}$和$a_{ji}, (i\not=j)$分配一个存储空间，则$n^2$个元素压缩存储到$n(n+1)\over2$个存储空间，能节约近一半的存储空间。</p>
</blockquote>

<h5 id="三角矩阵">三角矩阵</h5>

<blockquote>
  <p>三角矩阵中的重复元素c可共享一个存储空间，其余的元素正好有$n(n+1)\over2$个，因此，三角矩阵可压缩存储到向量sa[$0…{n(n+1)\over2}$]中，其中c存放在向量的第1个分量中。</p>
</blockquote>

<h5 id="对角矩阵">对角矩阵</h5>

<blockquote>
  <p>矩阵中，除了主对角线和主对角线上或下方若干条对角线上的元素之外，其余元素皆为零。</p>

  <p>对角矩阵可按行优先顺序或对角线顺序，将其压缩存储到一个向量中，并且也能找到每个非零元素和向量下标的对应关系。</p>
</blockquote>

<h4 id="稀疏矩阵-sparse-matrix">稀疏矩阵 Sparse Matrix</h4>

<h5 id="稀疏矩阵的压缩存储">稀疏矩阵的压缩存储</h5>

<p>对于稀疏矩阵，采用压缩存储方法时，只存储非0元素。必须存储非0元素的行下标值、列下标值、元素值。因此，一个三元组$(i,\ j,\ a_{ij})$唯一确定稀疏矩阵的一个非零元素。</p>

<h5 id="三元组顺序表">三元组顺序表</h5>

<blockquote>
  <p>若以行序为主序，稀疏矩阵中所有非0元素的三元组，就可以得构成该稀疏矩阵的一个三元组顺序表。</p>
</blockquote>

<h5 id="求转置矩阵">求转置矩阵</h5>

<ol>
  <li>将矩阵的行、列下标值交换。即将三元组表中的行、列位置值i 、j相互交换；</li>
  <li>重排三元组表中元素的顺序。即交换后仍然是<strong>按行优先顺序</strong>排序的。</li>
</ol>

<ul>
  <li>
    <p>方法一：</p>

    <ul>
      <li>
        <p>算法思想：</p>

        <p>按稀疏矩阵A的三元组表<code class="language-plaintext highlighter-rouge">a.data</code>中的列次序依次找到相应的三元组存入<code class="language-plaintext highlighter-rouge">b.data</code>中。</p>
      </li>
      <li>
        <p>算法分析：</p>

        <p>时间复杂度为$O(c_n\times t_n)$，即矩阵的列数和非0元素的个数的乘积成正比。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>方法二：（快速转置）</p>

    <ul>
      <li>
        <p>算法思想：</p>

        <p>直接按照稀疏矩阵A的三元组表<code class="language-plaintext highlighter-rouge">a.data</code>的次序依次顺序转换，并将转换后的三元组放置于三元组表<code class="language-plaintext highlighter-rouge">b.data</code>的恰当位置。</p>
      </li>
      <li>
        <p>前提：</p>

        <p>若能预先确定原矩阵A中每一列的(即B中每一行)第一个非0元素在<code class="language-plaintext highlighter-rouge">b.data</code>中应有的位置，则在作转置时就可直接放在<code class="language-plaintext highlighter-rouge">b.data</code>中恰当的位置。因此，应先求得A中每一列的非0元素个数。</p>
      </li>
      <li>
        <p>附设两个辅助向量<code class="language-plaintext highlighter-rouge">num[ ]</code>和<code class="language-plaintext highlighter-rouge">cpot[ ]</code> 。</p>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">num[col]</code>：统计A中第<code class="language-plaintext highlighter-rouge">col</code>列中非0元素的个数；</li>
          <li><code class="language-plaintext highlighter-rouge">cpot[col] </code>：指示A中第一个非0元素在<code class="language-plaintext highlighter-rouge">b.data</code>中的恰当位置。</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="稀疏矩阵的乘法">稀疏矩阵的乘法</h5>

<ul>
  <li>
    <p>算法思想：</p>

    <p>对于A中的每个元素<code class="language-plaintext highlighter-rouge">a.data[p](p=1, 2, … , a.tn)</code>，找到B中所有满足条件：<code class="language-plaintext highlighter-rouge">a.data[p].col=b.data[q].row</code> 的元素<code class="language-plaintext highlighter-rouge">b.data[q]</code>，求得<code class="language-plaintext highlighter-rouge">a.data[p].value * b.data[q].value</code>，该乘积是$c_{ij}$中的一部分。求得所有这样的乘积并累加求和就能得到$c_{ij}$。</p>
  </li>
</ul>

<h3 id="十字链表">十字链表</h3>

<p>矩阵非零元素结点所含有的域有：行、列、值、行指针（指向同一行的下一个非零元）、列指针（指向同一列的下一个非零元）</p>

<p><img src="/assets/images/post/image-20210104151844343.png" alt="image-20210104151844343" /></p>

<p>由定义知，稀疏矩阵中同一行的非0元素的由<code class="language-plaintext highlighter-rouge">right</code>指针域链接成一个行链表， 由<code class="language-plaintext highlighter-rouge">down</code>指针域链接成一个列链表。则每个非0元素既是某个行链表中的一个结点，同时又是某个列链表中的一个结点，所有的非0元素构成一个十字交叉的链表。称为<strong>十字链表</strong>。</p>

<p>其次，十字交叉链表还有一个<strong>头结点</strong>，结点的结构如图所示。</p>

<p><img src="/assets/images/post/image-20210104152456025.png" alt="image-20210104152456025" /></p>

<p><img src="/assets/images/post/image-20210104154357153.png" alt="image-20210104154357153" /></p>

<h3 id="广义表-list">广义表 List</h3>

<p>广义表是线性表的推广和扩充</p>

<h4 id="广义表的概念">广义表的概念</h4>

<p><strong>广义表</strong>是由 $n(n\ge 0)$ 个元素组成的有穷序列：$Lst = (a_1, a_2, … a_n)$</p>

<p>其中 $a_i$ 或者是原子项（不可再分），或者是一个广义表</p>

<ul>
  <li>
    <p>表头</p>
  </li>
  <li>
    <p>表尾</p>
  </li>
  <li>
    <p>表深</p>

    <blockquote>
      <p>括号的最大层数</p>
    </blockquote>
  </li>
</ul>

<h4 id="广义表的存储结构">广义表的存储结构</h4>

<p>由于广义表中的数据元素具有不同的结构，通常用<strong>链式</strong>存储结构表示，每个数据元素用一个结点表示。因此，广义表中就有两类结点：</p>

<ul>
  <li>
    <p>表结点：</p>

    <p>用来表示广义表项，由标志域，表头指针域，表尾指针域组成</p>
  </li>
  <li>
    <p>原子结点：</p>

    <p>用来表示原子项，由标志域，原子的值域组成</p>
  </li>
</ul>

<p><img src="/assets/images/post/image-20210104161411826.png" alt="image-20210104161411826" /></p>

<h1 id="树">树</h1>

<p><strong>树形结构</strong>是由结点（结构中的逻辑单元，可用于保存数据）和结点之间的连接关系（一种后继关系）构成，其结构域线性结构（表）不同，主要特征有：</p>

<ul>
  <li>一个结构如果不空，其中就存在着<strong>唯一</strong>的起始点，称为<strong>树根</strong>(root)</li>
  <li>一个结点<strong>有且只有一个</strong>前驱，可以有 <strong>0 个或者多个后继</strong></li>
  <li>结构里的所有结点都在树根结点通过后继关系可达的结点集合里</li>
  <li>结点之间的联系<strong>不会</strong>构成循环关系</li>
  <li>从任意俩能够不同的结点出发，通过后继关系可达的两个结点的集合，或者互不相交，或者一个为另一个的子集。</li>
</ul>

<h2 id="二叉树概念和性质">二叉树：概念和性质</h2>

<h3 id="概念和性质">概念和性质</h3>

<h4 id="定义和图示">定义和图示</h4>

<ul>
  <li>二叉树</li>
  <li>左子树</li>
  <li>右子树</li>
  <li>空树</li>
  <li>单点树</li>
  <li>子节点</li>
  <li>父节点</li>
  <li>树叶</li>
  <li>度数——一个结点的子节点个数</li>
</ul>

<h4 id="路径结点的层和树的高度">路径、结点的层和树的高度</h4>

<h4 id="二叉树的性质">二叉树的性质</h4>

<h4 id="满二叉树扩充二叉树">满二叉树、扩充二叉树</h4>

<ul>
  <li><strong>满二叉树</strong>：二叉树中所有分支结点的度数都是 2</li>
  <li><strong>扩充二叉树</strong>：将二叉树扩充为满二叉树，新增加的结点称为<strong>外部结点</strong>，原有结点称为<strong>内部结点</strong>。</li>
</ul>

<h4 id="完全二叉树">完全二叉树</h4>

<p>对于一棵高为 $h$ 的二叉树，如果其第 $0$ 层到第 $h-1$ 层的结点都满，最下一层的结点不满，且所有结点在最左边联系排列，空位都在右边。</p>

<p><img src="/assets/images/post/image-20210104163949799.png" alt="image-20210104163949799" /></p>

<h3 id="抽象数据类型">抽象数据类型</h3>

<h3 id="遍历二叉树">遍历二叉树</h3>

<p><img src="/assets/images/post/image-20210104165302639.png" alt="image-20210104165302639" /></p>

<p><code class="language-plaintext highlighter-rouge">A B C D E F G None H None I J K</code></p>

<h4 id="深度优先遍历-dfs">深度优先遍历 (DFS)</h4>

<ul>
  <li>
    <p><strong>先根序</strong>遍历（DLR）$\rightarrow$ 先根序列</p>

    <blockquote>
      <p>A B D H E I C F J K G</p>
    </blockquote>
  </li>
  <li>
    <p><strong>中根序</strong>遍历（LDR），也称对称序 $\rightarrow$ 中根序列</p>

    <blockquote>
      <p>D H B E I A J F K C G</p>
    </blockquote>
  </li>
  <li>
    <p><strong>后根序</strong>遍历（LRD）$\rightarrow$  后根序列</p>

    <blockquote>
      <p>H D I E B J K F G C A</p>
    </blockquote>
  </li>
</ul>

<h4 id="宽度优先遍历-bfs">宽度优先遍历 (BFS)</h4>

<p><strong>按层次</strong>顺序遍历</p>

<blockquote>
  <p>A B C D E F G H I J K</p>
</blockquote>

<h4 id="遍历与搜索">遍历与搜索</h4>

<h2 id="二叉树的-list-实现">二叉树的 <code class="language-plaintext highlighter-rouge">list</code> 实现</h2>

<h3 id="设计和实现">设计和实现</h3>

<ul>
  <li>
    <p>空树用 <code class="language-plaintext highlighter-rouge">None</code> 表示</p>
  </li>
  <li>
    <p>非空二叉树用包含桑元素的表<code class="language-plaintext highlighter-rouge">[d, l, r]</code> 表示，其中：</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">d</code> 表示存在根节点的元素</li>
      <li><code class="language-plaintext highlighter-rouge">l</code> 和 <code class="language-plaintext highlighter-rouge">r</code> 是两棵子树</li>
    </ul>
  </li>
  <li>
    <p>表示样例：</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="p">[</span><span class="s">'B'</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
      <span class="p">[</span><span class="s">'C'</span><span class="p">,</span> <span class="p">[</span><span class="s">'D'</span><span class="p">,</span> <span class="p">[</span><span class="s">'F'</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
                  <span class="p">[</span><span class="s">'G'</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
             <span class="s">'E'</span><span class="p">,</span> <span class="p">[</span><span class="s">'H'</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
                  <span class="p">[</span><span class="s">'I'</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]]]]</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="二叉树的-class-实现与遍历">二叉树的 <code class="language-plaintext highlighter-rouge">class</code> 实现与遍历</h2>

<h3 id="树类型定义">树类型定义</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<h3 id="根据层序输入生成树">根据层序输入生成树</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">CreateTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
    <span class="s">"""根据层序输入生成树"""</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">global</span> <span class="n">i</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">t</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">t</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="递归遍历">递归遍历</h3>

<h4 id="递归前序遍历">递归前序遍历</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">presearch</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="s">"""递归——前序遍历"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span> <span class="ow">or</span> <span class="n">root</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s">" "</span><span class="p">)</span>
        <span class="n">presearch</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">presearch</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="递归中序遍历">递归中序遍历</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">midsearch</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="s">"""递归——中序遍历"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>        
        <span class="n">midsearch</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span> <span class="ow">or</span> <span class="n">root</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s">" "</span><span class="p">)</span>
        <span class="n">midsearch</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="递归后序遍历">递归后序遍历</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">postsearch</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="s">"""递归——后序遍历"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>        
        <span class="n">postsearch</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>        
        <span class="n">postsearch</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span> <span class="ow">or</span> <span class="n">root</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s">" "</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="非递归遍历">非递归遍历</h3>

<h4 id="非递归前序遍历">非递归前序遍历</h4>

<h5 id="代码">代码</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">nonrec_presearch</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="s">"""非递归——前序遍历"""</span>
    <span class="n">dlr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 栈空间
</span>    <span class="n">now</span> <span class="o">=</span> <span class="n">root</span>
    <span class="k">while</span> <span class="ow">not</span><span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">now</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">now</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="k">elif</span> <span class="n">now</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">now</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">now</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dlr</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">stk</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">left</span>  
    <span class="c1"># 打印出遍历结果
</span>    <span class="k">print</span><span class="p">(</span><span class="n">dlr</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="算法思想">算法思想</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="n">当前结点不为空</span> <span class="ow">or</span> <span class="n">栈空间不为空时</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">当前结点为空</span><span class="p">:</span>
        <span class="n">当前结点</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="mf">1.</span> <span class="n">先访问当前结点</span><span class="err">（</span><span class="n">根节点</span><span class="err">）</span>
        <span class="mf">2.</span> <span class="n">右子节点进栈</span>
        <span class="mf">3.</span> <span class="n">当前结点设置为左子节点</span>
</code></pre></div></div>

<h4 id="非递归中序遍历">非递归中序遍历</h4>

<h5 id="代码-1">代码</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">nonrec_midsearch</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="s">"""非递归——中序遍历"""</span>
    <span class="n">ldr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 栈空间
</span>    <span class="n">now</span> <span class="o">=</span> <span class="n">root</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="p">((</span><span class="n">now</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">now</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">now</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">now</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">ldr</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stk</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">left</span>
    <span class="c1"># 打印出遍历结果
</span>    <span class="k">print</span><span class="p">(</span><span class="n">ldr</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="算法思想-1">算法思想</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="n">当前结点不为空</span> <span class="ow">or</span> <span class="n">栈空间不为空时</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">当前结点为空</span><span class="p">:</span>
        <span class="n">当前结点</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">访问当前节点</span>
        <span class="n">当前结点设置为右子节点</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">当前节点</span><span class="p">)</span>
        <span class="n">当前结点设置为左子节点</span>
</code></pre></div></div>

<h4 id="非递归后序遍历">非递归后序遍历</h4>

<h5 id="代码-2">代码</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">nonrec_postsearch</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="s">"""非递归——后序遍历"""</span>
    <span class="n">lrd</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 栈空间
</span>    <span class="n">now</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="p">((</span><span class="n">now</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">now</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span> <span class="ow">or</span> <span class="n">now</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">now</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">now</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span> <span class="ow">or</span> <span class="n">now</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">now</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">now</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stk</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
            <span class="n">now</span> <span class="o">=</span> <span class="p">[</span><span class="n">now</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">left</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">now</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">stk</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
            <span class="n">now</span> <span class="o">=</span> <span class="p">[</span><span class="n">now</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">right</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lrd</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">now</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lrd</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">now</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span><span class="p">)</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">now</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># 打印出遍历结果
</span>    <span class="k">print</span><span class="p">(</span><span class="n">lrd</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="算法思想-2">算法思想</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">需要引入</span><span class="s">"计数"</span><span class="err">，</span><span class="n">即是否可以访问根节点</span>
<span class="n">计数为</span> <span class="mi">0</span><span class="p">:</span> <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">left</span>
   <span class="n">为</span> <span class="mi">1</span><span class="p">:</span> <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">right</span>
   <span class="n">为</span> <span class="mi">2</span><span class="p">:</span> <span class="n">访问当前结点</span>
</code></pre></div></div>

<h2 id="树的存储">树的存储</h2>

<h2 id="树森林与二叉树的转换">树、森林与二叉树的转换</h2>

<h2 id="霍夫曼树的构造">霍夫曼树的构造</h2>

<blockquote>
  <p>设有实数集 $W = {w_0, w_1, …, w_{m-1}},\ T$ 是一棵扩充二叉树，其 m 个外部节点分别以 $w_i(i = 1,2,…,n-1)$ 为权，且 T 的带权外部路径长度 WPL 在所有这样的扩充二叉树中达到最小，则称 T 为 W 的最优二叉树或哈夫曼树。</p>
</blockquote>

<h1 id="图">图</h1>

<h2 id="概念性质与实现">概念、性质与实现</h2>

<h3 id="定义与图示">定义与图示</h3>

<ul>
  <li>有向图</li>
  <li>无向图</li>
</ul>

<h3 id="概念与性质">概念与性质</h3>

<ul>
  <li><strong>完全图</strong>：任意两个顶点之间都有边的图</li>
  <li><strong>度</strong>：一个顶点的度就是与它邻接边的条数。
    <ul>
      <li>入度</li>
      <li>出度</li>
    </ul>
  </li>
</ul>

<h4 id="路径的相关性质">路径的相关性质</h4>

<ul>
  <li>路径的长度：该路径上边的条数</li>
  <li><strong>回路</strong></li>
  <li><strong>简单回路</strong>：一个环路，除起点和终点外其它顶点均不相同</li>
  <li><strong>简单路径</strong>：内部不包含回路的路径</li>
  <li><strong>有根图</strong>：在有向图里存在一个顶点 v，到其它每个顶点均有路径</li>
</ul>

<h4 id="连通图">连通图</h4>

<ul>
  <li><strong>连通</strong></li>
  <li><strong>连通无向图</strong>：任意两个顶点之间都连通</li>
  <li><strong><em>强</em></strong> <strong>连通有向图</strong>：任意两个顶点之间都有路径（要求两个方向的路径都存在）</li>
</ul>

<h4 id="子图连通子图">子图、连通子图</h4>

<ul>
  <li><strong>极大连通子图</strong></li>
  <li><strong>极大强连通子图</strong></li>
</ul>

<h4 id="带权图和网络">带权图和网络</h4>

<ul>
  <li><strong>带权图</strong></li>
  <li><strong>网络</strong></li>
</ul>

<h3 id="图抽象数据类型">图抽象数据类型</h3>

<h3 id="图的表示和实现">图的表示和实现</h3>

<h4 id="邻接矩阵">邻接矩阵</h4>

<p>$A_{ij} = \left{ \begin{array}{lr} 1, 如果顶点 v_i 到 v_j 有边 \ 0，如果顶点 v_i 到 v_j 无边\end{array}\right.$</p>

<h4 id="图的邻接表表示">图的邻接表表示</h4>

<blockquote>
  <p>对图的每个顶点建立一个单链表，存储该顶点所有邻接顶点及其相关信息。每一个单链表设一个表头结点。</p>
</blockquote>

<p><img src="/assets/images/post/image-20210105165157110.png" alt="image-20210105165157110" /></p>

<h2 id="图的-python-实现">图的 Python 实现</h2>

<p>用字典实现</p>

<ul>
  <li>
    <p>字典的声明：</p>

    <p><code class="language-plaintext highlighter-rouge">Graph = dict()</code></p>
  </li>
  <li>
    <p>使用：</p>

    <p><code class="language-plaintext highlighter-rouge">Graph[key] = value</code></p>
  </li>
</ul>

<h3 id="由输入构造树">由输入构造树</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># get input
</span><span class="n">NodeNum</span><span class="p">,</span> <span class="n">PathNum</span><span class="p">,</span> <span class="n">Start</span><span class="p">,</span> <span class="n">End</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()</span>
<span class="n">NodeNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">NodeNum</span><span class="p">)</span>
<span class="n">PathNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">PathNum</span><span class="p">)</span>
<span class="n">Start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Start</span><span class="p">)</span>
<span class="n">End</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">End</span><span class="p">)</span>
<span class="c1"># Create Graph
</span><span class="n">Graph</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NodeNum</span><span class="p">):</span>
    <span class="n">Graph</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">PathNum</span><span class="p">):</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()</span>
    <span class="n">Graph</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">])][</span><span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</code></pre></div></div>

<h3 id="图的遍历">图的遍历</h3>

<h4 id="深度优先遍历">深度优先遍历</h4>

<h4 id="宽度优先遍历">宽度优先遍历</h4>

<h3 id="生成树">生成树</h3>

<blockquote>
  <p>条件：<strong>连通无向图</strong> 或 <strong>强连通有向图</strong></p>
</blockquote>

<blockquote>
  <p>如果图 G 有 n 个顶点，必然可以找到 G 中的一个包含 n-1 条边的集合，这个集合里包含了从 $v_0$ 到其它所有点的路径。</p>
</blockquote>

<h4 id="遍历和生成树">遍历和生成树</h4>

<h5 id="构造-dfs-生成树">构造 DFS 生成树</h5>

<h5 id="构造-bfs-生成树">构造 BFS 生成树</h5>

<h2 id="最小生成树">最小生成树</h2>

<h3 id="最小生成树问题">最小生成树问题</h3>

<p>最小生成树 —— 带权树中权值最小的生成树</p>

<h3 id="kruskal-算法">Kruskal 算法</h3>

<h5 id="算法思路-1">算法思路</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">将图看作离散的点和一堆边</span>
<span class="n">dot</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="n">num</span><span class="p">(</span><span class="n">边</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">从未选择的边中找到满足</span><span class="err">：</span><span class="o">&lt;</span><span class="n">m</span> <span class="p">,</span><span class="n">n</span><span class="o">&gt;</span>
    <span class="mf">1.</span> <span class="n">权重最小</span>
    <span class="mf">2.</span> <span class="n">两个端点不同时出现在已连接的点中</span>
    <span class="n">dot</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">dot</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">将边从未选择中删除</span>
    <span class="n">num</span><span class="p">(</span><span class="n">边</span><span class="p">)</span> <span class="o">++</span>
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>![img](https://upload-images.jianshu.io/upload_images/3755117-2656ffcd5cdb097d.png?imageMogr2/auto-orient/strip</td>
      <td>imageView2/2/w/1200/format/webp)</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>![img](https://upload-images.jianshu.io/upload_images/3755117-8392698e3388fece.png?imageMogr2/auto-orient/strip</td>
      <td>imageView2/2/w/1200/format/webp)</td>
    </tr>
  </tbody>
</table>

<h3 id="prim-算法">Prim 算法</h3>

<table>
  <tbody>
    <tr>
      <td>![img](https://upload-images.jianshu.io/upload_images/3755117-4491cf0d977af08c.png?imageMogr2/auto-orient/strip</td>
      <td>imageView2/2/w/1200/format/webp)</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>![img](https://upload-images.jianshu.io/upload_images/3755117-ac654c5400c4a97e.png?imageMogr2/auto-orient/strip</td>
      <td>imageView2/2/w/1200/format/webp)</td>
    </tr>
  </tbody>
</table>

<h2 id="最短路径">最短路径</h2>

<h3 id="最短路径问题">最短路径问题</h3>

<h3 id="求单原点最短路径的-dijikstra-算法">求单原点最短路径的 Dijikstra 算法</h3>

<p><img src="https://wiki.mbalib.com/w/images/6/65/Dijkstra%E7%AE%97%E6%B3%95%E5%9B%BE.jpg" alt="See the source image" /></p>

<p><img src="/assets/images/post/image-20210105185331340.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># FindPath
</span><span class="n">Path</span><span class="p">[</span><span class="n">Start</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Start</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Graph</span><span class="p">[</span><span class="n">Start</span><span class="p">]:</span>
    <span class="n">CanReach</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">Graph</span><span class="p">[</span><span class="n">Start</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">,</span><span class="n">Start</span><span class="p">))</span>
<span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Arrive</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NodeNum</span><span class="p">):</span>
    <span class="n">CanReach</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">CanReach</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span><span class="p">(</span><span class="n">CanReach</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">Arrive</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">at</span> <span class="o">=</span> <span class="n">CanReach</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">CanReach</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Arrive</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
    <span class="n">Path</span><span class="p">[</span><span class="n">at</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">CanReach</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">CanReach</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Graph</span><span class="p">[</span><span class="n">at</span><span class="p">]:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Arrive</span><span class="p">):</span>
            <span class="n">CanReach</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">length</span> <span class="o">+</span> <span class="n">Graph</span><span class="p">[</span><span class="n">at</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">j</span><span class="p">,</span><span class="n">at</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="求任意顶点间的最短路径的-floyd-算法">求任意顶点间的最短路径的 Floyd 算法</h3>

<p>基于图的邻接矩阵表示</p>

<ol>
  <li>若不允许经过任何中间点，则最短路径就是邻接矩阵</li>
  <li>允许经过第一个顶点，与邻接矩阵比较，算出最小值</li>
  <li>允许经过第一个和第二个顶点，…</li>
  <li>…</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Floyd</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span> <span class="c1"># pass point i
</span>        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span> <span class="c1">#&lt;m, n&gt;
</span>                <span class="n">old</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
                <span class="k">if</span><span class="p">(</span><span class="n">new</span> <span class="o">&lt;</span> <span class="n">old</span><span class="p">):</span>
                    <span class="n">graph</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span>
    <span class="k">return</span> <span class="n">graph</span>

<span class="n">inf</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">Graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
         <span class="p">[</span><span class="n">inf</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="n">inf</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="n">inf</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="k">print</span><span class="p">(</span><span class="n">Floyd</span><span class="p">(</span><span class="n">Graph</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="aov--aoe-网及其算法">AOV / AOE 网及其算法</h2>

<blockquote>
  <p><strong>AOV 网</strong>，又称顶点活动网(activity on vertex network)，表示各项活动之间的先后顺序关系</p>
</blockquote>

<h3 id="aov-网拓扑排序和拓扑序列">AOV 网、拓扑排序和拓扑序列</h3>

<h4 id="拓扑排序和拓扑序列">拓扑排序和拓扑序列</h4>

<blockquote>
  <p><strong>拓扑排序</strong> $S$：如果 $N$ 中存在顶点 $v_i$ 到 $v_j$ 的路径，那么 $S$ 里 $v_i$ 就排在 $v_j$ 之前</p>
</blockquote>

<p>拓扑序列<strong>不唯一</strong></p>

<p>拓扑序列<strong>不包含</strong>回路</p>

<h3 id="拓扑排序算法">拓扑排序算法</h3>

<h4 id="算法思路-2">算法思路</h4>

<ol>
  <li>从 $N$ 中选出一个入度为 0 的顶点作为序列的下一顶点</li>
  <li>从 $N$ 网中删除所选顶点及其所有的出边</li>
  <li>反复执行上述步骤，直至已经选出了所有图中的顶点</li>
</ol>

<h4 id="代码-3">代码</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># get input
</span><span class="n">temp</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()</span>
<span class="n">NodeNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">PathNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">Start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">End</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="c1"># Create Graph
</span><span class="n">Graph</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">ReGraph</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">From</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">EE</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">LE</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">Topology</span> <span class="o">=</span> <span class="p">[</span><span class="n">Start</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NodeNum</span><span class="p">):</span>
    <span class="n">Graph</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">From</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ReGraph</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="c1"># Find Topology Order
</span><span class="n">now</span> <span class="o">=</span> <span class="n">Start</span>
<span class="k">while</span> <span class="ow">not</span><span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="n">End</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">From</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">now</span> <span class="ow">in</span> <span class="n">From</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">From</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">remove</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">From</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">Topology</span><span class="p">)):</span>
            <span class="n">Next</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">Topology</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Next</span><span class="p">)</span>
    <span class="n">now</span> <span class="o">=</span> <span class="n">Next</span>
</code></pre></div></div>

<h3 id="aoe-网和关键路径">AOE 网和关键路径</h3>

<blockquote>
  <p><strong>AOE 网</strong> (Activity On Edge Network) 是另一类带权有向图</p>

  <p>抽象来看，AOE 网是一种无环带权有向图，其中：</p>

  <ul>
    <li>顶点表示<strong>事件</strong>，有向边表示<strong>活动</strong>，边上的权值表示活动的<strong>持续时间</strong></li>
    <li>图中一个顶点表示的事件，也就是它的入边所表示的活动<strong>都已完成</strong>，它的出边活动<strong>可以开始</strong>的那个状态。</li>
    <li>AOE 网中描述的活动可以<strong>并行</strong>地执行。</li>
  </ul>

  <p><strong>关键路径</strong>：完成整个工程所需的最短时间，就是从开始顶点到完成顶点的最长路径的长度。</p>
</blockquote>

<h3 id="关键路径算法">关键路径算法</h3>

<h4 id="定义变量">定义变量</h4>

<ul>
  <li>事件 $v_j$ 最早可能发生时间 $ee[j]$
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ee[0] = 0</code>（初始时间总是在 0 时刻发生）</li>
      <li><code class="language-plaintext highlighter-rouge">ee[j] = max{ee[i] + w[i, j]}</code></li>
    </ul>
  </li>
  <li>事件 $v_j$ 最迟允许发生时间 $le[j]$
    <ul>
      <li>根据已知 <code class="language-plaintext highlighter-rouge">ee[j]</code> 反向推算</li>
      <li><code class="language-plaintext highlighter-rouge">le[n - 1] = ee[n - 1]</code> （最后一个事件绝不能再延迟）</li>
      <li><code class="language-plaintext highlighter-rouge">le[i] = min{le[j] + w[i, j]}</code></li>
    </ul>
  </li>
</ul>

<h4 id="定义概念">定义概念</h4>

<ul>
  <li>关键活动
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ee[j] == le[j]</code></li>
    </ul>
  </li>
  <li>时间余量
    <ul>
      <li><code class="language-plaintext highlighter-rouge">t[j] = le[j] - ee[j]</code></li>
    </ul>
  </li>
</ul>

<h4 id="关键路径算法-1">关键路径：算法</h4>

<ol>
  <li>生成 AOE 网的一个拓扑序列</li>
  <li>按照拓扑正序，生成 <code class="language-plaintext highlighter-rouge">ee</code> 表的值</li>
  <li>按照拓扑逆序，生成 <code class="language-plaintext highlighter-rouge">le</code> 表的值</li>
  <li>将 <code class="language-plaintext highlighter-rouge">e</code> 与 <code class="language-plaintext highlighter-rouge">l</code> 一起计算，得到关键路径</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">copy</span>
<span class="k">def</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">Result</span><span class="p">,</span> <span class="n">Critical</span><span class="p">,</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">End</span>
    <span class="k">if</span><span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="n">End</span><span class="p">):</span>
        <span class="n">Result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="k">return</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Graph</span><span class="p">[</span><span class="n">now</span><span class="p">]:</span>
        <span class="k">if</span><span class="p">((</span><span class="n">i</span> <span class="ow">in</span> <span class="n">Critical</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Graph</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">EE</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">EE</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])):</span>
            <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">DFS</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
            <span class="n">path</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span>
<span class="c1"># get input
</span><span class="n">temp</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()</span>
<span class="n">NodeNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">PathNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">Start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">End</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="c1"># Create Graph
</span><span class="n">Graph</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">ReGraph</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">From</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">EE</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">LE</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">Topology</span> <span class="o">=</span> <span class="p">[</span><span class="n">Start</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NodeNum</span><span class="p">):</span>
    <span class="n">Graph</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">From</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ReGraph</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">PathNum</span><span class="p">):</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()</span>
    <span class="n">Graph</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">])][</span><span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">From</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">])].</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">ReGraph</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">])][</span><span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">Graph</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">From</span><span class="p">)</span>
<span class="c1"># Find Topology Order
</span><span class="n">now</span> <span class="o">=</span> <span class="n">Start</span>
<span class="k">while</span> <span class="ow">not</span><span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="n">End</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">From</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">now</span> <span class="ow">in</span> <span class="n">From</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">From</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">remove</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">From</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">Topology</span><span class="p">)):</span>
            <span class="n">Next</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">Topology</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Next</span><span class="p">)</span>
    <span class="n">now</span> <span class="o">=</span> <span class="n">Next</span>
<span class="k">print</span><span class="p">(</span><span class="n">Topology</span><span class="p">)</span>
<span class="c1"># Find Critical Path
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Topology</span><span class="p">:</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">Start</span><span class="p">):</span>
        <span class="n">EE</span><span class="p">[</span><span class="n">Start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">can</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ReGraph</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">can</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">EE</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">ReGraph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
        <span class="n">EE</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">can</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">EE</span><span class="p">)</span>
<span class="n">Topology</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Topology</span><span class="p">:</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">End</span><span class="p">):</span>
        <span class="n">LE</span><span class="p">[</span><span class="n">End</span><span class="p">]</span> <span class="o">=</span> <span class="n">EE</span><span class="p">[</span><span class="n">End</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">can</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Graph</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">can</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">LE</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">Graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
        <span class="n">LE</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">can</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">LE</span><span class="p">)</span>
<span class="c1"># Critical Path
</span><span class="n">Critical</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Graph</span><span class="p">:</span>
    <span class="k">if</span><span class="p">(</span><span class="n">EE</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">LE</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
        <span class="n">Critical</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="n">Result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">Start</span><span class="p">]</span>
<span class="n">DFS</span><span class="p">(</span><span class="n">Start</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="n">Result</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Result</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">Result</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="查找">查找</h1>

<h2 id="顺序查找">顺序查找</h2>

<blockquote>
  <p>从表的一端开始逐个将记录的关键字和给定K值进行比较，若某个记录的关键字和给定K值相等，查找成功；否则，若扫描完整个表，仍然没有找到相应的记录，则查找失败。</p>
</blockquote>

<h2 id="折半查找">折半查找</h2>

<blockquote>
  <p>折半查找又称为二分查找，是一种效率较高的查找方法。
前提条件：查找表中的所有记录是按关键字有序(升序或降序) 。
查找过程中，先确定待查找记录在表中的范围，然后逐步缩小范围(每次将待查记录所在区间缩小一半)，直到找到或找不到记录为止。</p>
</blockquote>

<h2 id="索引查找">索引查找</h2>

<blockquote>
  <p>分块查找(Blocking Search)又称索引顺序查找，是前面两种查找方法的综合。</p>
</blockquote>

<h3 id="索引树">索引树</h3>

<h3 id="b_树">B_树</h3>

<blockquote>
  <p>一棵 m 阶 B 树或者为空，或者具有下面特征：</p>

  <ul>
    <li>树中分支结点至多有 m-1 个排序存放的关键码。根结点至少有一个关键码，其他结点至少有 $\lfloor (m-1)/2\rfloor$ 个关键码</li>
    <li>如果一个分支节点有 j 个关键码，它就有 j + 1 棵子树，这一结点中保存的是一个序列 $&lt;p_0, k_0, p_1, k_1, …, p_{j-1}, k_{j-1}, p_j&gt;$, 其中 $k_j$ 为关键码，$p_j$ 为子结点引用，而且 $k_i$ 大于 $p_i$ 所引子树里所有的关键码，小于 $p_{i+1}$ 所引子树里所有的关键码</li>
  </ul>
</blockquote>

<p><a href="https://blog.csdn.net/sinat_36118365/article/details/103648782">B_ 树图文详解</a></p>

<h3 id="b树">B+树</h3>

<p><a href="https://blog.csdn.net/qq_26222859/article/details/80631121">B+ 树图文详解</a></p>

<h2 id="平衡二叉树-avl">平衡二叉树 AVL</h2>

<h3 id="定义和性质">定义和性质</h3>

<blockquote>
  <p><strong>平衡二叉排序树</strong>是一类特殊的二叉排序树，它或为孔数，或者其左右子树都是平衡二叉排序树，而且其左右子树的<strong>高度之差的绝对值不超过 1</strong>。</p>
</blockquote>

<p><strong>平衡因子 BF</strong>（Balance Factor）：该结点的左子树高度减去右子树高度之差，可能的取指只有 1, -1, 0</p>

<h3 id="avl-树类">AVL 树类</h3>

<blockquote>
  <p>如果能维持平衡二叉树的结构，检索操作就能在 $O(\log{n})$ 时间内完成</p>
</blockquote>

<h4 id="基本定义">基本定义</h4>

<p>为了实现 AVL 树，每个结点里需要增加一个平衡因子记录</p>

<h3 id="插入操作">插入操作</h3>

<h4 id="插入后的失衡与调整">插入后的失衡与调整</h4>

<ul>
  <li>不失衡的情况
    <ul>
      <li>若在检索树的过程中，所有途径的结点 BF 均为 0，那么实际上插入结点也不会导致失衡</li>
    </ul>
  </li>
  <li>失衡的情况
    <ul>
      <li>若失衡，则一定存在一棵包含实际插入点的<strong>最小非平衡子树</strong>，即包含新结点插入位置的、其根节点的 BF 非零的最小子树。如果插入新结点后这颗子树仍保持平衡，而且其高度不变，那么整棵二叉排序树也将保持平衡（由于该子树的高度不变，在它外面的树的结点的 BF 值都不变）。进一步说，如果插入新结点后的结构调整和 BF 值修改都能在子树内部的一条路径上完成，插入的复杂度将不超过 $O(\log{n})$</li>
      <li>类型
        <ul>
          <li>$LL$ 型调整【a 的左子树较高，新结点插入在 a 的左子树的左子树】</li>
          <li>$LR$ 型调整【a 的左子树较高，新结点插入在 a 的左子树的右子树】</li>
          <li>$RR$ 型调整【a 的右子树较高，新结点插入在 a 的左子树的右子树】</li>
          <li>$RL$ 型调整【a 的右子树较高，新结点插入在 a 的左子树的左子树】</li>
        </ul>
      </li>
      <li>在插入新结点并完成调整之后，这棵子树与插入之前这个位置上的子<strong>树高度相同</strong>，其结构变化对子树之外的部分<strong>无影响</strong>。</li>
    </ul>
  </li>
</ul>

<h4 id="llrr-失衡与调整">LL(RR) 失衡与调整</h4>

<ul>
  <li>
    <p>LL</p>

    <p><img src="/assets/images/post/image-20210109104205737.png" alt="image-20210109104205737" /></p>

    <p><img src="https://img-blog.csdnimg.cn/20191109203211331.gif" alt="在这里插入图片描述" /></p>
  </li>
  <li>
    <p>RR</p>

    <p><img src="/assets/images/post/image-20210109104640685.png" alt="image-20210109104640685" /></p>
  </li>
</ul>

<p><img src="https://img-blog.csdnimg.cn/2019110920332691.gif" alt="在这里插入图片描述" /></p>

<h4 id="lrrl-失衡和调整">LR(RL) 失衡和调整</h4>

<ul>
  <li>
    <p>LR</p>

    <p><img src="/assets/images/post/image-20210109111448478.png" alt="image-20210109111448478" /></p>
  </li>
  <li>
    <p>RL</p>

    <p><img src="/assets/images/post/image-20210111155857041.png" alt="image-20210111155857041" /></p>
  </li>
</ul>

<h4 id="插入操作的实现">插入操作的实现</h4>

<ol>
  <li>查找新结点的插入位置，并在查找过程中记录遇到的最小不平衡子树的根
    <ul>
      <li>用一个变量 a 记录距插入位置最近的平衡因子非零的结点，由于可能需要修改这棵子树，在此过程中用另一变量 pa 记录 a 的父结点</li>
      <li>如果不存在这种结点，需要考虑的 a 就是树根</li>
      <li>如果在新结点插入后出现失衡，a 就是平衡位置</li>
      <li>实际插入新结点</li>
    </ul>
  </li>
  <li>修改从 a 的子结点到新结点的路径上各结点的平衡因子
    <ul>
      <li>由于 a 的定义，这段结点原来都有 BF = 0</li>
      <li>插入后用一个扫描变量 p 从 a 的子结点开始遍历，如果新结点插入在 p 的左子树，就把 p 的平衡因子改为 1，否则改为 -1</li>
    </ul>
  </li>
  <li>检查以 a 为根的子树是否失衡，失衡时做出调整
    <ul>
      <li>如果 a.bf == 0，插入后不会失衡，简单修改平衡因子并结束</li>
      <li>如果 a.bf == 1，而且新结点插入其左子树，就出现了失衡
        <ul>
          <li>新结点在 a 的左子节点的左子树时做 LL 调整</li>
          <li>新结点在 a 的右子节点的左子树时做 LR 调整</li>
        </ul>
      </li>
      <li>如果 a.bf == -1，而且新结点插入其右子树，就出现了失衡
        <ul>
          <li>新结点在 a 的左子节点的左子树时做 RL 调整</li>
          <li>新结点在 a 的右子节点的左子树时做 RR 调整</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>连接好调整后的子树，它可能作为整棵树的根，或作为 a 原来的父节点的相应方向的子结点（左子结点或右子结点）</li>
</ol>

<h4 id="代码实现">代码实现</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AVLNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bf</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="n">bf</span>

<span class="k">def</span> <span class="nf">LL</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="c1"># LL 型调整
</span>    <span class="n">a</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">right</span>
    <span class="n">b</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">RR</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="c1"># RR 型调整
</span>    <span class="n">a</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">left</span>
    <span class="n">b</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">LR</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="c1"># LR 型调整
</span>    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">right</span>
    <span class="n">a</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">left</span>
    <span class="n">c</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># c 本身就是插入结点
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span><span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">bf</span><span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 新结点在 c 的左子树
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 新结点在 c 的右子树
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">RL</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="c1"># RL 型调整
</span>    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">left</span>
    <span class="n">a</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">right</span>
    <span class="n">c</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
    <span class="k">if</span> <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># c 本身就是新结点
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 新结点在 c 的左子树
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 新结点在 c 的右子树
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">c</span>
        
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c1"># 若是一棵空树
</span>        <span class="n">root</span> <span class="o">=</span> <span class="n">AVLNode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">pa</span> <span class="o">=</span> <span class="n">q</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># 维持 pa, q 为 a, p 的父节点
</span>    <span class="k">while</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">.</span><span class="n">bf</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pa</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span> <span class="c1"># 已知最小非平衡子树
</span>        <span class="n">q</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">right</span>
    <span class="c1"># q 是插入点的父节点, pa, a记录最小非平衡子树
</span>    <span class="n">node</span> <span class="o">=</span> <span class="n">AVLNode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">q</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span> <span class="c1"># 作为左子结点
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span> <span class="c1"># 作为右子结点
</span>    <span class="c1"># 新结点已插入，a 是最小不平衡子树
</span>    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span><span class="p">:</span> <span class="c1"># 新结点在 a 的左子树
</span>        <span class="n">p</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">left</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">right</span>
        <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># 修改 b 到新结点路径上各结点的 bf 值, b 为 a 的子结点
</span>    <span class="k">while</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span> <span class="c1"># node 一定存在，不用判断 b 空
</span>        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">value</span><span class="p">:</span> <span class="c1"># p 的左子树增高
</span>            <span class="n">p</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span>  <span class="mi">1</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">right</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># a 的原 bf 为 0，不会失衡
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="o">-</span><span class="n">d</span><span class="p">:</span> <span class="c1"># 新结点在较低子树里
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span>
    <span class="c1"># 新结点在较高子树，失衡，必须调整
</span>    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 新结点在 a 的左子树
</span>        <span class="k">if</span> <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">LL</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># LL
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">LR</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># RL
</span>    <span class="k">else</span><span class="p">:</span> <span class="c1"># 新结点在 a 的右子树
</span>        <span class="k">if</span> <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">RR</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># RR 调整
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">RL</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># RL 调整
</span>    <span class="k">if</span> <span class="n">pa</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c1"># 原 a 为树根，修改 root
</span>        <span class="n">root</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pa</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">pa</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pa</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 以下为加入一些遍历与输入操作后的代码
# -*- coding: utf-8 -*-
</span><span class="s">"""
Created on Sat Jan  9 19:45:52 2021

@author: Ericaaaaaaaa
"""</span>

<span class="k">class</span> <span class="nc">AVLNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bf</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="n">bf</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">"[AVLNode value: {0} bf: {1}]"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">bf</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">AVLNode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">pa</span> <span class="o">=</span> <span class="n">q</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># 维持 pa, q 为 a, p 的父节点
</span>    <span class="k">while</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">.</span><span class="n">bf</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pa</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span> <span class="c1"># 已知最小非平衡子树
</span>        <span class="n">q</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">right</span>
    <span class="c1"># q 是插入点的父节点, pa, a记录最小非平衡子树
</span>    <span class="n">node</span> <span class="o">=</span> <span class="n">AVLNode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">q</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span> <span class="c1"># 作为左子结点
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span> <span class="c1"># 作为右子结点
</span>    <span class="c1"># 新结点已插入，a 是最小不平衡子树
</span>    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span><span class="p">:</span> <span class="c1"># 新结点在 a 的左子树
</span>        <span class="n">p</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">left</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">right</span>
        <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># 修改 b 到新结点路径上各结点的 bf 值, b 为 a 的子结点
</span>    <span class="k">while</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span> <span class="c1"># node 一定存在，不用判断 b 空
</span>        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">value</span><span class="p">:</span> <span class="c1"># p 的左子树增高
</span>            <span class="n">p</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span>  <span class="mi">1</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">right</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># a 的原 bf 为 0，不会失衡
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="o">-</span><span class="n">d</span><span class="p">:</span> <span class="c1"># 新结点在较低子树里
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span>
    <span class="c1"># 新结点在较高子树，失衡，必须调整
</span>    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 新结点在 a 的左子树
</span>        <span class="k">if</span> <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">LL</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># LL
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">LR</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># RL
</span>    <span class="k">else</span><span class="p">:</span> <span class="c1"># 新结点在 a 的右子树
</span>        <span class="k">if</span> <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">RR</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># RR 调整
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">RL</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1"># RL 调整
</span>    <span class="k">if</span> <span class="n">pa</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c1"># 原 a 为树根，修改 root
</span>        <span class="n">root</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pa</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">pa</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pa</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span>
    
<span class="k">def</span> <span class="nf">LL</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">a</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">right</span>
    <span class="n">b</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">RR</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">a</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">left</span>
    <span class="n">b</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">LR</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">right</span>
    <span class="n">a</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">left</span>
    <span class="n">c</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># c 本身就是插入结点
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span><span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">bf</span><span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 新结点在 c 的左子树
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 新结点在 c 的右子树
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">RL</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">left</span>
    <span class="n">a</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">right</span>
    <span class="n">c</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
    <span class="k">if</span> <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># c 本身就是新结点
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 新结点在 c 的左子树
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 新结点在 c 的右子树
</span>        <span class="n">a</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">b</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">c</span><span class="p">.</span><span class="n">bf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">print_tree</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">now</span> <span class="o">=</span> <span class="n">root</span>
    <span class="k">while</span> <span class="ow">not</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">now</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">now</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">left</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">right</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span><span class="p">):</span>
            <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">right</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">right</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">right</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">"None"</span><span class="p">):</span>
            <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">now</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
<span class="n">initial</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">AVLNode</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="s">"finish"</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
        <span class="n">print_tree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="内部排序问题和性质">内部排序问题和性质</h1>

<h3 id="问题定义">问题定义</h3>

<h3 id="排序算法">排序算法</h3>

<h4 id="基于比较的排序">基于比较的排序</h4>

<h4 id="基本操作性质和评价">基本操作、性质和评价</h4>

<p>在讨论各个算法时，总是以被排序序列的长度（即序列中元素的个数）作为问题的规模参数 n</p>

<ul>
  <li>任何算法的<strong>时间复杂度</strong>都不可能优于 $O(n\log{n})$</li>
  <li>算法的性质
    <ul>
      <li><strong>稳定性</strong>：
        <ul>
          <li>对于待排序序列里的任一对排序码相同的记录 $R_i$ 和 $R_j$，在排序后的序列里 $R_i$ 和 $R_j$ 的前后顺序不变</li>
          <li>稳定性是一个具体算法的性质，而不是排序方法的性质</li>
        </ul>
      </li>
      <li><strong>适应性</strong>：
        <ul>
          <li>如果一个排序算法对接近有序的序列工作的更快，就称这种算法具有适应性</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="简单排序算法">简单排序算法</h2>

<h3 id="插入排序">插入排序</h3>

<h4 id="算法的思路">算法的思路</h4>

<ol>
  <li>从一个没有元素的列表开始</li>
  <li>选择一个未排序的元素</li>
  <li>将所选元素与列表中的元素一一比较，并插入到正确的位置</li>
  <li>重复 2、3 直至所有元素都被插入到列表中为止。</li>
</ol>

<h4 id="代码-4">代码</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span> <span class="c1"># 开始时片段 [lst[0]] 已排序
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># 选择元素
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">:</span> <span class="c1"># 逐一向前比较
</span>            <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 反序逐个后移元素，决定插入位置
</span>            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">lst</span> <span class="c1"># 有没有都行，因为 python 其实已经改变了原有的 lst 了
</span></code></pre></div></div>

<h4 id="复杂度分析">复杂度分析</h4>

<ul>
  <li><strong>平均时间复杂度</strong>： $O(n^2)$</li>
  <li><strong>最坏时间复杂度</strong>：$O(n^2)$</li>
  <li><strong>空间复杂度</strong>：$O(1)$</li>
</ul>

<h4 id="算法特性分析">算法特性分析</h4>

<ul>
  <li>
    <p>有稳定性</p>

    <blockquote>
      <p><code class="language-plaintext highlighter-rouge">lst[j-1] &gt; x</code></p>
    </blockquote>
  </li>
  <li>
    <p>有适应性</p>
  </li>
</ul>

<h4 id="改进">改进</h4>

<p>采用<strong>二分法</strong>检索插入位置</p>

<h3 id="选择排序">选择排序</h3>

<h4 id="算法思路-3">算法思路</h4>

<ol>
  <li>顺序扫描未排序序列中的元素，记住遇到的最小的元素</li>
  <li>将最小元素于未排序的第一位交换</li>
  <li>重复 1、2，直至序列排序完毕</li>
</ol>

<h4 id="代码-5">代码</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">select_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="s">"""选择排序"""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># 只需循环 len(lst) - 1 次
</span>        <span class="n">k</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span> <span class="c1"># k 是已知最小元素的位置
</span>            <span class="k">if</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lst</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span> <span class="c1"># lst[k] 是已知确定最小的元素，检查是否需要交换
</span>            <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># 交换
</span>    <span class="k">return</span> <span class="n">lst</span> <span class="c1"># 有没有都行，因为 python 其实已经改变了原有的 lst 了
</span></code></pre></div></div>

<h4 id="复杂度分析-1">复杂度分析</h4>

<ul>
  <li><strong>平均时间复杂度</strong>： $O(n^2)$</li>
  <li><strong>最坏时间复杂度</strong>：$O(n^2)$</li>
  <li><strong>空间复杂度</strong>：$O(1)$</li>
</ul>

<h4 id="算法特性分析-1">算法特性分析</h4>

<ul>
  <li>
    <p>没有适应性</p>

    <blockquote>
      <p>任何情况下的时间复杂度都是 $O(n^2)$</p>
    </blockquote>
  </li>
</ul>

<h3 id="堆排序">堆排序</h3>

<h4 id="补充知识">补充知识</h4>

<h5 id="优先队列">优先队列</h5>

<p>优先队列是一种<strong>缓存结构</strong>，保证在任何时候访问或弹出的，总是当时这个结构里保存的所有元素里<strong>优先级最高的</strong>（在存数数据时会同时存入优先级）</p>

<h5 id="树形结构和堆">树形结构和堆</h5>

<h6 id="堆及其性质">堆及其性质</h6>

<ul>
  <li>采用<strong>树形结构</strong>实现<strong>优先队列</strong>的一种有效技术称为堆。</li>
  <li>从结构上看，堆就是结点里存储数据的<strong>完全二叉树</strong></li>
  <li><strong>堆序</strong>：任意一个结点里存储的数据的优先级<strong>先于（或等于）</strong>其子节点里的数据
    <ul>
      <li>堆中优先级最高的元素必在<strong>堆顶</strong></li>
      <li>大顶堆 &amp; 小顶堆</li>
    </ul>
  </li>
</ul>

<h5 id="优先队列的堆实现">优先队列的堆实现</h5>

<h6 id="插入元素和向上筛选">插入元素和向上筛选</h6>

<h6 id="弹出元素和向下筛选">弹出元素和向下筛选</h6>

<h4 id="算法思路-4">算法思路</h4>

<h4 id="代码-6">代码</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">elems</span><span class="p">):</span> <span class="c1"># 堆排序
</span>    <span class="s">"""
    堆排序：
    采用小顶堆，因此输出顺序为从大到小
    若希望得到从小到大的输入，只需要将 ① 与 ② 处改为 "&gt;" 即可
    """</span>
    <span class="k">def</span> <span class="nf">siftdown</span><span class="p">(</span><span class="n">elems</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span> <span class="c1"># elems 按层序方式存储的堆，e 为要插入的元素（向下筛选），begin, end 为已有堆的 begin, end 下标
</span>        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">begin</span><span class="p">,</span> <span class="n">begin</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># j 为 i 的左子结点
</span>        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span> <span class="c1"># invariant: j == 2 *i + 1
</span>            <span class="k">if</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="ow">and</span> <span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> <span class="c1"># ① # 使得 j 为 i 子结点中最小的结点的下标
</span>                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># elems[j] 小于等于其兄弟结点的数据
</span>            <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> <span class="c1"># e 在三者中最小 ②
</span>                <span class="k">break</span>
            <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="c1"># elems[j] 最小，上移
</span>            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># i 下移， j 为 i 的左子结点
</span>        <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span> <span class="c1"># 将 e 放入合适的位置（i 处的元素已经被移走）
</span>        
    <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
    <span class="c1"># 循环建堆
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">end</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># 从最下层开始，逐步向上使得序列满足小顶堆条件
</span>        <span class="n">siftdown</span><span class="p">(</span><span class="n">elems</span><span class="p">,</span> <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="c1"># 循环逐个取出最小元素，将其积累在表的最后，放一个退一步
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">siftdown</span><span class="p">(</span><span class="n">elems</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="复杂度分析-2">复杂度分析</h4>

<ul>
  <li>时间复杂度：$O(n\log{n})$</li>
  <li>空间复杂度：$O(1)$</li>
</ul>

<h4 id="算法特性分析-2">算法特性分析</h4>

<h3 id="交换排序冒泡排序">交换排序（冒泡排序）</h3>

<h4 id="算法思路-5">算法思路</h4>

<p>通过交换元素<strong>消除逆序</strong></p>

<h4 id="代码-7">代码</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="s">"""冒泡排序"""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> <span class="c1"># 找到逆序
</span>                <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">found</span> <span class="o">=</span><span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span> <span class="c1"># 如果序列中已经没有逆序了
</span>            <span class="k">break</span>
    <span class="k">return</span> <span class="n">lst</span> <span class="c1"># 有没有都行，因为 python 其实已经改变了原有的 lst 了
</span></code></pre></div></div>

<h4 id="复杂度分析-3">复杂度分析</h4>

<ul>
  <li><strong>平均时间复杂度</strong>： $O(n^2)$</li>
  <li><strong>最坏时间复杂度</strong>：$O(n^2)$</li>
  <li><strong>空间复杂度</strong>：$O(1)$</li>
</ul>

<h4 id="算法特性分析-3">算法特性分析</h4>

<ul>
  <li>
    <p>有稳定性</p>
  </li>
  <li>
    <p>有适应性</p>

    <p><code class="language-plaintext highlighter-rouge">if not found:</code></p>
  </li>
</ul>

<h2 id="快速排序">快速排序</h2>

<h4 id="算法思路-6">算法思路</h4>

<ol>
  <li>若序列长度为 0 或 1，证明已经完成排序，返回，若不然，执行 2</li>
  <li>取待排序序列中的任意一个元素（通常是第一个）作为标准</li>
  <li>将其他元素与之比较，并分成【比标准小】、【比标准大】两部分</li>
  <li>将分好的两部分视为新的未排序序列，递归执行 2 操作</li>
</ol>

<h4 id="代码-8">代码</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">qsort_rec</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">return</span> <span class="c1"># 分段无记录或只有一个记录
</span>    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># lst[i] 是初始空位
</span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span> <span class="c1"># 找 pivot 的最终位置
</span>        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># 用 j 向左扫描找小于 pivot 的记录
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 小记录移到左边
</span>        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 用 i 向右扫描找大于 pivot 的记录
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># 大记录移到右边
</span>    <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pivot</span> <span class="c1"># 将 pivot 存入其最终位置
</span>    <span class="n">qsort_rec</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 递归处理左半区间
</span>    <span class="n">qsort_rec</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="c1"># 递归处理右半区间
</span>
<span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">qsort_rec</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="复杂度分析-4">复杂度分析</h4>

<ul>
  <li><strong>平均</strong>时间复杂度： $O(n\log{n})$</li>
  <li><strong>最坏</strong>时间复杂度：$O(n)$</li>
  <li>空间复杂度：$O(\log{n})$</li>
</ul>

<h4 id="算法特性分析-4">算法特性分析</h4>

<ul>
  <li>不稳定</li>
  <li>不具有适应性</li>
</ul>

<h2 id="归并排序">归并排序</h2>

<h4 id="算法思路-7">算法思路</h4>

<ol>
  <li>开始时，将每个记录看成单独的有序序列，则 n 个待排序的记录就是 n 个长度为 1 的有序子序列</li>
  <li>对所有有序子序列进行两两归并，得到 n/2 个长度为 2 或 1 的有序子序列——一趟归并</li>
  <li>重复 2，直到得到长度为 n 的有序序列为止。</li>
</ol>

<h4 id="代码-9">代码</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">lfrom</span><span class="p">,</span> <span class="n">lto</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">):</span>
    <span class="s">"""
    归并排序最下层函数
    实现表中相邻的一对有序序列的归并工作，将归并的结果存入另一个顺序表里的相同位置
    需要归并的两有序段分别为：lfrom[low:mid] 和 lfrom[mid:high]
    归并结果应存入 lto[low:high]
    """</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">low</span> <span class="c1"># i, j 遍历两个有序子序列，k 写入结果序列
</span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">:</span> <span class="c1"># 反复赋值两分段首最小的
</span>        <span class="k">if</span> <span class="n">lfrom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lfrom</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">lto</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfrom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lto</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfrom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">:</span> <span class="c1"># 复制第一段剩余记录
</span>        <span class="n">lto</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfrom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">:</span> <span class="c1"># 复制第二段剩余记录
</span>        <span class="n">lto</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfrom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        
<span class="k">def</span> <span class="nf">merge_pass</span><span class="p">(</span><span class="n">lfrom</span><span class="p">,</span> <span class="n">lto</span><span class="p">,</span> <span class="n">llen</span><span class="p">,</span> <span class="n">slen</span><span class="p">):</span>
    <span class="s">"""
    归并排序中间层函数
    实现对整个表里顺序各对有序序列的归并，完成一遍归并，
    各对序列的归并结果顺序存入另一顺序表里的同位置分段
    slen: 需要归并的每小段长度
    llen: 序列总长度
    """</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slen</span> <span class="o">&lt;</span> <span class="n">llen</span><span class="p">:</span> <span class="c1"># 归并长 slen 的两段
</span>        <span class="n">merge</span><span class="p">(</span><span class="n">lfrom</span><span class="p">,</span> <span class="n">lto</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">slen</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slen</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slen</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">slen</span> <span class="o">&lt;</span> <span class="n">llen</span><span class="p">:</span> <span class="c1"># 剩下两端，后段长度小于 slen
</span>        <span class="n">merge</span><span class="p">(</span><span class="n">lfrom</span><span class="p">,</span> <span class="n">lto</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">slen</span><span class="p">,</span> <span class="n">llen</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 只剩下一段，复制给表 lto
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">llen</span><span class="p">):</span>
            <span class="n">lto</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfrom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            
<span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="s">"""
    归并排序主函数（最顶层函数）
    在两个顺序表中往复执行中间层操作，直至排序全部完成
    """</span>
    <span class="n">slen</span><span class="p">,</span> <span class="n">llen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
    <span class="n">templst</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">llen</span>
    <span class="k">while</span> <span class="n">slen</span> <span class="o">&lt;</span> <span class="n">llen</span><span class="p">:</span> <span class="c1"># 未形成长度为总长度的顺序序列
</span>        <span class="n">merge_pass</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">templst</span><span class="p">,</span> <span class="n">llen</span><span class="p">,</span> <span class="n">slen</span><span class="p">)</span>
        <span class="n">slen</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="c1"># 排序完成时，结果可能存放在 templst 中，无论如何，再执行一次下一步，将结果存回 lst 中
</span>        <span class="n">merge_pass</span><span class="p">(</span><span class="n">templst</span><span class="p">,</span> <span class="n">lst</span><span class="p">,</span> <span class="n">llen</span><span class="p">,</span> <span class="n">slen</span><span class="p">)</span> <span class="c1"># 结果存回原位
</span>        <span class="n">slen</span> <span class="o">*=</span> <span class="mi">2</span>
</code></pre></div></div>

<h4 id="复杂度分析-5">复杂度分析</h4>

<ul>
  <li>时间复杂度：$O(n\log{n})$</li>
  <li>空间复杂度：$O(n)$</li>
</ul>

<h4 id="算法特性分析-5">算法特性分析</h4>

<ul>
  <li>有稳定性</li>
  <li>无适应性</li>
</ul>

<h2 id="其他排序方法">其他排序方法</h2>

<h3 id="分配排序和基数排序">分配排序和基数排序</h3>

<h4 id="算法思路-8">算法思路</h4>

<p>如果关键码只有很少几个不同的值，</p>

<ol>
  <li>为每个关键码设置一个桶</li>
  <li>遍历序列，根据关键码把记录放在不同的桶中</li>
  <li>顺序手机各个桶的记录，得到排序的序列</li>
</ol>

<h4 id="复杂度分析-6">复杂度分析</h4>

<ul>
  <li>时间复杂度：$O(n)$</li>
  <li>空间复杂度：$O(n)$</li>
</ul>

<h3 id="多轮分配和排序">多轮分配和排序</h3>

<h4 id="算法思路-9">算法思路</h4>

<ul>
  <li>高位优先（Most Significant Digit first, MSD）</li>
  <li>低位优先（Least Significant Digit first, LSD）</li>
</ul>

<h3 id="希尔排序-shell-sort">希尔排序 Shell Sort</h3>

<h4 id="算法思路-10">算法思路</h4>

<ol>
  <li>先取一个正整数d1(d1&lt;n)作为第一个增量，将全部n个记录分成d1组，把所有相隔d1的记录放在一组中，即对于每个k(k=1, 2,  … d1)，R[k], R[d1+k], R[2d1+k] , …分在同一组中，在各组内进行直接插入排序。这样一次分组和排序过程称为一趟希尔排序；</li>
  <li>取新的增量d2&lt;d1，重复 1 的分组和排序操作；直至所取的增量di=1为止，即所有记录放进一个组中排序为止。</li>
</ol>

<p><img src="/assets/images/post/image-20210106192442516.png" alt="image-20210106192442516" /></p>

<p><img src="/assets/images/post/image-20210106193116456.png" alt="image-20210106193116456" /></p>

<h1 id="外部排序">外部排序</h1>

<h2 id="文件">文件</h2>

<h3 id="文件的组织方式">文件的组织方式</h3>

<h4 id="顺序文件">顺序文件</h4>

<h4 id="索引文件">索引文件</h4>

<p>索引结构(称为索引文件)由<strong>索引表</strong>和数据表两部分</p>

<ul>
  <li>数据表：存储实际的数据记录</li>
  <li>索引表：存储记录的关键字和记录(存储)地址之间的对照表，每个元素称为一个索引项</li>
</ul>

<h5 id="稠密索引">稠密索引</h5>

<h5 id="非稠密索引">非稠密索引</h5>

<h3 id="isam">ISAM</h3>

<blockquote>
  <p><strong>ISAM</strong>(Indexed Sequential Access Method，<strong>顺序索引存取方法</strong>)，是专为<strong>磁盘</strong>存取设计的一种文件组织方式，采用<strong>静态</strong>索引结构，是一种三级索引结构的顺序文件。</p>
</blockquote>

<p><img src="/assets/images/post/image-20210106203126494.png" alt="image-20210106203126494" /></p>

<p><img src="/assets/images/post/image-20210106203143277.png" alt="image-20210106203143277" /></p>

<h3 id="vsam">VSAM</h3>

<blockquote>
  <p><strong>VSAM</strong>(Virtual Storage Access Method，<strong>虚拟存取方法</strong>)，也是一种索引顺序文件组织方式，利用OS的虚拟存储器功能，采用的是基于B+树的动态索引结构。</p>
</blockquote>

<p><img src="/assets/images/post/image-20210106203231777.png" alt="image-20210106203231777" /><img src="/assets/images/post/image-20210106203249607.png" alt="image-20210106203249607" /></p>

<h3 id="散列文件">散列文件</h3>

<blockquote>
  <p><strong>散列文件</strong>(直接存取文件) ：利用散列存储方式组织的文件。类似散列表，即根据文件中记录关键字的特点，设计一个散列函数和冲突处理方法，将记录散列到存储介质上。</p>
</blockquote>

<h3 id="多关键字文件">多关键字文件</h3>

<h3 id="多重表文件">多重表文件</h3>

<blockquote>
  <p><strong>多重表文件</strong>(Multilist Files)的特点是：记录按主关键字的顺序构成一个串联文件(物理上的) ，并建立主关键字索引(称为主索引)；对每个次关键字都建立次关键字索引(称为次索引)，所有具有同一次关键字值的记录构成一个链表(逻辑上的)。</p>
</blockquote>

<h3 id="倒排文件">倒排文件</h3>

<blockquote>
  <p><strong>倒排文件</strong>又称逆转表文件。与多重表文件类似，可以处理多关键字查询。</p>
</blockquote>

<h2 id="外部排序-1">外部排序</h2>

<blockquote>
  <p>外部排序最基本的方法是归并。这种方法是由两个相对独立的阶段组成：
① 按内存(缓冲区)的大小，将n个记录的数据文件分成若干个长度为l的段或子文件，依次读入内存并选择有效的内部排序方法进行排序；然后将排好序的有序子文件重新写入到外存。子文件称为归并段或顺串。
② 采用归并的办法对归并段进行逐趟归并，使归并段的长度逐渐增大，直到最后合并成只有一个归并段的文件—排好序的文件。</p>
</blockquote>

<h2 id="内存管理">内存管理</h2>

<h3 id="兄弟伙伴算法">兄弟伙伴算法</h3>

<blockquote>
  <p><strong>伙伴系统</strong>是一种<strong>非顺序</strong>内存管理方法，不是以顺序片段来分配内存，是把内存分为两个部分，只要有可能，这两部分就可以合并在一起; 且这两部分从来不是自由的，程序可以使用伙伴系统中的一部分或者两部分都不使用。与边界标识法类似，所不同是：无论占用块或空闲块，其大小均为2的k次幂。</p>
</blockquote>

<blockquote>
  <p>当程序释放所占用的块时，系统将该新的空闲块插入到可利用空闲表中，需要考虑合并成大块问题。在伙伴系统中，只有“互为伙伴”的两个子块均空闲时才合并；即使有两个相邻且大小相同的空闲块，如果不是“互为伙伴” (从同一个大块中分裂出来的)也不合并。</p>
</blockquote>

<blockquote>
  <p>设要回收的空闲块的首地址是p，其大小为2k的，算法思想是：
⑴ 判断其 “互为伙伴”的两个空闲块是否为空：
若不为空，仅将要回收的空闲块直接插入到相应的子表中；否则转⑵；
⑵  按以下步骤进行空闲块的合并：
◆ 在相应子表中找到其伙伴并删除之；
◆ 合并两个空闲块；
⑶ 重复⑵，直到合并后的空闲块的伙伴不是空闲块为止。6</p>
</blockquote>]]></content><author><name>ericaaaaaaaa</name></author><category term="Data" /><category term="note" /><category term="data-structure" /><category term="data" /><category term="algorithm" /><summary type="html"><![CDATA[线性表]]></summary></entry></feed>